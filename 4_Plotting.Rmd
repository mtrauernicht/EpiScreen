---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  pdf_document:
    toc: yes
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(modelr)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

```


## Data import
```{r data import}
setwd("~/mydata/EpiScreen/epigenetic-screening-on-trip-clone/Data/")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20190125RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,47,54,55,119:124,127)]

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```

## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
indel.data <- merge(mean.ratio.data, indel.data)

setnames(indel.data, old = ".id", new = "condition")
setnames(indel.data, old = "rn", new = "barcode")

# Remove weird barcode?
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG",]

# We want to exclude cells that died right after drug addition: set viability cut-off at max. value of the PAO
indel.data <- indel.data[indel.data$viability > 7200,]

# Also, we want to exclude remaining barcodes with very low reads
indel.data <- indel.data[indel.data$read.count1.7 > 20,]


# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]


# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"

# Select reps
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$condition)
indel.data$rep.group <- "1"
indel.data[grep("10um_.*_plate2", indel.data$condition),]$rep.group <- "2"
indel.data[grep("1um_.*_plate1", indel.data$condition),]$rep.group <- "3"
indel.data[grep("1um_.*_plate2", indel.data$condition),]$rep.group <- "4"
indel.data[grep("100nm_.*_plate1", indel.data$condition),]$rep.group <- "5"
indel.data[grep("100nm_.*_plate2", indel.data$condition),]$rep.group <- "6"

```


# Analysis

## Data analysis
```{r data analysis}
# Perform statistical test to remove not significant hits
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Calculate mean values per group
# Mean ratio per barcode
indel.data$mean.ratio.new <- ave(indel.data$ratio, indel.data$barcode, FUN = function(x) mean(x))
# Mean ratio per target group
indel.data$mean.ratio.target <- ave(indel.data$ratio, indel.data$Target, FUN = function(x) mean(x))
# Mean efficiency per target group
indel.data$mean.eff <- ave(indel.data$efficiency, indel.data$Target, FUN = function(x) mean(x))
# Mean viability per target group
indel.data$mean.viability <- ave(indel.data$viability, indel.data$Target, FUN = function(x) mean(x))

# Calculate the chi square scores
indel.data$chisq <- ave(indel.data$logratio, indel.data$barcode, 
                      FUN=function(x) scores(x, type = "chisq"))

# Combine the three replicates
indel.data.rep1 <- indel.data[grep("rep1", indel.data$condition),]
indel.data.rep2 <- indel.data[grep("rep2", indel.data$condition),]
indel.data.rep3 <- indel.data[grep("rep3", indel.data$condition),]
indel.data.rep2 <- indel.data.rep2[,c(1,20,22)]
indel.data.rep3 <- indel.data.rep3[,c(1,20,22)]
setnames(indel.data.rep2, old = "logratio", new = "rep2_logratio")
setnames(indel.data.rep3, old = "logratio", new = "rep3_logratio")
indel.data <- merge(indel.data.rep1, indel.data.rep2, all = TRUE)
indel.data <- merge(indel.data, indel.data.rep3, all = TRUE)
indel.data$logratio.comb <- (indel.data$logratio + indel.data$rep2_logratio + indel.data$rep3_logratio) / 3

HDM.df <- indel.data[grep("Histone demethylase|Negative control", indel.data$Target),]
ERD.df <- indel.data[grep("Epigenetic Reader Domain|Negative control", indel.data$Target),]

# Create an outlier dataframe
outlier.df <- indel.data[indel.data$chisq > 3.841,] 
outlier.df <- outlier.df[-grep("DNA-PK", outlier.df$Target),]
indel.data$mean.ratio.new <- ave(indel.data$ratio, indel.data$barcode, FUN = function(x) mean(x))


```

## Visualization
```{r visualization}
# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = aes(x = barcode, y = logratio, 
                                 colour = ifelse(chisq > 3.841,'blue','red'))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")

# ggplot specifying group of drugs
ggplot(data = indel.data) +
  geom_quasirandom(mapping = aes(x = barcode, y = logratio, colour = Target)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")

# ggplot specifying the drug ratio
ggplot(data = indel.data, aes(x = barcode, y = logratio, colour = conc)) +
  geom_quasirandom() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("Log2(+1/-7 ratio))") + xlab("Barcode")

# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio, colour = Target)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")
  print(p)
}

# Same as before, colour indicates number of reads
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio, shape = Target, colour = read.count1.7)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")
  print(p)
}

# Boxplot of efficiencies 
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) 

# Correlation efficiency vs +1/-7 ratio
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=logratio, y=efficiency, colour = Target))

# Correlation mean efficiency vs mean ratio
ggplot(data = indel.data, aes(x=mean.ratio.target, y=mean.eff)) +
    geom_point() + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation plot viability vs. efficiency
ggplot(data = indel.data, aes(x=viability, y=efficiency)) +
  geom_point() + geom_smooth(method = lm)

# Correlation plot mean viability vs. mean efficiency
ggplot(data = indel.data, aes(x=mean.viability, y=mean.eff)) +
  geom_point() + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation viability vs. +1/-7 ratio
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=viability, y=logratio, colour = Target))

# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
ggplot(data = indel.data[indel.data$Target == "Negative control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.new))) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) + scale_x_continuous(breaks=c(2, 4, 6, 8))

# Correlation IC50 vs viability
ggplot(data = indel.data, aes(x=viability, y=IC50..µM., colour = conc)) +
  geom_point()
ggplot(data = indel.data, aes(x=viability, y=IC50..µM., colour = conc)) +
  geom_point() + scale_y_continuous(limits = c(0, 5))

correlation.plot <- indel.data[,c(24,25,26)]
pairs(correlation.plot)

# Correlation rep1 vs rep2
ggplot(data = indel.data, aes(x=logratio, y=rep2_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep1 vs rep3
ggplot(data = indel.data, aes(x=logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep2 vs rep3 per group
ggplot(data = indel.data, aes(x=rep2_logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation matrix plot
correlation.plot.rep <- indel.data[,c(22,28,29)]
pairs(correlation.plot.rep)

# Correlation plot plate 1uM_plate1
correlation.plot.weird.plate <- indel.data[grep("1um_.*_plate1",indel.data$condition),]
correlation.plot.weird.plate <- correlation.plot.weird.plate[,c(22,28,29)]
pairs(correlation.plot.weird.plate)

# Correlation reads vs. viability
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=read.count, y=viability, colour = plate.nr))

# Outlier plot
ggplot(data = outlier.df) + 
  geom_point(mapping = aes(x = barcode, y = logratio, colour = Target)) + 
  geom_step(data = indel.data, mapping = aes(x = barcode, y = logratio)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))
```
We can see that there is a very high correlation between all 3 replicates, even when you look at the plates which have shifted amounts of reads (some wells have very low amount of reads and others have very high amounts of reads), meaning that we can use the data of all 3 replicates.
```


# Results
```{r}

```

# Conclusions
```{r}
```

## Exporting potential data. 
```{r}
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

