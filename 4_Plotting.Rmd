---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

```


## Data import
```{r data import}
setwd("~/mydata/EpiScreen/epigenetic-screening-on-trip-clone/")
# Import data from preprocessing script
RSTP2_200_indels.df <- get(load("mt20190124RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,119:122,124,125)]
# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```

## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
indel.data <- merge(mean.ratio.data, indel.data)

# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]
```


# Analysis

## Data analysis
```{r data analysis}
# Perform statistical test to remove not significant hits
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Calculate mean ratios
indel.data$mean.ratio.new <- ave(indel.data$ratio, indel.data$rn, FUN = function(x) mean(x))

# Calculate the chi square scores
indel.data$chisq <- ave(indel.data$logratio, indel.data$rn, 
                      FUN=function(x) scores(x, type = "chisq"))

# Add plate specifier
# indel.data$plate.nr <- "1"
# indel.data[grep("10um_rep1_plate2", indel.data$.id),]$plate.nr <- "2"
# indel.data[grep("10um_rep2_plate1", indel.data$.id),]$plate.nr <- "3"
# indel.data[grep("10um_rep2_plate2", indel.data$.id),]$plate.nr <- "4"
# indel.data[grep("10um_rep3_plate1", indel.data$.id),]$plate.nr <- "5"
# indel.data[grep("10um_rep3_plate2", indel.data$.id),]$plate.nr <- "6"
# indel.data[grep("1um_rep1_plate1", indel.data$.id),]$plate.nr <- "7"
# indel.data[grep("1um_rep1_plate2", indel.data$.id),]$plate.nr <- "8"
# indel.data[grep("1um_rep2_plate1", indel.data$.id),]$plate.nr <- "9"
# indel.data[grep("1um_rep2_plate2", indel.data$.id),]$plate.nr <- "10"
# indel.data[grep("1um_rep3_plate1", indel.data$.id),]$plate.nr <- "11"
# indel.data[grep("1um_rep3_plate2", indel.data$.id),]$plate.nr <- "12"
# indel.data[grep("100nm_rep1_plate1", indel.data$.id),]$plate.nr <- "13"
# indel.data[grep("100nm_rep1_plate2", indel.data$.id),]$plate.nr <- "14"
# indel.data[grep("100nm_rep2_plate1", indel.data$.id),]$plate.nr <- "15"
# indel.data[grep("100nm_rep2_plate2", indel.data$.id),]$plate.nr <- "16"
# indel.data[grep("100nm_rep3_plate1", indel.data$.id),]$plate.nr <- "17"
# indel.data[grep("100nm_rep3_plate2", indel.data$.id),]$plate.nr <- "18"

# Select reps
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$.id)

indel.data$rep.group <- "1"
indel.data[grep("10um_.*_plate2", indel.data$.id),]$rep.group <- "2"
indel.data[grep("1um_.*_plate1", indel.data$.id),]$rep.group <- "3"
indel.data[grep("1um_.*_plate2", indel.data$.id),]$rep.group <- "4"
indel.data[grep("100nm_.*_plate1", indel.data$.id),]$rep.group <- "5"
indel.data[grep("100nm_.*_plate2", indel.data$.id),]$rep.group <- "6"


indel.data.rep1 <- indel.data[grep("rep1", indel.data$.id),]
indel.data.rep2 <- indel.data[grep("rep2", indel.data$.id),]
indel.data.rep3 <- indel.data[grep("rep3", indel.data$.id),]
indel.data.rep2 <- indel.data.rep2[,c(1,15,18,19)]
indel.data.rep3 <- indel.data.rep3[,c(1,15,18,19)]
setnames(indel.data.rep2, old = "logratio", new = "rep2_logratio")
setnames(indel.data.rep3, old = "logratio", new = "rep3_logratio")
indel.data.rep4 <- merge(indel.data.rep1, indel.data.rep2)
indel.data.rep4 <- merge(indel.data.rep4, indel.data.rep3)


```

## Visualization
```{r visualization}
# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = aes(x = rn, y = logratio, 
                                 colour = ifelse(chisq > 3.841,'blue','red'))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")

# ggplot specifying group of drugs
ggplot(data = indel.data) +
  geom_quasirandom(mapping = aes(x = rn, y = logratio, colour = Target)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")

# ggplot specifying the drug ratio
ggplot(data = indel.data, aes(x = rn, y = logratio, colour = conc)) +
  geom_quasirandom() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("Log2(+1/-7 ratio))") + xlab("Barcode")

# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = rn, y = logratio, colour = Target)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("Log2(+1/-7 ratio))") + xlab("Barcode") + labs(fill="titel")
  print(p)
}

# Boxplot of efficiencies 
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = rn, y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) 

# Correlation plot viability vs. efficiency
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=viability, y=efficiency, colour = Target))

# Correlation viability vs. +1/-7 ratio
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=viability, y=logratio, colour = Target))

# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
ggplot(data = indel.data[indel.data$Target == "Negative control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.new))) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) + scale_x_continuous(breaks=c(2, 4, 6, 8))

# Correlation IC50 vs viability
ggplot(data = indel.data, aes(x=viability, y=IC50..µM., colour = conc)) +
  geom_point()
ggplot(data = indel.data, aes(x=viability, y=IC50..µM., colour = conc)) +
  geom_point() + scale_y_continuous(limits = c(0, 5))

# Correlation rep1 vs rep2
ggplot(data = indel.data.rep4, aes(x=logratio, y=rep2_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep1 vs rep3
ggplot(data = indel.data.rep4, aes(x=logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep2 vs rep3 per group
ggplot(data = indel.data.rep4, aes(x=rep2_logratio, y=rep3_logratio, colour = rep.group)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 
```


# Results
```{r}

```

# Conclusions
```{r}
```

## Exporting potential data. 
```{r}
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

