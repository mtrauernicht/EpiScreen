---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup, echo = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(Laurae)
library(ggpubr)
```

### Custom functions
Functions used thoughout this script.
```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

```


## Data import
```{r data import, echo = FALSE, warning = FALSE}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20200501_RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df %>%
  select(Number, Drug, Target, `IC50..ÂµM.`, `.id`, V2, X.7, X0, X1, rep, 
         plate, conc, ratio, read.count, read.count1.7, efficiency, MMEJ_score)
indel.data.all <- RSTP2_2000_indels.df %>% 
  select(Number, Drug, Target, `IC50..ÂµM.`, `.id`, V2, X.7, X.6, X.5, X.4,
         X.3, X.2, X.1, X0, X1, rep, plate, conc, ratio, read.count, read.count1.7,
         efficiency, MMEJ_score)
integrations <- read.table("barcode_order.txt", header = T)

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
viability.comp <- read.csv2("mt20200618_viability_rep1-2.csv")
viability <- read.csv2("EpiscreenAllPlates.csv")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```
## Visualize viability data
```{r viability_overview, echo = FALSE, warning = FALSE}
# Compute relative viability per plate
viability.df <- melt(viability) %>% 
  mutate(value = ave(value, variable, FUN = function(x) x/max(x)))

for (i in unique(viability.df$variable)) {
p <- raw_grid(data = viability.df$value[viability.df$variable == i],
       well = viability.df$X[viability.df$variable == i],
       plate_id = viability.df$variable[viability.df$variable == i])
print(p)
}
```


## Compare viability data rep 1 & rep 2
```{r}
viability.comp$plate.nr <- "1"
viability.comp[grep("10um_rep1_plate2", viability.comp$.id),]$plate.nr <- "2"
viability.comp[grep("10um_rep2_plate1", viability.comp$.id),]$plate.nr <- "3"
viability.comp[grep("10um_rep2_plate2", viability.comp$.id),]$plate.nr <- "4"
viability.comp[grep("10um_rep3_plate1", viability.comp$.id),]$plate.nr <- "5"
viability.comp[grep("10um_rep3_plate2", viability.comp$.id),]$plate.nr <- "6"
viability.comp[grep("1um_rep1_plate1", viability.comp$.id),]$plate.nr <- "7"
viability.comp[grep("1um_rep1_plate2", viability.comp$.id),]$plate.nr <- "8"
viability.comp[grep("1um_rep2_plate1", viability.comp$.id),]$plate.nr <- "9"
viability.comp[grep("1um_rep2_plate2", viability.comp$.id),]$plate.nr <- "10"
viability.comp[grep("1um_rep3_plate1", viability.comp$.id),]$plate.nr <- "11"
viability.comp[grep("1um_rep3_plate2", viability.comp$.id),]$plate.nr <- "12"
viability.comp[grep("100nm_rep1_plate1", viability.comp$.id),]$plate.nr <- "13"
viability.comp[grep("100nm_rep1_plate2", viability.comp$.id),]$plate.nr <- "14"
viability.comp[grep("100nm_rep2_plate1", viability.comp$.id),]$plate.nr <- "15"
viability.comp[grep("100nm_rep2_plate2", viability.comp$.id),]$plate.nr <- "16"
viability.comp[grep("100nm_rep3_plate1", viability.comp$.id),]$plate.nr <- "17"
viability.comp[grep("100nm_rep3_plate2", viability.comp$.id),]$plate.nr <- "18"

viability.comp <- viability.comp %>% 
  mutate(viability = ave(viability, plate.nr, FUN = function(x) x/max(x)),
         X = ave(X, plate.nr, FUN = function(x) x/max(x)))

mirin <- c("_C1_", "_G1_", "_C12_", "_G12_")

viability.comp.drugs <- viability.comp[-grep(paste(mirin, collapse = "|"), viability.comp$.id),]


pao <- c("_A1_", "_E1_", "_A12_", "_E12_")

viability.comp.drugs <- viability.comp[-grep(paste(pao, collapse = "|"), viability.comp$.id),]

sp <- ggscatter(viability.comp.drugs, x = "viability", y = "X",
                color = ifelse(viability.comp.drugs$X > 0.5 & 
                                 viability.comp.drugs$viability > 0.5, "black", "red"),
   add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "viability episcreen rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")
sp + stat_cor(method = "pearson", label.x = 0.25, label.y = 1) + geom_abline(linetype = "dashed") 


# Plot next to each other to visualize cutoff

```




## Data pre-processing - clean up dataframe and add important specifiers
```{r pre-processing, echo = FALSE, warning = FALSE}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) %>% 
  setnames(old = "V2", new = "rn")

# Add previously estimated +1/-7 ratio data for correlation check-ups, rename columns
indel.data <- merge(mean.ratio.data, indel.data, all = T) %>%
  setnames(c(".id", "rn"), c("condition", "barcode"))
all.indel.data <- indel.data

# Remove barcodes with abnormal counts from analysis
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG" &
                           indel.data$barcode != "CTCTTAATCGCTGCC",]


# Set a threshold on minimun +1 and -7 read counts to exclude noisy data
low.indel.count <- indel.data[indel.data$read.count1.7 < 30,]
low.indel.count <- low.indel.count[low.indel.count$X0 > 100,]
low.indel.count <- low.indel.count[!low.indel.count$Drug %in% "PAO",]

indel.data <- indel.data[indel.data$read.count1.7 > 30,]

# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]

# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"

## Compute some useful entities for data analysis

indel.data <- indel.data %>% 
  mutate(logratio = ave(ratio, FUN = function(x) log2(x)), # log2(+1/-7)ratio
         viability = ave(viability, plate.nr, FUN = function(x) x/max(x)), # relative viability
         classifier = gsub("_rep[0-9]", "\\1", indel.data$condition), # classifier for df operations
         uniqueID = paste(indel.data$barcode, indel.data$classifier, sep = "_")) # unique well ID

# We want to exclude reads from cells that have reduced viability (set cut-off at 45% reduced viability)
indel.data <- indel.data[indel.data$viability > 0.45,]


# Optional: Exclude data completely (remove the remaining datapoint) if 2 out of 3 replicates were already excluded untill now
## indel.data <- indel.data[indel.data$uniqueID %in% names(which(table(indel.data$uniqueID) > 1)), ]
```



# Analysis

## Data analysis - normalize logratios
```{r plate_normalization, echo = FALSE, warning = FALSE}
## Normalize the data
# Plate normalization: substract log2(DMSO.mean)ratio from log2(drug)ratio per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- mean(indel.data$logratio[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$logratio.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$logratio[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.mean
  }
}

# Plate normalization for efficiency
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.eff.mean <- mean(indel.data$efficiency[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$efficiency.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <-
    indel.data$efficiency[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.eff.mean
  }
}

# Plate normalization for MMEJ score
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.MMEJ_score <- mean(indel.data$MMEJ_score[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$MMEJ_score_norm[indel.data$plate.nr == i & indel.data$barcode == j] <-
    indel.data$MMEJ_score[indel.data$plate.nr == i & indel.data$barcode == j] /
    dmso.MMEJ_score
  }
}

```

## Compute z-scores
```{r plate_normalization, echo = FALSE, warning = FALSE}
# For each drug compute the z-score of the MMEJ score
## Check if we have normally distributed DMSO data
qqnorm(indel.data$MMEJ_score[indel.data$Drug == "DMSO"])
qqnorm(indel.data$efficiency[indel.data$Drug == "DMSO"])

## MMEJ_score z-score
for (i in unique(indel.data$Drug)) {
  for (j in unique(indel.data$conc)) {
    indel.data$MMEJ_zscore[indel.data$Drug == i & indel.data$conc == j] <-
      (indel.data$MMEJ_score_norm[indel.data$Drug == i & indel.data$conc == j] -
      mean(indel.data$MMEJ_score_norm[indel.data$Drug == "DMSO" & indel.data$conc == j])) / 
      sd(indel.data$MMEJ_score_norm[indel.data$Drug == "DMSO" & indel.data$conc == j])
  }
} 

## Efficiency z-score
for (i in unique(indel.data$Drug)) {
  for (j in unique(indel.data$conc)) {
    indel.data$efficiency_zscore[indel.data$Drug == i & indel.data$conc == j] <-
      (indel.data$efficiency.platenorm[indel.data$Drug == i & indel.data$conc == j] -
      mean(indel.data$efficiency.platenorm[indel.data$Drug == "DMSO" & indel.data$conc == j])) / 
      sd(indel.data$efficiency.platenorm[indel.data$Drug == "DMSO" & indel.data$conc == j])
  }
} 

```



## Perform statistical tests
```{r t_test, echo = FALSE, warning = FALSE}
## Perform t-tests - save in different file

# t-test for target groups
indel.data.aurora <- indel.data[indel.data$Target == "Aurora Kinase" |
                            indel.data$Drug == "DMSO" &
                            indel.data$conc == "1um",]
indel.data.aurora$logratio.drug <- ave(indel.data.aurora$logratio.platenorm, 
                                 indel.data.aurora$Target,
                                 indel.data.aurora$rep,
                                 FUN = function(x) mean(x))
indel.data.aurora <- indel.data.aurora %>% select(Target, rep, logratio.drug) %>% unique()
indel.data.aurora$mean <- ave(indel.data.aurora$logratio.drug, indel.data.aurora$Target, FUN = function(x) mean(x))
indel.data.aurora$sd <- ave(indel.data.aurora$logratio.drug, indel.data.aurora$Target, FUN = function(x) sd(x))

for (i in unique(indel.data.aurora$Target)) {
    x <- indel.data.aurora[indel.data.aurora$Target == "Negative Control",]
    y <- indel.data.aurora[indel.data.aurora$Target == "Aurora Kinase",]
    
    if (nrow(y)>1) {
    indel.data.aurora$p.value[indel.data.aurora$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data.aurora$statistic[indel.data.aurora$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data.aurora$conf.int1[indel.data.aurora$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data.aurora$conf.int2[indel.data.aurora$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}


# Select relevant data
indel.data.aurora <- indel.data.aurora %>% select(Target, mean, sd, p.value) %>% unique()


# t-test for controls
indel.data.controls <- indel.data[indel.data$Drug == "DNA-PKi" |
                            indel.data$Drug == "DMSO" |
                            indel.data$Drug == "Mirin",]
indel.data.controls$logratio.drug <- ave(indel.data.controls$logratio.platenorm, 
                                 indel.data.controls$Drug,
                                 indel.data.controls$rep, FUN = function(x) mean(x))
indel.data.controls <- indel.data.controls %>% select(Drug, rep, logratio.drug) %>% unique()
indel.data.controls$mean <- ave(indel.data.controls$logratio.drug, indel.data.controls$Drug,  FUN = function(x) mean(x))
indel.data.controls$sd <- ave(indel.data.controls$logratio.drug, indel.data.controls$Drug,  FUN = function(x) sd(x))

for (i in unique(indel.data.controls$Drug)) {
    x <- indel.data.controls[indel.data.controls$Drug == "DMSO",]
    y <- indel.data.controls[indel.data.controls$Drug == i,]
    
    if (nrow(y)>1) {
    indel.data.controls$p.value[indel.data.controls$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data.controls$statistic[indel.data.controls$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data.controls$conf.int1[indel.data.controls$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data.controls$conf.int2[indel.data.controls$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}


# Select relevant data
indel.data.controls <- indel.data.controls %>% select(Drug, mean, sd, p.value) %>% unique()


# t-test for individual drugs
indel.data.drugs <- indel.data
indel.data.drugs$logratio.drug <- ave(indel.data.drugs$logratio.platenorm, 
                                 indel.data.drugs$Drug, indel.data$conc,
                                 indel.data.drugs$rep, FUN = function(x) mean(x))
indel.data.drugs <- indel.data.drugs %>% select(Drug, rep, conc, logratio.drug) %>% unique()
indel.data.drugs$mean <- ave(indel.data.drugs$logratio.drug, indel.data.drugs$Drug, indel.data.drugs$conc, FUN = function(x) mean(x))
indel.data.drugs$sd <- ave(indel.data.drugs$logratio.drug, indel.data.drugs$Drug, indel.data.drugs$conc, FUN = function(x) sd(x))

for (j in unique(indel.data.drugs$conc)) {
for (i in unique(indel.data.drugs$Drug)) {
    x <- indel.data.drugs[indel.data.drugs$Drug == "DMSO" & indel.data.drugs$conc == j,]
    y <- indel.data.drugs[indel.data.drugs$Drug == i & indel.data.drugs$conc == j,]
    
    if (nrow(y)>1) {
    indel.data.drugs$p.value[indel.data.drugs$Drug == i & indel.data.drugs$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data.drugs$statistic[indel.data.drugs$Drug == i & indel.data.drugs$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data.drugs$conf.int1[indel.data.drugs$Drug == i & indel.data.drugs$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data.drugs$conf.int2[indel.data.drugs$Drug == i & indel.data.drugs$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}
}

# Select relevant data
indel.data.drugs <- indel.data.drugs %>% select(Drug, conc, mean, sd, p.value) %>% unique()

# t-test for each drug, treating integrations as replicates
indel.data.drugs.int <- indel.data
indel.data.drugs.int$logratio.drug <- ave(indel.data.drugs.int$logratio.platenorm, 
                                 indel.data.drugs.int$Drug, indel.data$conc,
                                 indel.data.drugs.int$rep, indel.data.drugs.int$barcode,
                                 FUN = function(x) mean(x))
indel.data.drugs.int <- indel.data.drugs.int %>% select(Drug, rep, conc, classifier, logratio.drug) %>%
  unique()
indel.data.drugs.int$mean <- ave(indel.data.drugs.int$logratio.drug, indel.data.drugs.int$Drug, indel.data.drugs.int$conc, FUN = function(x) mean(x))
indel.data.drugs.int$sd <- ave(indel.data.drugs.int$logratio.drug, indel.data.drugs.int$Drug, indel.data.drugs.int$conc, FUN = function(x) sd(x))

for (j in unique(indel.data.drugs.int$conc)) {
for (i in unique(indel.data.drugs.int$Drug)) {
    x <- indel.data.drugs.int[indel.data.drugs.int$Drug == "DMSO" & indel.data.drugs.int$conc == j,]
    y <- indel.data.drugs.int[indel.data.drugs.int$Drug == i & indel.data.drugs.int$conc == j,]
    
    if (nrow(y)>1) {
    indel.data.drugs.int$p.value[indel.data.drugs.int$Drug == i & indel.data.drugs.int$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data.drugs.int$statistic[indel.data.drugs.int$Drug == i & indel.data.drugs.int$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data.drugs.int$conf.int1[indel.data.drugs.int$Drug == i & indel.data.drugs.int$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data.drugs.int$conf.int2[indel.data.drugs.int$Drug == i & indel.data.drugs.int$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}
}

# Adjust p-values for multiple testing and select relevant data
indel.data.drugs.int$p.value.adjust <- p.adjust(indel.data.drugs.int$p.value)
indel.data.drugs.int <- indel.data.drugs.int %>% select(Drug, conc, mean, sd, p.value) %>% unique()



# Run t-test within each well for each barcode
for (i in unique(indel.data$barcode)) {
  
    for (j in unique(indel.data$classifier)) {
    x <- indel.data[indel.data$Drug == "DMSO" & indel.data$barcode == i,]
    y <- indel.data[indel.data$classifier == j & indel.data$barcode == i,]
    
  if (nrow(y)>1) {
    
    indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$p.value
    
    indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$statistic
  
    indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[1]
  
    indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[2]
  }
    else {
      indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$p.value

      indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$statistic

      indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[1]

      indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[2]

      indel.data$conf.int <- abs(indel.data$conf.int2 - indel.data$conf.int1)
    }
    }
}



# Adjust p-values for multiple testing
indel.data$p.value.adjust <- p.adjust(indel.data$p.value)

# Look at specific drugs
indel.data2 <- indel.data
indel.data2$logratio.mean <- ave(indel.data$logratio.platenorm,
                                 indel.data$barcode,
                                 indel.data$Drug,
                                 indel.data$conc,
                                 FUN = function(x) mean(x))
indel.data2$logratio.sd <- ave(indel.data$logratio.platenorm,
                                 indel.data$barcode,
                                 indel.data$Drug,
                                 indel.data$conc,
                                 FUN = function(x) sd(x))
indel.data2 <- indel.data2 %>% select(barcode, Drug, conc, logratio.platenorm, 
                                      p.value.adjust, logratio.mean, logratio.sd) %>% unique()


# Create outlier df based on t-statistic
t.outlier.df <- indel.data[indel.data$p.value <= 0.05,]

# Calculate the mean of the three replicates
indel.data$logratio.mean <- 
  ave(indel.data$logratio.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))

indel.data$efficiency.mean <- 
  ave(indel.data$efficiency.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))
```


\newpage
# Results
## Visualization: checking quality of data
```{r Quality check data, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
## save favorite colors
colors_diverse <- c("#006D77", "#83C5BE", "#EDF6F9", "#FFDDD2", "#E29578")
colors_diverse_2 <- c("#CB997E", "#DDBEA9", "#FFE8D6", "#B7B7A4", "#A5A58D", "#6B705C")
colors_continous <- c("#CAD2C5", "#84A98C", "#52796F", "#354F52", "#2F3E46")
colors_continous_2 <- c("#F8F9FA", "#E9ECEF", "#DEE2E6", "#CED4DA", "#ADB5BD", "#6C757D", "#495057", "#343A40", "#212529")



## Make some density plots to get a feeling for the data
indel.data <- merge(indel.data, integrations)

# Density plot logratio of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = MMEJ_zscore, fill = Target)) + theme_classic() +
  geom_density() + xlab("logratio") + labs(title = "logratio density of the controls")

# Beeswarm plot of MMEJ score of the controls at all IPRs
ggplot(data = indel.data[indel.data$Drug == "DMSO",], 
       aes(y = MMEJ_score, x = integration)) + theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0.5)) + 
  geom_quasirandom(dodge.width = 0.75) +
  geom_boxplot(position = position_dodge(0.75), alpha = 0.7)+ xlab("integration") + 
  labs(title = "MMEJ score of DMSO-treated cells")

# Density plot logratio 
ggplot(data = indel.data, aes(x = MMEJ_zscore, fill = Target)) + 
  geom_density() + xlab("logratio")+ labs(title = "logratio density of all targets") + theme_classic() +
  theme(legend.text=element_text(size=18))

# Integral of logratio density plot per target group
ggplot(data = indel.data, 
       aes(x = MMEJ_zscore)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = Target))+ theme_classic() +
  labs(title = "accumulative logratio of all targets")


# Density plot logratio per target
ggplot(data = indel.data, 
       aes(x = MMEJ_zscore, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ Target, nrow = 4)+ theme_classic() +
  labs(title = "logratio density per target")

# Density plot logratio per integration
ggplot(data = indel.data, 
       aes(x = MMEJ_zscore, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ integration, nrow = 6, scales = "free")+ theme_classic() +
  labs(title = "logratio density per integration")

# Density plot efficiency
ggplot(data = indel.data, aes(x = efficiency, fill = Target)) + geom_density() + theme_classic() +
xlab("efficiency")+ labs(title = "efficiency density")

# Density plot efficiency per target
ggplot(data = indel.data, 
       aes(x = efficiency_zscore, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_grid(rows = vars(Target))+ theme_classic() +
  labs(title = "efficiency density per target group")

# Density plot efficiency per integration
ggplot(data = indel.data, 
       aes(x = efficiency_zscore, fill = Target)) + geom_density()+ theme_classic() +
  xlab("efficiency: normalized over plate") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "efficiency density per integration")

# Integral of density plot
ggplot(data = indel.data, 
       aes(x = efficiency_zscore)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = Target))+ theme_classic() +
  labs(title = "integral of efficiency density")

# Density plot normalized efficiency of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = efficiency_zscore, fill = Target)) + geom_density() + theme_classic() +
  xlab("efficiency: normalized over plate")+ 
  labs(title = "normalized efficiency density of controls")

# Density plots t-distribution, only Mirin & DNA-PKi
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + 
  geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ theme_classic() +
  xlab("t-statistic")+ labs(title = "t-statistic density of controls")

# Density plots t-distribution
ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + 
  geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ theme_classic() +
  xlab("t-statistic")+ labs(title = "t-statistic density")

# Density plot t-statistic + facet_wrap
 ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() + 
   geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + 
   geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ theme_classic() +
   xlab("t-statistic") + facet_wrap(~Target, nrow = 4, scales = "free")+ 
   labs(title = "t-statistic density per target group")

# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group")+ labs(title = "datapoints per target group")

# Relative amount of drugs in outlier df
ggplot(NULL,aes(x = reorder(Target,Target,function(x)-length(x)))) + 
      geom_bar(aes(fill="amount non-outliers"), data = indel.data, alpha = 0.5)+
  geom_bar(aes(fill="amount outlier"), data = t.outlier.df, alpha = 0.5)+theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group") + labs(title = "outlier vs. non-outlier distribution per drug category", fill = "groups")



indel.data2 <- indel.data
indel.data2$zscore_change <- "<0.5"
indel.data2$zscore_change[abs(indel.data2$MMEJ_zscore)>0.5] <- "0.5-1"
indel.data2$zscore_change[abs(indel.data2$MMEJ_zscore)>1] <- ">1"
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))


for (i in unique(indel.data2$Target)) {
p <- ggplot(indel.data2, aes(x = reorder(Target,Target,function(x)-length(x)), 
                   y = length(i)/(length(unique(barcode))*length(unique(rep))), 
                       fill = zscore_change)) + 
      geom_bar(stat="identity") +
    labs(fill = "z-score")+
  scale_fill_manual(values = colors_diverse[seq(2, length(colors_diverse), 2)])+
  coord_flip()+ theme_bw() +
  ylab("Amount of Drugs per Category") + theme(axis.title.y = element_blank())+
  theme(text = element_text(size = 14), axis.text.y = element_text(size = 12))+
  facet_wrap(~conc, nrow=1, ncol=3)
print(p)
}



# Density plot of reads.count using only PAO data -> these are the input reads
all.indel.data <- na.omit(all.indel.data)
ggplot(data = all.indel.data[all.indel.data$Drug == c("PAO","DMSO"),], aes(x = read.count, fill = Drug, group = Drug)) + geom_density() + facet_wrap(~barcode, nrow = 6)+ labs(title = "read count before cutting (PAO) and after cutting (DMSO)") + theme_classic2()


```



\newpage
## Visualization: correlation plots for quality check
```{r correlation plots, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Visualize logratio change and efficiency change in one plot to spot outliers
indel.data$mean.MMEJ_zscore.drug = 
  ave(indel.data$MMEJ_zscore, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$mean.efficiency_zscore.drug = 
  ave(indel.data$efficiency_zscore, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))

indel.data2 <- indel.data %>% 
  select(Drug, conc, mean.MMEJ_zscore.drug, mean.efficiency_zscore.drug) %>%
  filter(Drug != "DNA-PKi")
indel.data2 <- unique(indel.data2)
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))


ggplot(indel.data2, aes(x = mean.MMEJ_zscore.drug, y = mean.efficiency_zscore.drug)) +
  geom_point(color = ifelse(indel.data2$mean.MMEJ_zscore.drug > 2 | 
                                         indel.data2$mean.MMEJ_zscore.drug < -2, "black", "grey"))+
  xlab("MMEJ z-score") + ylab("Efficiency z-score") +
  #gghighlight(abs(mean.MMEJ_zscore.drug) > 5, label_key = Drug) + 
  theme_bw() +
  theme(text = element_text(size = 14)) +
  facet_wrap(~conc, nrow = 1, ncol = 3)


# Correlation plot mean viability vs. mean efficiency
indel.data$mean.viability.drug = 
  ave(indel.data$viability, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$Drug <- as.character(indel.data$Drug)

indel.data2 <- indel.data %>% select(Drug, conc, mean.viability.drug, mean.efficiency_zscore.drug) %>% unique()
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))

ggplot(indel.data2, aes(x = mean.viability.drug, y = mean.efficiency_zscore.drug)) +
  geom_point() +
  xlab("Viability") + ylab("Cutting Efficiency Change") +
  #gghighlight(abs(mean.efficiency_zscore.drug) > 0.1, label_key = Drug) + 
  theme_bw() +
  theme(text = element_text(size = 14)) +
  facet_wrap(~conc, nrow = 1, ncol = 3)


# Correlation plot mean viability vs. mean ratio
indel.data2 <- indel.data %>% select(Drug, conc, mean.MMEJ_zscore.drug, mean.viability.drug) %>% unique()
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))

ggplot(indel.data2 %>%
         filter(Drug != "DNA-PKi"), aes(x = mean.MMEJ_zscore.drug, y = mean.viability.drug)) +
  geom_point() +
  xlab("MMEJ z-score") + ylab("Viability") +
  #gghighlight(abs(mean.MMEJ_zscore.drug) > 1.5, label_key = Drug) + 
  theme_bw() +
  theme(text = element_text(size = 14)) +
  facet_wrap(~conc, nrow = 1, ncol = 3)


ggplot(indel.data2[indel.data2$Drug != "DNA-PKi",], aes(x = mean.MMEJ_zscore.drug, y = mean.viability.drug)) +
  geom_point()+
  xlab("MMEJ z-score") + ylab("Viability")+
  geom_smooth(method = lm, color = "grey") +
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)+
  theme_bw()

indel.data2.low <- indel.data2[indel.data2$conc == "100nm" & 
                                 indel.data2$Drug != "DNA-PKi",]
cor.viability.low <- cor.test(indel.data2.low$mean.MMEJ_zscore.drug, indel.data2.low$mean.viability.drug)

indel.data2.med <- indel.data2[indel.data2$conc == "1um" & 
                                 indel.data2$Drug != "DNA-PKi",]
cor.viability.med <- cor.test(indel.data2.med$mean.MMEJ_zscore.drug, indel.data2.med$mean.viability.drug)

indel.data2.high <- indel.data2[indel.data2$conc == "10um" & 
                                  indel.data2$Drug != "DNA-PKi",]
cor.viability.high <- cor.test(indel.data2.high$mean.MMEJ_zscore.drug, indel.data2.high$mean.viability.drug)

# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
indel.data$mean.ratio.bc <- ave(indel.data$ratio, indel.data$integration, FUN = function(x) mean(x))
ggplot(data = indel.data[indel.data$Target == "Negative Control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.bc))) +
  geom_point() + geom_smooth(method = lm) + theme_classic() +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  scale_x_continuous(breaks=c(2, 4, 6, 8))+ xlab("logratio previous experiments") +
  ylab("logratio this experiment (only DMSO treated data)") + 
  labs(title = "correlation logratio per integration of previous data with these data")

# Correlation plots of the replicates
indel.data.DNAPK <- indel.data[-grep("DNA-PK", indel.data$Drug),]
indel.data.rep1 <- indel.data.DNAPK[grep("rep1", indel.data.DNAPK$condition),]
indel.data.rep1 <- indel.data.rep1 %>% select(barcode, Number, conc, MMEJ_zscore)
indel.data.rep2 <- indel.data.DNAPK[grep("rep2", indel.data.DNAPK$condition),]
indel.data.rep2 <- indel.data.rep2 %>% select(barcode, Number, conc, MMEJ_zscore)
indel.data.rep3 <- indel.data.DNAPK[grep("rep3", indel.data.DNAPK$condition),]
indel.data.rep3 <- indel.data.rep3 %>% select(barcode, Number, conc, MMEJ_zscore)
setnames(indel.data.rep1, old = "MMEJ_zscore", new = "rep1")
setnames(indel.data.rep2, old = "MMEJ_zscore", new = "rep2")
setnames(indel.data.rep3, old = "MMEJ_zscore", new = "rep3")
indel.data.rep <- merge(indel.data.rep1, indel.data.rep2, all = T)
indel.data.rep <- merge(indel.data.rep, indel.data.rep3, all = T)

# Correlation matrix plot
correlation.plot.rep <- indel.data.rep %>% select(rep1, rep2, rep3) %>% na.omit()

n <- sample(1:nrow(indel.data), 5000)
boundaries <- seq(from = 0.7, by = 0.05, length.out = 4)
plt <- ggpairs(correlation.plot.rep,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") +
                   theme_bw()}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") +
                   theme_bw()})) +
  ggtitle("Correlation Between Replicates") +
  theme(text = element_text(size = 20))+
  xlab("Logratio") +
  ylab("Logratio") 
  # theme_bw()

print(plt)

```


\newpage
## Visualizaton: Spotting outliers
```{r visualization spotting outliers, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Spot individual drug outliers per concentration
indel.data2 <- indel.data
indel.data2$MMEJ_zscore <- ave(indel.data2$MMEJ_zscore, indel.data2$conc, indel.data2$Drug, FUN = function(x) mean(x))
indel.data2 <- indel.data2 %>% select(Drug, conc, MMEJ_zscore)
indel.data2 <- indel.data2[!duplicated(indel.data2),]
indel.data2$conc <- factor(indel.data2$conc, levels=c("100nm", "1um", "10um"))

ggplot(indel.data2 %>%
         filter(Drug != "DNA-PKi"), aes(x=conc, y=MMEJ_zscore)) +
  geom_quasirandom() + 
  gghighlight(abs(MMEJ_zscore) > 6, label_key = Drug) + theme_bw()
  
# The same but only the range between 1 & 2
ggplot(indel.data2[abs(indel.data2$MMEJ_zscore) < 2,], aes(x=conc, y=MMEJ_zscore)) +
  geom_quasirandom() + 
  gghighlight(abs(MMEJ_zscore) > 1.7, label_key = Drug) + theme_bw()

# Spot outliers by plotting DMSO versus drugs
indel.data2 <- indel.data
indel.data2$mean.ratio.bc.drug.conc <- ave(indel.data2$efficiency, 
                                           indel.data2$conc, indel.data2$Drug, 
                                           indel.data2$barcode, FUN = function(x) mean(x))
indel.data2 <- indel.data2 %>% select(barcode, Drug, conc, mean.ratio.bc.drug.conc)
indel.data2 <- indel.data2[!duplicated(indel.data2),]
indel.data2.high <- indel.data2[grep("1um", indel.data2$conc),]
indel.data2.high <- indel.data2.high[,-3]

indel.data2.high <- dcast(indel.data2.high, barcode ~ Drug, value.var = "mean.ratio.bc.drug.conc")


gghighlight_point(indel.data2.high, aes(x = DMSO, y = `Vorinostat (SAHA, MK0683)`), `Vorinostat (SAHA, MK0683)` - DMSO > 0.1) +
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0.1, slope = 1, linetype = "dashed") +
  geom_abline(intercept = - 0.1, slope = 1, linetype = "dashed") +
  geom_text(aes(x = 0.4, y = 0.32, label = "-10% efficiency", angle = 35)) +
  geom_text(aes(x = 0.4, y = 0.52, label = "+10% efficiency", angle = 35)) +
  scale_x_continuous(limits = c(0.25, 1)) +
  scale_y_continuous(limits = c(0.25, 1)) +
  labs(title = "Efficiency compared to DMSO for each integration") + theme_bw()

# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = reorder(integration, order), y = logratio.mean, 
                         colour = ifelse(p.value > 0.05,
                                         "non-outlier","outlier")), alpha = 0.5) + theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("integration") + 
  labs(title = "Outlier plot", colour = "Outlier based on p value < 0.05") + 
  scale_color_manual(values=c("#999999", "#E69F00"))



# Boxplot of logratio 
indel.data2 <- indel.data
indel.data2$cluster <- "Active Promoter/Enhancer" 
indel.data2$cluster[indel.data2$order == "3" | 
                      indel.data2$order == "4"] <- "H3K9me2/3 Domain"
indel.data2$cluster[indel.data2$order == "5" | 
                      indel.data2$order == "6" |
                      indel.data2$order == "7" | 
                      indel.data2$order == "8"] <- "Active Gene Body"
indel.data2$cluster[indel.data2$order == "9" | 
                      indel.data2$order == "10" |
                      indel.data2$order == "11" | 
                      indel.data2$order == "12"] <- "LAD"
indel.data2$cluster[indel.data2$order == "13" | 
                      indel.data2$order == "14"] <- "No Chromatin Marks"
indel.data2$cluster[indel.data2$order == "15" | 
                      indel.data2$order == "16" |
                      indel.data2$order == "17" | 
                      indel.data2$order == "18"] <- "H3K27me3 Domain"

ggplot(data = indel.data2[indel.data2$Drug == "DMSO",],
       aes(x = reorder(integration, order), 
                             y = MMEJ_score)) +
  geom_quasirandom() +
  geom_boxplot(alpha = 0.4) +
  ylab("MMEJ score")+
  scale_fill_brewer(palette = "Pastel2")+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+
  theme(axis.title.x = element_blank())

# Are the logratios of the different barcode clusters different?
indel.data2$int <- "1"
indel.data2$int[indel.data2$order >= 9] <- "2"
indel.data2$logratio <- ave(indel.data2$logratio, 
                            indel.data2$integration, 
                            indel.data2$rep, 
                            FUN = function(x) mean(x))
indel.data2 <- indel.data2 %>% select(rep, logratio, int, integration) %>% unique()
indel.data2$mean <- ave(indel.data2$logratio,
                        indel.data2$int, 
                        indel.data2$rep,
                        FUN = function(x) mean(x))
indel.data2$sd <- ave(indel.data2$logratio, 
                      indel.data2$int, 
                      indel.data2$rep,
                      FUN = function(x) sd(x))
indel.data2$p.value <- t.test(indel.data2$mean[indel.data2$int == 1], indel.data2$mean[indel.data2$int == 2])$p.value
indel.data2$mean.bio <- ave(indel.data2$mean,
                        indel.data2$int, 
                        FUN = function(x) mean(x))
indel.data2$sd.bio <- ave(indel.data2$logratio, 
                      indel.data2$int, 
                      FUN = function(x) sd(x))


# Boxplot of efficiencies normalized
ggplot(data = indel.data[indel.data$Drug == "DMSO",]) +
  geom_boxplot(mapping = aes(x = reorder(integration,order), y = efficiency.platenorm)) + theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  labs(title = "Efficiency distribution per integration after normalization") 

# Beeswarm plot of efficiencies
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = reorder(integration,order), y = efficiency.mean, 
                         colour = ifelse(p.value > 0.05,
                                         "non-outlier","outlier"))) + theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("efficiency") + xlab("integration") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on p value < 0.05") + scale_color_manual(values=c("#999999", "#E69F00"))


# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == i | indel.data$Target == "Negative Control", ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = reorder(integration,order), y = MMEJ_zscore, colour = Target), alpha = 0.8, dodge.width = -0.5) + theme_bw() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("integration")+ labs(title= paste("logratio of",i, "compared to DMSO"))
  print(p)
}


# Aurora Kinase only
indel.data.med <- indel.data[indel.data$conc == "1um",]
aurora.dmso <- indel.data.med[indel.data.med$Drug == "DMSO" | indel.data.med$Target == "Aurora Kinase",]
aurora.dmso$Target <- factor(aurora.dmso$Target, levels = c("Negative Control", "Aurora Kinase"))
ggplot(data =  aurora.dmso) +
    geom_quasirandom(aes(x = reorder(integration,order), y = MMEJ_zscore, colour = Target, group = Target), 
                     alpha = 0.8, dodge.width = -0.5, width = 0.1) + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
    ylab("Change log2(+1/-7 ratio)")+
  theme(text = element_text(size = 14))+
  geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.5)+
  theme_classic2()


# Decitabine only
decitabine.dmso <- indel.data[indel.data$Drug == "DMSO" | 
                                indel.data$Drug == "Decitabine",]
decitabine.dmso$Drug <- factor(decitabine.dmso$Drug, levels = c("DMSO", "Decitabine"))
decitabine.dmso$conc <- factor(decitabine.dmso$conc, levels = c("100nm", "1um", "10um"))

ggplot(decitabine.dmso, aes(x = reorder(integration,order), 
                            y = MMEJ_zscore, 
                            colour = Drug, group = Drug,
                            dodge.width = -0.5,
                            width = 0.1)) +
    geom_quasirandom() + 
  scale_colour_brewer(palette = "Set2") +
  coord_flip() +
  theme(axis.title.y = element_blank()) +
  ylab("MMEJ z-score") +
  xlab("") +
  theme(text = element_text(size = 14)) +
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
  theme_bw() + facet_wrap(~conc)

# HDACs (efficiency and logratio)
hdac.dmso <- indel.data[indel.data$Drug == "Vorinostat (SAHA, MK0683)"|
                          indel.data$Drug == "Givinostat (ITF2357)"|
                          indel.data$Drug == "PCI-24781 (Abexinostat)"|
                          indel.data$Drug == "AR-42"|
                          indel.data$Drug == "Scriptaid ",]
hdac.dmso <- hdac.dmso[hdac.dmso$conc == "1um",]

hdac.dmso$MMEJ_zscore <- ave(hdac.dmso$MMEJ_zscore, 
                             hdac.dmso$barcode, hdac.dmso$Drug,
                             FUN = function(x) mean(x))
hdac.dmso$efficiency_zscore <- ave(hdac.dmso$efficiency_zscore, 
                                    hdac.dmso$barcode, hdac.dmso$Drug,
                                    FUN = function(x) mean(x))


hdac.dmso <- hdac.dmso %>% select(Drug, MMEJ_zscore, 
                                  efficiency_zscore, order, 
                                  integration) %>% unique()
hdac.dmso$mean <- ave(hdac.dmso$MMEJ_zscore, hdac.dmso$integration,
                      FUN = function(x) mean(x))
hdac.dmso$mean2 <- ave(hdac.dmso$efficiency_zscore, hdac.dmso$integration,
                      FUN = function(x) mean(x))

ggplot() +
  geom_bar(data = hdac.dmso %>%
             select(mean, integration, order) %>%
             unique(), stat="identity", aes(x =  reorder(integration,order), y = mean, alpha = 0.2)) +
  geom_point(data = hdac.dmso, aes(x = reorder(integration,order), y = MMEJ_zscore, color = Drug)) + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
  ylab("MMEJ z-score")+
  xlab("") +
  theme(text = element_text(size = 14))+
  theme_bw()

ggplot() +
  geom_bar(data = hdac.dmso %>%
             select(mean2, integration, order) %>%
             unique(), stat="identity", aes(x =  reorder(integration,order), y = mean2, alpha = 0.2)) +
  geom_point(data = hdac.dmso, aes(x = reorder(integration,order), y = efficiency_zscore, color = Drug)) + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
  ylab("efficiency z-score")+
  xlab("") +
  theme(text = element_text(size = 14))+
  theme_bw()

# Statistical significance? Is integration 17 different?
anova <- aov(MMEJ_zscore ~ integration, data = hdac.dmso)
summary.aov(anova)
tukey <- TukeyHSD(anova)
```

## Conclusion
The data looks very nice, we can already spot the first outliers. Now we need to generate more sophisticated plots (like heatmaps) and integrate chromatin data to select hits.



## Exporting potential data. 
```{r export}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)

filename <- SetFileName("_t.outlier.df", "mt")
save(t.outlier.df, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

