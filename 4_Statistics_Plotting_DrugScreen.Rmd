---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(Laurae)
library(ggpubr)
```

### Custom functions
Functions used thoughout this script.
```{r}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[3]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

```


## Data import
```{r data import}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/data/files_scripts")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20190501_RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,48,55,56,120:125,128)]
indel.data.all <- RSTP2_2000_indels.df[,c(1:6,48:56,120:125,128)]
integrations <- read.table("barcode_order.txt", header = T)

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
viability <- read.csv2("EpiscreenAllPlates.csv")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```
## Visualize viability data
```{r}
viability.df <- melt(viability)
viability.df$value <- ave(viability.df$value, viability.df$variable, FUN = function(x) x/max(x))


for (i in unique(viability.df$variable)) {
p <- raw_grid(data = viability.df$value[viability.df$variable == i],
       well = viability.df$X[viability.df$variable == i],
       plate_id = viability.df$variable[viability.df$variable == i])
print(p)
}
```



## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
setnames(indel.data, old = "V2", new = "rn")
indel.data <- merge(mean.ratio.data, indel.data, all = T)
all.indel.data <- indel.data


setnames(indel.data, old = ".id", new = "condition")
setnames(indel.data, old = "rn", new = "barcode")

# Remove weird barcode?
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG" &
                           indel.data$barcode != "CTCTTAATCGCTGCC",]


# Also, we want to exclude remaining barcodes with very low reads
indel.data <- indel.data[indel.data$read.count1.7 > 30,]

low.indel.count <- indel.data[indel.data$read.count1.7 < 30,]
low.indel.count <- low.indel.count[low.indel.count$X0 > 100,]
low.indel.count <- low.indel.count[!low.indel.count$Drug %in% "PAO",]

# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]


# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"

## Compute some useful entities for data analysis
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Compute relative viability
indel.data$viability <- ave(indel.data$viability, indel.data$plate.nr, FUN = function(x) x/max(x))

# We want to exclude reads from cells that have reduced viability (set cut-off at 50% reduced viability)
indel.data <- indel.data[indel.data$viability > 0.45,]

# Exclude data completely (remove the remaining datapoint) if 2 out of 3 replicates were already excluded untill now
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$condition)
indel.data$uniqueID <- paste(indel.data$barcode, indel.data$classifier)
# indel.data <- indel.data[indel.data$uniqueID %in% names(which(table(indel.data$uniqueID) > 1)), ]
```

## Plotting indel spectra for certain drugs
```{r plotting indel spectra, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# indel.data.plot <- indel.data.all[indel.data.all$V2 == "GAGCGCGTCACCGGGT" & 
#                                     indel.data.all$Drug == "GSK J4 HCl" | 
#                                     indel.data.all$V2 == "GAGCGCGTCACCGGGT" & 
#                                     indel.data.all$Drug == "DMSO",]
# indel.data.plot.dmso <- indel.data.plot[indel.data.plot$Drug == "DMSO" & indel.data.plot$Number == "B1_013",]
# indel.data.plot.dmso2 <- indel.data.plot[indel.data.plot$Drug == "DMSO" & indel.data.plot$Number == "B1_109" & indel.data.plot$rep == "2" & indel.data.plot$conc == "1um",]
# indel.data.plot.dmso <- rbind(indel.data.plot.dmso, indel.data.plot.dmso2)
# indel.data.plot.gsk <- indel.data.plot[indel.data.plot$Drug == "GSK J4 HCl",]
# indel.data.plot <- rbind(indel.data.plot.dmso, indel.data.plot.gsk)
# indel.data.plot <- indel.data.plot[,c(2,16,18,19)]
# indel.data.plot$ratio <- log2(indel.data.plot$ratio)
# indel.data.plot$Drug <- as.character(indel.data.plot$Drug)
# indel.data.plot$Drug <- as.factor(indel.data.plot$Drug)
# 
# # Difference calculation
# for (i in unique(indel.data.plot$conc)) {
# indel.data.plot$diff[indel.data.plot$conc == i] <- 
#   indel.data.plot$ratio[indel.data.plot$conc == i & indel.data.plot$Drug == "GSK J4 HCl"] - 
#   indel.data.plot$ratio[indel.data.plot$conc == i & indel.data.plot$Drug == "DMSO"]
# }
# 
# indel.data.plot$mean.ratio <- ave(indel.data.plot$ratio, indel.data.plot$Drug, indel.data.plot$conc, FUN = function(x) mean(x))
# indel.data.plot$mean.diff <- ave(indel.data.plot$diff, indel.data.plot$Drug, indel.data.plot$conc, FUN = function(x) mean(x))
# indel.data.plot$SD.ratio <- ave(indel.data.plot$ratio, indel.data.plot$Drug, indel.data.plot$conc, FUN = function(x) sd(x))
# indel.data.plot$SD.diff <- ave(indel.data.plot$diff, indel.data.plot$Drug, indel.data.plot$conc, FUN = function(x) sd(x))
# 
# indel.data.plot$conc <- factor(indel.data.plot$conc, levels=c("100nm", "1um", "10um"))
# 
# # Plotting 
# p <- ggplot(indel.data.plot[indel.data.plot$Drug == "DMSO",]) + 
#   geom_errorbar(aes(x = conc, ymin = mean.ratio-SD.ratio, 
#                     ymax = mean.ratio+SD.ratio), width = 0.2)+
#   geom_point(aes(x=conc, y=ratio, color=rep)) +
#   scale_color_brewer(palette = "Set2")+
#   coord_cartesian(ylim = c(0, 6)) + 
#   theme_classic2()
# 
# p1 <- p  + geom_bar(data = indel.data.plot[indel.data.plot$Drug == "DMSO",],
#                                            stat= "identity", 
#                                            aes(x=conc, y=mean.ratio/3))
# p1
# 
# ggplot(indel.data.plot[indel.data.plot$Drug == "GSK J4 HCl",], aes(x=conc, y=ratio))+
#   geom_bar(indel.data.plot[indel.data.plot$Drug == "GSK J4 HCl",],
#            stat= "identity", aes(x=conc, y=mean.ratio/3)) +
#   geom_errorbar(aes(x = conc, ymin = mean.ratio-SD.ratio, ymax = mean.ratio+SD.ratio), width = 0.2)+
#   geom_point(aes(x=conc, y=ratio, color=rep)) +
#   scale_color_brewer(palette = "Set2")+
#   coord_cartesian(ylim = c(0, 6)) + 
#   theme_classic2()
# 
# ggplot(indel.data.plot[indel.data.plot$Drug == "GSK J4 HCl",], aes(x=conc, y=diff))+
#   geom_bar(indel.data.plot[indel.data.plot$Drug == "GSK J4 HCl",],
#            stat= "identity", aes(x=conc, y=mean.diff/3)) +
#   geom_errorbar(aes(x = conc, ymin = mean.diff-SD.diff, ymax = mean.diff+SD.diff), width = 0.2)+
#   geom_point(aes(x=conc, y=diff, color=rep)) +
#   scale_color_brewer(palette = "Set2")+
#   coord_cartesian(ylim = c(0, 4)) + 
#   theme_classic2()
```





# Analysis

## Compute relative barcode counts
```{r}
# Plate normalization: substract dmso bc counts from each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- 
    mean(indel.data$read.count[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$rel.counts[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$read.count[indel.data$plate.nr == i & indel.data$barcode == j] /
    dmso.mean
  }
}


# Check which drugs alter barcode count
indel.data$mean.count <- ave(indel.data$rel.counts, indel.data$Drug, indel.data$barcode, FUN = function(x) mean(x))
indel.data.bc.count <- indel.data[indel.data$mean.count >  1.5 | indel.data$mean.count < 0.666,]

ggplot(indel.data.bc.count, aes(colour = barcode, y = mean.count, x = reorder(Drug, Drug, function(x) -length(x)))) + 
    geom_point() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12)) + 
    ylab("datapoints") + xlab("target group") + labs(title = "datapoints drugs with altered bc counts")

```



## Data analysis
```{r data analysis}
## Normalize the data
# Plate normalization: substract log(DMSO.mean) for each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- mean(indel.data$logratio[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$logratio.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$logratio[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.mean
  }
}

# Plate normalization for efficiency
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.eff.mean <- mean(indel.data$efficiency[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$efficiency.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <-
    indel.data$efficiency[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.eff.mean
  }
}

## Perform t-tests

# t-test for target groups
indel.data2 <- indel.data[indel.data$Target == "Aurora Kinase" |
                            indel.data$Drug == "DMSO" &
                            indel.data$conc == "1um",]
indel.data2$logratio.drug <- ave(indel.data2$logratio.platenorm, 
                                 indel.data2$Target,
                                 indel.data2$rep,
                                 FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(7,12,27)]
indel.data2 <- unique(indel.data2)
indel.data2$mean <- ave(indel.data2$logratio.drug, indel.data2$Target, FUN = function(x) mean(x))
indel.data2$sd <- ave(indel.data2$logratio.drug, indel.data2$Target, FUN = function(x) sd(x))

for (i in unique(indel.data2$Target)) {
    x <- indel.data2[indel.data2$Target == "Negative Control",]
    y <- indel.data2[indel.data2$Target == "Aurora Kinase",]
    
    if (nrow(y)>1) {
    indel.data2$p.value[indel.data2$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data2$statistic[indel.data2$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data2$conf.int1[indel.data2$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data2$conf.int2[indel.data2$Target == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}


# Adjust p-values for multiple testing
indel.data2 <- indel.data2[,c(1,4,5,6)]
indel.data2 <- unique(indel.data2)


# t-test for controls
indel.data2 <- indel.data[indel.data$Drug == "DNA-PKi" |
                            indel.data$Drug == "DMSO" |
                            indel.data$Drug == "Mirin",]
indel.data2$logratio.drug <- ave(indel.data2$logratio.platenorm, 
                                 indel.data2$Drug,
                                 indel.data2$rep, FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(6,12,27)]
indel.data2 <- unique(indel.data2)
indel.data2$mean <- ave(indel.data2$logratio.drug, indel.data2$Drug,  FUN = function(x) mean(x))
indel.data2$sd <- ave(indel.data2$logratio.drug, indel.data2$Drug,  FUN = function(x) sd(x))

for (i in unique(indel.data2$Drug)) {
    x <- indel.data2[indel.data2$Drug == "DMSO",]
    y <- indel.data2[indel.data2$Drug == i,]
    
    if (nrow(y)>1) {
    indel.data2$p.value[indel.data2$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data2$statistic[indel.data2$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data2$conf.int1[indel.data2$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data2$conf.int2[indel.data2$Drug == i] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}


# Select relevant data
indel.data2 <- indel.data2[,c(1,4,5,6)]
indel.data2 <- unique(indel.data2)


# t-test for individual drugs
indel.data2 <- indel.data
indel.data2$logratio.drug <- ave(indel.data2$logratio.platenorm, 
                                 indel.data2$Drug, indel.data$conc,
                                 indel.data2$rep, FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(6,12,14,27)]
indel.data2 <- unique(indel.data2)
indel.data2$mean <- ave(indel.data2$logratio.drug, indel.data2$Drug, indel.data2$conc, FUN = function(x) mean(x))
indel.data2$sd <- ave(indel.data2$logratio.drug, indel.data2$Drug, indel.data2$conc, FUN = function(x) sd(x))

for (j in unique(indel.data2$conc)) {
for (i in unique(indel.data2$Drug)) {
    x <- indel.data2[indel.data2$Drug == "DMSO" & indel.data2$conc == j,]
    y <- indel.data2[indel.data2$Drug == i & indel.data2$conc == j,]
    
    if (nrow(y)>1) {
    indel.data2$p.value[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data2$statistic[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data2$conf.int1[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data2$conf.int2[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}
}

# Select relevant data
indel.data2 <- indel.data2[,c(1,3,5,6,7)]
indel.data2 <- unique(indel.data2)


# t-test for each drug, treating integrations as replicates
indel.data2 <- indel.data
indel.data2$logratio.drug <- ave(indel.data2$logratio.platenorm, 
                                 indel.data2$Drug, indel.data$conc,
                                 indel.data2$rep, indel.data2$barcode,
                                 FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(6,12,14,21,27)]
indel.data2 <- unique(indel.data2)
indel.data2$mean <- ave(indel.data2$logratio.drug, indel.data2$Drug, indel.data2$conc, FUN = function(x) mean(x))
indel.data2$sd <- ave(indel.data2$logratio.drug, indel.data2$Drug, indel.data2$conc, FUN = function(x) sd(x))

for (j in unique(indel.data2$conc)) {
for (i in unique(indel.data2$Drug)) {
    x <- indel.data2[indel.data2$Drug == "DMSO" & indel.data2$conc == j,]
    y <- indel.data2[indel.data2$Drug == i & indel.data2$conc == j,]
    
    if (nrow(y)>1) {
    indel.data2$p.value[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$p.value
    
    indel.data2$statistic[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$statistic
  
    indel.data2$conf.int1[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[1]
  
    indel.data2$conf.int2[indel.data2$Drug == i & indel.data2$conc == j] <- 
      t.test(x$logratio.drug, y$logratio.drug)$conf.int[2]
    }
}
}

# Adjust p-values for multiple testing
indel.data2$p.value.adjust <- p.adjust(indel.data2$p.value)
indel.data2 <- indel.data2[,c(1,3,6,7,12)]
indel.data2 <- unique(indel.data2)





# Run t-test within each well for each barcode
for (i in unique(indel.data$barcode)) {
  
    for (j in unique(indel.data$classifier)) {
    x <- indel.data[indel.data$Drug == "DMSO" & indel.data$barcode == i,]
    y <- indel.data[indel.data$classifier == j & indel.data$barcode == i,]
    
  if (nrow(y)>1) {
    
    indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$p.value
    
    indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$statistic
  
    indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[1]
  
    indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[2]
  }
    else {
      indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$p.value

      indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$statistic

      indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[1]

      indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <-
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[2]

      indel.data$conf.int <- abs(indel.data$conf.int2 - indel.data$conf.int1)
    }
    }
}



# Adjust p-values for multiple testing
indel.data$p.value.adjust <- p.adjust(indel.data$p.value)

# Look at specific drugs
indel.data2 <- indel.data
indel.data2$logratio.mean <- ave(indel.data$logratio.platenorm,
                                 indel.data$barcode,
                                 indel.data$Drug,
                                 indel.data$conc,
                                 FUN = function(x) mean(x))
indel.data2$logratio.sd <- ave(indel.data$logratio.platenorm,
                                 indel.data$barcode,
                                 indel.data$Drug,
                                 indel.data$conc,
                                 FUN = function(x) sd(x))
indel.data2 <- indel.data2[,c(1,6,14,27,32,33,34)]
indel.data2 <- unique(indel.data2)


# Create outlier df based on t-statistic
t.outlier.df <- indel.data[indel.data$p.value <= 0.05,]

# Calculate the mean of the three replicates
indel.data$logratio.mean <- 
  ave(indel.data$logratio.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))

indel.data$efficiency.mean <- 
  ave(indel.data$efficiency.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))


```


\newpage
# Results
## Visualization: checking quality of data
```{r Quality check data, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
## Make some density plots to get a feeling for the data
indel.data <- merge(indel.data, integrations)

# Density plot logratio of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = logratio.platenorm, fill = Target)) + 
  geom_density() + xlab("logratio") + labs(title = "logratio density of the controls")

# Density plot logratio 
ggplot(data = indel.data, aes(x = logratio.platenorm, fill = Target)) + 
  geom_density() + xlab("logratio")+ labs(title = "logratio density of all targets") +
  theme(legend.text=element_text(size=18))

# Integral of logratio density plot per target group
ggplot(data = indel.data, 
       aes(x = logratio.platenorm)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = Target))+ 
  labs(title = "accumulative logratio of all targets")


# Density plot logratio per target
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "logratio density per target")

# Density plot logratio per integration
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ integration, nrow = 6, scales = "free")+ 
  labs(title = "logratio density per integration")

# Density plot efficiency
ggplot(data = indel.data, aes(x = efficiency, fill = Target)) + geom_density() +
xlab("efficiency")+ labs(title = "efficiency density")

# Density plot efficiency per target
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_grid(rows = vars(Target))+ 
  labs(title = "efficiency density per target group")

# Density plot efficiency per integration
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "efficiency density per integration")

# Integral of density plot
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = Target))+ 
  labs(title = "integral of efficiency density")

# Density plot normalized efficiency of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density() +
  xlab("efficiency: normalized over plate")+ 
  labs(title = "normalized efficiency density of controls")

# Density plots t-distribution, only Mirin & DNA-PKi
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + 
  geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ 
  xlab("t-statistic")+ labs(title = "t-statistic density of controls")

# Density plots t-distribution
ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + 
  geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ 
  xlab("t-statistic")+ labs(title = "t-statistic density")

# Density plot t-statistic + facet_wrap
 ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() + 
   geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + 
   geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ 
   xlab("t-statistic") + facet_wrap(~Target, nrow = 4, scales = "free")+ 
   labs(title = "t-statistic density per target group")

# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group")+ labs(title = "datapoints per target group")

# Relative amount of drugs in outlier df
ggplot(NULL,aes(x = reorder(Target,Target,function(x)-length(x)))) + 
      geom_bar(aes(fill="amount non-outliers"), data = indel.data, alpha = 0.5)+
  geom_bar(aes(fill="amount outlier"), data = t.outlier.df, alpha = 0.5)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group") + labs(title = "outlier vs. non-outlier distribution per drug category", fill = "groups")



indel.data2 <- indel.data
indel.data2$`Logratio Change` <- "<0.5"
indel.data2$`Logratio Change`[abs(indel.data2$logratio.platenorm)>0.5] <- "0.5-1"
indel.data2$`Logratio Change`[abs(indel.data2$logratio.platenorm)>1] <- ">1"
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))


for (i in unique(indel.data2$Target)) {
p <- ggplot(indel.data2, aes(x = reorder(Target,Target,function(x)-length(x)), 
                   y = length(i)/(length(unique(barcode))*length(unique(rep))), 
                       fill = `Logratio Change`)) + 
      geom_bar(stat="identity") +
    labs(fill = "Log2(+1/-7)ratio Change")+
  scale_fill_brewer(palette = "Set2")+
  coord_flip()+
  ylab("Amount of Drugs per Category") + theme(axis.title.y = element_blank())+
  theme(text = element_text(size = 14), axis.text.y = element_text(size = 12))+
  facet_wrap(~conc, nrow=1, ncol=3)
print(p)
}



# Density plot of reads.count using only PAO data -> these are the input reads
all.indel.data <- na.omit(all.indel.data)
ggplot(data = all.indel.data[all.indel.data$Drug == c("PAO","DMSO"),], aes(x = read.count, fill = Drug, group = Drug)) + geom_density() + facet_wrap(~barcode, nrow = 6)+ labs(title = "read count before cutting (PAO) and after cutting (DMSO)") + theme_classic2()


```



\newpage
## Visualization: correlation plots for quality check
```{r correlation plots, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Visualize logratio change and efficiency change in one plot to spot outliers
indel.data$mean.logratio.drug = 
  ave(indel.data$logratio.platenorm, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$mean.efficiency.drug = 
  ave(indel.data$efficiency.platenorm, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))

indel.data2 <- indel.data[,c(6,14,37,38)]
indel.data2 <- unique(indel.data2)
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))


ggplot(indel.data2, aes(x = mean.logratio.drug, y = mean.efficiency.drug)) +
  geom_point()+
  xlab("Log2(+1/-7 ratio) Change") + ylab("Cutting Efficiency Change")+
  gghighlight(abs(mean.logratio.drug) > 2, label_key = Drug)+
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)


ggplot(indel.data2, aes(x = mean.logratio.drug, y = mean.efficiency.drug)) +
  geom_point()+
  xlab("Log2(+1/-7 ratio) Change") + ylab("Cutting Efficiency Change")+
  gghighlight(abs(mean.efficiency.drug) > 0.05, label_key = Drug)+
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)


# Correlation plot mean viability vs. mean efficiency
indel.data$mean.viability.drug = 
  ave(indel.data$viability, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$Drug <- as.character(indel.data$Drug)

indel.data2 <- indel.data[,c(6,14,38,39)]
indel.data2 <- unique(indel.data2)
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))

ggplot(indel.data2, aes(x = mean.viability.drug, y = mean.efficiency.drug)) +
  geom_point()+
  xlab("Viability") + ylab("Cutting Efficiency Change")+
  gghighlight(abs(mean.efficiency.drug) > 0.1, label_key = Drug)+
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)


# Correlation plot mean viability vs. mean ratio
indel.data2 <- indel.data[,c(6,14,39,37)]
indel.data2 <- unique(indel.data2)
indel.data2$conc <- factor(indel.data2$conc, levels = c("100nm", "1um", "10um"))

ggplot(indel.data2, aes(x = mean.logratio.drug, y = mean.viability.drug)) +
  geom_point()+
  xlab("Log2(+1/-7 ratio) Change") + ylab("Viability")+
  gghighlight(abs(mean.logratio.drug) > 1.5, label_key = Drug)+
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)


ggplot(indel.data2[indel.data2$Drug != "DNA-PKi",], aes(x = mean.logratio.drug, y = mean.viability.drug)) +
  geom_point()+
  xlab("Log2(+1/-7 ratio) Change") + ylab("Viability")+
  geom_smooth(method = lm) +
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)+
  theme_bw()

indel.data2.low <- indel.data2[indel.data2$conc == "100nm" & 
                                 indel.data2$Drug != "DNA-PKi",]
cor.viability.low <- cor.test(indel.data2.low$mean.logratio.drug, indel.data2.low$mean.viability.drug)

indel.data2.med <- indel.data2[indel.data2$conc == "1um" & 
                                 indel.data2$Drug != "DNA-PKi",]
cor.viability.med <- cor.test(indel.data2.med$mean.logratio.drug, indel.data2.med$mean.viability.drug)

indel.data2.high <- indel.data2[indel.data2$conc == "10um" & 
                                  indel.data2$Drug != "DNA-PKi",]
cor.viability.high <- cor.test(indel.data2.high$mean.logratio.drug, indel.data2.high$mean.viability.drug)

# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
indel.data$mean.ratio.bc <- ave(indel.data$ratio, indel.data$integration, FUN = function(x) mean(x))
ggplot(data = indel.data[indel.data$Target == "Negative Control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.bc))) +
  geom_point() + geom_smooth(method = lm) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  scale_x_continuous(breaks=c(2, 4, 6, 8))+ xlab("logratio previous experiments") +
  ylab("logratio this experiment (only DMSO treated data)") + 
  labs(title = "correlation logratio per integration of previous data with these data")

# Correlation plots of the replicates
indel.data.DNAPK <- indel.data[-grep("DNA-PK", indel.data$Drug),]
indel.data.rep1 <- indel.data.DNAPK[grep("rep1", indel.data.DNAPK$condition),]
indel.data.rep1 <- indel.data.rep1[,c(1,5,14,20)]
indel.data.rep2 <- indel.data.DNAPK[grep("rep2", indel.data.DNAPK$condition),]
indel.data.rep2 <- indel.data.rep2[,c(1,5,14,20)]
indel.data.rep3 <- indel.data.DNAPK[grep("rep3", indel.data.DNAPK$condition),]
indel.data.rep3 <- indel.data.rep3[,c(1,5,14,20)]
setnames(indel.data.rep1, old = "logratio", new = "rep1")
setnames(indel.data.rep2, old = "logratio", new = "rep2")
setnames(indel.data.rep3, old = "logratio", new = "rep3")
indel.data.rep <- merge(indel.data.rep1, indel.data.rep2, all = T)
indel.data.rep <- merge(indel.data.rep, indel.data.rep3, all = T)

# Correlation matrix plot
correlation.plot.rep <- indel.data.rep[,c(4,5,6)]
correlation.plot.rep <- na.omit(correlation.plot.rep)

n <- sample(1:nrow(indel.data), 5000)
boundaries <- seq(from = 0.7, by = 0.05, length.out = 4)
plt <- ggpairs(correlation.plot.rep,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") +
                   theme_bw()}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") +
                   theme_bw()})) +
  ggtitle("Correlation Between Replicates") +
  theme(text = element_text(size = 20))+
  xlab("Logratio") +
  ylab("Logratio") 
  # theme_bw()

print(plt)

```

### Conclusion correlation plots
We can see that there is a very high correlation between all 3 replicates, meaning that we can use the data of all 3 replicates.


\newpage
## Visualizaton: Spotting outliers
```{r visualization spotting outliers, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Spot individual drug outliers per concentration
indel.data2 <- indel.data
indel.data2$logratio.platenorm <- ave(indel.data2$logratio.platenorm, indel.data2$conc, indel.data2$Drug, FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(6,14,25)]
indel.data2 <- indel.data2[!duplicated(indel.data2),]
indel.data2$conc <- factor(indel.data2$conc, levels=c("100nm", "1um", "10um"))

ggplot(indel.data2, aes(x=conc, y=logratio.platenorm))+
  geom_quasirandom() + 
  coord_cartesian(ylim = c(-4, 4))+  
  gghighlight(abs(logratio.platenorm) > 2, label_key = Drug)
  
# The same but only the range between 1 & 2
ggplot(indel.data2[abs(indel.data2$logratio.platenorm) < 2,], aes(x=conc, y=logratio.platenorm))+
  geom_quasirandom() + 
  coord_cartesian(ylim = c(-4, 4))+  
  gghighlight(abs(logratio.platenorm) > 1, label_key = Drug)

# Spot outliers by plotting DMSO versus drugs
indel.data2 <- indel.data
indel.data2$mean.ratio.bc.drug.conc <- ave(indel.data2$efficiency, 
                                           indel.data2$conc, indel.data2$Drug, 
                                           indel.data2$barcode, FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(1,6,14,41)]
indel.data2 <- indel.data2[!duplicated(indel.data2),]
indel.data2.high <- indel.data2[grep("1um", indel.data2$conc),]
indel.data2.high <- indel.data2.high[,-3]

indel.data2.high <- dcast(indel.data2.high, barcode ~ Drug, value.var = "mean.ratio.bc.drug.conc")


gghighlight_point(indel.data2.high, aes(x = DMSO, y = `Vorinostat (SAHA, MK0683)`), `Vorinostat (SAHA, MK0683)` - DMSO > 0.1) +
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0.1, slope = 1, linetype = "dashed") +
  geom_abline(intercept = - 0.1, slope = 1, linetype = "dashed") +
  geom_text(aes(x = 0.4, y = 0.32, label = "-10% efficiency", angle = 35)) +
  geom_text(aes(x = 0.4, y = 0.52, label = "+10% efficiency", angle = 35)) +
  scale_x_continuous(limits = c(0.25, 1)) +
  scale_y_continuous(limits = c(0.25, 1)) +
  labs(title = "Efficiency compared to DMSO for each integration")

# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = reorder(integration, order), y = logratio.mean, 
                         colour = ifelse(p.value > 0.05,
                                         "non-outlier","outlier")), alpha = 0.5) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("integration") + 
  labs(title = "Outlier plot", colour = "Outlier based on p value < 0.05") + 
  scale_color_manual(values=c("#999999", "#E69F00"))

# Boxplot of efficiencies 
ggplot(data = indel.data[indel.data$Drug == "DMSO",]) +
  geom_boxplot(mapping = aes(x = reorder(integration, order), y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+
  ylab("Cutting Efficiency")+
  theme(axis.title.x = element_blank())

# Boxplot of logratio 
indel.data2 <- indel.data
indel.data2$cluster <- "Active Promoter/Enhancer" 
indel.data2$cluster[indel.data2$order == "3" | 
                      indel.data2$order == "4"] <- "H3K9me2/3 Domain"
indel.data2$cluster[indel.data2$order == "5" | 
                      indel.data2$order == "6" |
                      indel.data2$order == "7" | 
                      indel.data2$order == "8"] <- "Active Gene Body"
indel.data2$cluster[indel.data2$order == "9" | 
                      indel.data2$order == "10" |
                      indel.data2$order == "11" | 
                      indel.data2$order == "12"] <- "LAD"
indel.data2$cluster[indel.data2$order == "13" | 
                      indel.data2$order == "14"] <- "No Chromatin Marks"
indel.data2$cluster[indel.data2$order == "15" | 
                      indel.data2$order == "16" |
                      indel.data2$order == "17" | 
                      indel.data2$order == "18"] <- "H3K27me3 Domain"

ggplot(data = indel.data2[indel.data2$Drug == "DMSO",]) +
  geom_boxplot(mapping = aes(x = reorder(integration, order), 
                             y = logratio, fill = cluster)) +
  ylab("Logratio")+
  scale_fill_brewer(palette = "Pastel2")+
  theme_classic2()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+
  theme(axis.title.x = element_blank())

# Are the logratios of the different barcode clusters different?
indel.data2$int <- "1"
indel.data2$int[indel.data2$order >= 9] <- "2"
indel.data2$logratio <- ave(indel.data2$logratio, 
                            indel.data2$integration, 
                            indel.data2$rep, 
                            FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(12,20,36,42)]
indel.data2 <- unique(indel.data2)
indel.data2$mean <- ave(indel.data2$logratio,
                        indel.data2$int, 
                        indel.data2$rep,
                        FUN = function(x) mean(x))
indel.data2$sd <- ave(indel.data2$logratio, 
                      indel.data2$int, 
                      indel.data2$rep,
                      FUN = function(x) sd(x))
indel.data2$p.value <- t.test(indel.data2$mean[indel.data2$int == 1], indel.data2$mean[indel.data2$int == 2])$p.value
indel.data2$mean.bio <- ave(indel.data2$mean,
                        indel.data2$int, 
                        FUN = function(x) mean(x))
indel.data2$sd.bio <- ave(indel.data2$logratio, 
                      indel.data2$int, 
                      FUN = function(x) sd(x))


# Boxplot of efficiencies normalized
ggplot(data = indel.data[indel.data$Drug == "DMSO",]) +
  geom_boxplot(mapping = aes(x = reorder(integration,order), y = efficiency.platenorm)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  labs(title = "Efficiency distribution per integration after normalization") 

# Beeswarm plot of efficiencies
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = reorder(integration,order), y = efficiency.mean, 
                         colour = ifelse(p.value > 0.05,
                                         "non-outlier","outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("efficiency") + xlab("integration") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on p value < 0.05") + scale_color_manual(values=c("#999999", "#E69F00"))


# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == i | indel.data$Target == "Negative Control", ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = reorder(integration,order), y = logratio.platenorm, colour = Target), alpha = 0.8, dodge.width = -0.5) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("integration")+ labs(title= paste("logratio of",i, "compared to DMSO"))
  print(p)
}


# Aurora Kinase only
indel.data.med <- indel.data[indel.data$conc == "1um",]
aurora.dmso <- indel.data.med[indel.data.med$Drug == "DMSO" | indel.data.med$Target == "Aurora Kinase",]
aurora.dmso$Target <- factor(aurora.dmso$Target, levels = c("Negative Control", "Aurora Kinase"))
ggplot(data =  aurora.dmso) +
    geom_quasirandom(aes(x = reorder(integration,order), y = logratio.platenorm, colour = Target, group = Target), 
                     alpha = 0.8, dodge.width = -0.5, width = 0.1) + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
    ylab("Change log2(+1/-7 ratio)")+
  theme(text = element_text(size = 14))+
  geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.5)+
  theme_classic2()


# Decitabine only
decitabine.dmso <- indel.data[indel.data$Drug == "DMSO" | 
                                indel.data$Drug == "Decitabine",]
decitabine.dmso$Drug <- factor(decitabine.dmso$Drug, levels = c("DMSO", "Decitabine"))
decitabine.dmso$conc <- factor(decitabine.dmso$conc, levels = c("100nm", "1um", "10um"))

ggplot(decitabine.dmso, aes(x = reorder(integration,order), 
                            y = logratio.platenorm, 
                            colour = Drug, group = Drug,
                            dodge.width = -0.5, alpha = conc,
                            width = 0.1)) +
    geom_quasirandom() + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
    ylab("Change log2(+1/-7 ratio)")+
  theme(text = element_text(size = 14))+
  geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.5)+
  theme_classic2()

# HDACs (efficiency and logratio)
hdac.dmso <- indel.data[indel.data$Drug == "Vorinostat (SAHA, MK0683)"|
                          indel.data$Drug == "Givinostat (ITF2357)"|
                          indel.data$Drug == "PCI-24781 (Abexinostat)"|
                          indel.data$Drug == "AR-42"|
                          indel.data$Drug == "Scriptaid ",]
hdac.dmso <- hdac.dmso[hdac.dmso$conc == "1um",]

hdac.dmso$logratio.platenorm <- ave(hdac.dmso$logratio.platenorm, 
                                    hdac.dmso$barcode, hdac.dmso$Drug,
                                    FUN = function(x) mean(x))
hdac.dmso$efficiency.platenorm <- ave(hdac.dmso$efficiency.platenorm, 
                                    hdac.dmso$barcode, hdac.dmso$Drug,
                                    FUN = function(x) mean(x))


hdac.dmso <- hdac.dmso[,c(6,25,26,35,36)]
hdac.dmso <- unique(hdac.dmso)
hdac.dmso$mean <- ave(hdac.dmso$logratio.platenorm, hdac.dmso$integration,
                      FUN = function(x) mean(x))
hdac.dmso$mean2 <- ave(hdac.dmso$efficiency.platenorm, hdac.dmso$integration,
                      FUN = function(x) mean(x))

ggplot(hdac.dmso, aes(colour = Drug, group = Drug, fill = Drug)) +
  geom_bar(data = hdac.dmso,
           stat="identity", aes(x =  reorder(integration,order),
                                y = mean)) +
    geom_quasirandom(aes(x = reorder(integration,order), 
                            y = logratio.platenorm)) + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
    ylab("Change log2(+1/-7 ratio)")+
  theme(text = element_text(size = 14))+
  geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.5)+
  scale_y_continuous(limits = c(-0.5,2))+
  theme_classic2()

ggplot(hdac.dmso, aes(colour = Drug, group = Drug, fill = Drug)) +
  geom_bar(data = hdac.dmso,
           stat="identity", aes(x =  reorder(integration,order),
                                y = mean2)) +
    geom_quasirandom(aes(x = reorder(integration,order), 
                            y = efficiency.platenorm)) + 
  scale_colour_brewer(palette = "Set2")+
  coord_flip()+
  theme(axis.title.y = element_blank())+
    ylab("Change log2(+1/-7 ratio)")+
  theme(text = element_text(size = 14))+
  scale_y_continuous(limits = c(-0.1,0.3))+
  theme_classic2()

# Statistical significance? Is integration 17 different?
anova <- aov(logratio.platenorm ~ integration, data = hdac.dmso)
summary.aov(anova)
tukey <- TukeyHSD(anova)
```

## Conclusion
The data looks very nice, we can already spot the first outliers. Now we need to generate more sophisticated plots (like heatmaps) and integrate chromatin data to select hits.



## Exporting potential data. 
```{r export}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/data/files_scripts/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)

filename <- SetFileName("_t.outlier.df", "mt")
save(t.outlier.df, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

