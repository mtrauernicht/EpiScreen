---
title: "DSB Episcreen data analysis & plotting"
author: 
  - name: "Max Trauernicht"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site IPRs was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(ggpubr)
library(tidyr)
library(Laurae)
library(tibble)
library(pheatmap)
library(RColorBrewer)
library(ggrastr)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

theme_classic_lines <- function() {
  theme_pubr(border = F, legend = "top") +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}
theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 90) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#9AC1AE", "#5D987B", "#f2cc8f", "#e76f51")
colors_drugs <- c("#FA8D62", "#65BFA4", "#8CA0C4", "#808184", "#F6D289", "#E5E5E5", "#ACACAC", "#737373")
#colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
# Import data from preprocessing script
indel.data <- readRDS("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/mt20220120_episcreen.RDS")
```




## A: MMEJ-z-score per drug
Are the compounds (per concentration) that significantly alter the MMEJ score?
```{r warning = FALSE}
# A: MMEJ-z-score per drug
ggplot_custom(indel.data %>%
                filter(sample == "drug") %>%
                distinct(MMEJ_zscore_global_comb, drug, conc_char),
              aes(x = conc_char, y = MMEJ_zscore_global_comb, color = ifelse(Mod(MMEJ_zscore_global_comb) > 1.96, "red", "black"))) +
  geom_quasirandom() +
  geom_hline(linetype = "dashed", yintercept = 1.96) +
  geom_hline(linetype = "dashed", yintercept = -1.96)
```

*Figure 3A: Compound-induced change in MMEJ ratio of all tested compounds. Mean MMEJ z-score per drug & concentration.* 

**Conclusion: Yes, there are a lot of interesting hits at all tested concentrations.**

---

## B: MMEJ ratio change per target group
Are there any target groups that are prone to changes in MMEJ ratio?
```{r warning = FALSE}
# C: Bar plot
eff.data <- indel.data %>%
  filter(sample == "drug") %>%
  distinct(MMEJ_zscore_global_comb, drug, target, conc_char)

eff.data$sign <- "Yes"
eff.data$sign[Mod(eff.data$MMEJ_zscore_global_comb) < 1.96] <- "No"

eff.data <- eff.data %>%
  mutate(number = ave(target, target, sign, conc_char, FUN = length)) %>%
  mutate(number = as.numeric(number)) %>%
  distinct(conc_char, target, sign, number) %>%
  spread(sign, number, fill = 0) %>%
  mutate(fraction = Yes / (No + Yes)) %>%
  pivot_longer(Yes:No, names_to = "sign", values_to = "number")

ggplot_custom(eff.data ,
              aes(y = reorder(target, -number), x = number, fill = sign)) +
  geom_bar(stat = "identity") +
  facet_wrap(~conc_char)
```

*Figure 2B: Number of compounds with significant changes in MMEJ ratio per target group.*

**Conclusion: Some target groups have more changes. But there are no groups significantly sticking out.**

---

## C: MMEJ z-score heatmap: drug vs genomic location
Which drugs are changing MMEJ score? Do they act globally or locally? 
```{r warning = FALSE}
# Set annotation for heatmap
# Row annotation: annotate drugs with the target group
target <- indel.data %>% 
  filter(!target %in% c("Negative Control", "MRN", "DNA-PK")) %>% 
  distinct(drug, target) %>% 
  column_to_rownames(var="drug")

file_list = list.files("/DATA/projects/DSBrepair/data/R/rs20210813_episcreen_2", full.names = TRUE)
file_list
episcreen_ratios = readRDS(file_list[[3]])

chromatin <- readRDS(
  "/DATA/usr/x.vergara/XV_ChIPIndels/XV20200902_DDR_RS_revision/XV20200902_DDR_RS_revision/data/xv20200915_DDR_data_CHIP.rds") %>% 
  distinct(barcode, chromatin) %>%
  left_join(distinct(episcreen_ratios, barcode, IPR)) %>%
  filter(IPR != "<NA>") %>% 
  select(-barcode) %>%
  column_to_rownames(var="IPR")

# Change colors of annotations
chrom_colors = c("Euchromatin" = "#264653",
                  "other-heterochromatin" = "#e9c46a",  
                     "H3K27me3" = "#e76f51", 
                  "Triple Heterochromatin" = "#f4a261")

# colors <- brewer.pal(length(unique(barcode.annotation$cluster)), "Pastel2")
# names(colors) <- unique(barcode.annotation$cluster)

annotation_colors_scr = list(
  chromatin = chrom_colors,
  type = c(Active="#669966", Repressive="grey90"),
  target = c(HDAC="#60988D", HAT="#C6D0A8", Sirtuin="#8FCAAC",
             HMT="#FDCDAC", DNMT="#D69C81", `Histone Demethylase`="#FFF2AE",
             HIF="#E3DCD5", JAK="#C8D7E2", PIM="#9AB8C4", `Aurora Kinase`="#F4CAE4",
             PARP="#CB546F", `Epigenetic Reader Domain`= "#476D61", `DNA-PK`="#E07A43"
             ))



# Order the annotation legend
ordered_marks <- c("Euchromatin", 
                     "other-heterochromatin",  
                     "H3K27me3", 
                     "Triple Heterochromatin")

annotation_colors_scr$chromatin <- annotation_colors_scr$chromatin[ordered_marks]

ordered_marks2 <- c("DNA-PK","Epigenetic Reader Domain", "HDAC",  "Sirtuin", "HAT", 
                    "Histone Demethylase", "HMT", "DNMT", 
                    "HIF", "JAK", "PIM",
                    "Aurora Kinase", "PARP")
annotation_colors_scr$target <- annotation_colors_scr$target[ordered_marks2]


# Generate heatmap: select top 15 drugs (highest change at any IPR) per concentration
eff.data.heatmap <- indel.data %>%
  filter(target != "Aurora Kinase") %>%
  filter(sample == "drug" | drug == "DMSO") %>%
  #filter(Mod(eff_zscore_pooled_global_comb) >= 1.645) %>%  # we could also choose to display all drugs that have significant global hits
  distinct(conc_char,drug, IPR, MMEJ_zscore_comb)

## Select drugs that have a large effect size in at least one location (some drugs might have a small global effect size, but large local)
eff.data.heatmap2 <- eff.data.heatmap %>%
  mutate(mod = Mod(MMEJ_zscore_comb)) %>%
  mutate(max = ave(mod, drug, conc_char, FUN = max)) %>%
  filter(max > 2*2.58) %>% # p < 0.005
  dplyr::select(-mod, -max) %>%
  spread(IPR, MMEJ_zscore_comb)


breaks <- seq(-10, 10, 0.2)



for (i in unique(eff.data.heatmap2$conc_char)) {
  pheatmap(as.matrix(eff.data.heatmap2[eff.data.heatmap2$conc_char == i,] %>%
                       column_to_rownames('drug') %>%
                       dplyr::select(contains('IPR')) %>%
                       t()),
           border_color = "white",
           cellwidth = 12,
           cellheight = 12,
           cluster_rows = F,
           breaks = breaks,
           main = paste('MMEJ z-score, concentration =', i),
           annotation_col = target,
           annotation_row = chromatin,
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
           annotation_colors = annotation_colors_scr, annotation_legend = T)
}
```

*Figure 3C: Heatmap of MMEJ z-score per IPR for 15 most potent compounds per concentration.*

**Conclusion: At all three concentrations, the 15 most potent drugs reduce the MMEJ score. IPR10 is very sensitive to MMEJ score reduction, especially by HDACs.**



```{r export}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

