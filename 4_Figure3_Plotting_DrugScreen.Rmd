---
title: "DSB epigenetic drug screen - Figure 3"
author:
  - name: "Max Trauernicht & Ruben Schep"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output:
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '4'
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site IPRs was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(knitr)
library(tidyverse)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
# library(ggrepel)
library(GGally)
# library(DESeq2)
# library(gghighlight)
# library(platetools)
library(ggpubr)
# library(Laurae)
library(pheatmap)
library(RColorBrewer)
# # library(ggrastr)
library(broom)
# library(ggsignif)
# library(rstatix)
library(colorspace)

## Select outdir
out.dir = paste0("./figures/", Date, "/")
dir.create(out.dir)
in.dir = list.dirs(path = "/DATA/projects/DSBrepair/data/R") %>% .[grepl("episcreen", .)] %>% tail(n = 1)
opts_chunk$set(dev=c('png', 'pdf'), fig.path = file.path(out.dir))
pdf.options(useDingbats = FALSE)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

theme_classic_lines <- function() {
  theme_pubr(border = T, legend = "top") +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "white", color = "white")
            )
}
theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "white", color = "white")
            )
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 90) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "white", color = "white")
            )
}

theme_classic_lines_90_noborder <- function() {
  theme_pubr(border = F, legend = "top", x.text.angle = 90) +
            theme(strip.background = element_rect(fill = "white", color = "white")
            )
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#9AC1AE", "#5D987B", "#f2cc8f", "#e76f51")
# colors_drugs <- c("DMSO (neg control)" = "#65BFA4", "DNA-PKi (NHEJ control)" = "#8CA0C4", "drugs" = "#808184", "Mirin (MMEJ control)" = "#5D79AC")
colors_drugs <- c("#FA8D62", "#65BFA4", "#8CA0C4", "#808184", "#F6D289", "#E5E5E5", "#ACACAC", "#737373")
#colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 
## Chromatin groups
group_colors = c("Euchromatin" = "#f7941d",
                 "other-heterochromatin" = "#838687",
                 "Triple Heterochromatin" = "#662d91",
                 "H3K27me3" = "#d21f8a")

conc_control_colors = c("CTRL" = colors_drugs[2], "100 nM" = colors_drugs[7], "1 µM" = colors_drugs[4], "10 µM" = "#000000")
conc_colors = c("100 nM" = colors_drugs[7], "1 µM" = colors_drugs[4], "10 µM" = "#000000")

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
# Import data from preprocessing script
in.dir = list.dirs(path = "/DATA/projects/DSBrepair/data/R") %>% .[grepl("episcreen", .)] %>% tail(n = 1)
file = list.files(in.dir, pattern = "ratios", full.names = T) %>% tail(n = 1)
indel.data <- readRDS(file) # %>% filter(pathway_bal_filter == TRUE & viab_reproducibility == TRUE)
```

---

## C: MMEJ ratio heatmap: drug vs genomic location

## 2D HDACi heatmap
```{r prepare data for heatmaps}
# Set annotation for heatmap
# viability
viab_drug = indel.data %>% filter(drug != "PAO") %>% mutate(drug = gsub(" [(].*[)]", "", drug),
                                                            drug_conc = paste(drug, conc_char, sep = " ")) %>% distinct(viab_mean, drug_conc, replicate) %>% group_by(drug_conc) %>%
  summarise(viab = mean(viab_mean))
# Row annotation: annotate drugs with the target group
target_set_drugs <- indel.data %>% 
  filter(!target %in% c("Negative Control", "MRN", "DNA-PK")) %>%
  mutate(drug = gsub(" [(].*[)]", "", drug),
         drug_conc = paste(drug, conc_char, sep = " ")) %>%
  left_join(viab_drug) %>%
  distinct(drug, drug_conc, conc_char, target, viab) %>% 
  column_to_rownames(var="drug_conc")


chromatin <- readRDS(
  "/DATA/usr/x.vergara/XV_ChIPIndels/XV20200902_DDR_RS_revision/XV20200902_DDR_RS_revision/data/xv20200915_DDR_data_CHIP.rds") %>% 
  distinct(barcode, chromatin) %>%
  left_join(distinct(indel.data, barcode, IPR)) 
# chromatin$IPR[is.na(chromatin$IPR)] <- "IPR1"
chromatin <- chromatin %>%
  filter(IPR != "<NA>") %>% 
  dplyr::select(-barcode) %>%
  column_to_rownames(var="IPR")

# Change colors of annotations
chrom_colors = c("Euchromatin" = "#EAEEE8",
                 "other-heterochromatin" = "#a5a58d",  
                 "H3K27me3" = "#CAD6C2", 
                 "Triple Heterochromatin" = "#6b705c")

# colors <- brewer.pal(length(unique(barcode.annotation$cluster)), "Pastel2")
# names(colors) <- unique(barcode.annotation$cluster)

viab_colors = sequential_hcl(11, "Peach", rev = TRUE)
names(viab_colors) = seq(0, 1, by = 0.1)


annotation_colors_scr = list(
  chromatin = chrom_colors,
  target = c(HDAC="#60988D", HAT="#C6D0A8", Sirtuin="#8FCAAC",
             HMT="#FDCDAC", DNMT="#D69C81", `Histone Demethylase`="#FFF2AE",
             HIF="#E3DCD5", JAK="#C8D7E2", PIM="#9AB8C4", `Aurora Kinase`="#F4CAE4",
             PARP="#CB546F", `Epigenetic Reader Domain`= "#476D61", `DNA-PK`="#E07A43"),
  conc_char = conc_colors,
  clusters_drugs = sequential_hcl(7, "Plasma"),
  # viab_rep1 = c('#ffeee9', '#ffdcd4', '#ffcbbe', '#ffb8a8', '#fda693', '#f9947e', '#f4826a', '#ef6f56', '#e95b43', '#e24530'),
  # viab_rep2 = c('#ffeee9', '#ffdcd4', '#ffcbbe', '#ffb8a8', '#fda693', '#f9947e', '#f4826a', '#ef6f56', '#e95b43', '#e24530'),
  viab = viab_colors)



# Order the annotation legend
ordered_marks <- c("Euchromatin", 
                   "H3K27me3", 
                   "other-heterochromatin",  
                   "Triple Heterochromatin")

annotation_colors_scr$chromatin <- annotation_colors_scr$chromatin[ordered_marks]

# Order IPRs by their starting MMEJ_log2_FC value
dmso_bal <- indel.data %>%
  filter(drug == "DMSO") %>%
  distinct(IPR, MMEJ_log2_FC) %>%
  mutate(MMEJ_log2_FC = ave(MMEJ_log2_FC, IPR, FUN = function(x) mean(x, na.rm = TRUE))*100) %>%
  dplyr::select('dmso_bal' = MMEJ_log2_FC, IPR) %>%
  distinct() %>%
  arrange(desc(dmso_bal))

iprs <- dmso_bal$IPR
iprs <- as.character(iprs)


# Generate heatmap: select top drugs (highest change at any IPR) per concentration
balance.data <- indel.data %>%
  #filter(target != "Aurora Kinase") %>%
  filter(sample == "Epigenetic Compound") %>% 
  filter(pathway_bal_filter == TRUE & viab_reproducibility == TRUE) %>%
  #filter(Mod(MMEJ_zscore_comb) >= 2.58) %>%  # we can choose to display all drugs that have significant global hits
  distinct(conc_char, drug, target, IPR, MMEJ_zscore_comb, MMEJ_log2_FC, replicate, tech)

dmso_bal <- indel.data %>%
  filter(drug == "DMSO") %>%
  dplyr::select('dmso_bal' = MMEJ_log2_FC , IPR) %>%
  mutate(dmso_bal = ave(dmso_bal, IPR, FUN = function(x) mean(x, na.rm = TRUE))) %>%
  distinct()

balance.data.heatmap <- balance.data %>%
  # left_join(dmso_bal) %>%
  group_by(drug, conc_char) %>%
  # ave to add IPR grouping level to calculate mean of the replicates
  mutate(MMEJ_log2_FC_mean = ave(MMEJ_log2_FC, IPR, FUN = function(x) mean(x, na.rm = TRUE)),
         ## Select drugs that have a large effect size in at least one location 
         ## (some drugs might have a small global effect size, but large local)
         p_value = 2*pnorm(q = abs(MMEJ_zscore_comb), lower.tail = F),
         # Adjust p value for false discovery rate
         adj_pvalue = p.adjust(p_value, method = 'fdr'),
         # Pick the smallest per compound & concentration
         min_score = min(adj_pvalue)) %>%
  # filter for adjusted p.val < 0.001 so we keep compounds with at least one signif effect.
  filter(min_score < 0.01) %>%
  distinct(drug, target, conc_char, MMEJ_log2_FC_mean, IPR) %>%
  ungroup()


# replace -Inf with minimal value of the table.
min.value = min(balance.data.heatmap$MMEJ_log2_FC_mean[is.finite(balance.data.heatmap$MMEJ_log2_FC_mean)])

balance.data.heatmap2 <- balance.data.heatmap %>%
  mutate(MMEJ_log2_FC_mean = ifelse(is.infinite(MMEJ_log2_FC_mean), min.value, MMEJ_log2_FC_mean)) %>%
  spread(IPR, MMEJ_log2_FC_mean) %>%
  filter(!is.nan(IPR3))

balance.data.heatmap2 <- balance.data.heatmap2[,c("drug", "target", "conc_char", iprs)]
balance.data.heatmap2$drug <- gsub(" [(].*[)]", "", balance.data.heatmap2$drug) #shorten name of drug


breaks <- quantile(unlist(balance.data.heatmap2 %>% 
                            dplyr::select(contains('IPR'))), c(.05,.95), na.rm = T) # change these numbers according to where you want to set the cutoff
palette_length <- 100

myBreaks <- c(seq(breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
              seq(-breaks[1]/palette_length, -breaks[1], length.out=floor(palette_length/2)))


# myBreaks <- c(seq(-0.5, 0, length.out=ceiling(palette_length/2) + 1), 
#               seq(0.5/palette_length, 0.5, length.out=floor(palette_length/2)))

ordered_marks2 <- balance.data.heatmap2 %>% 
  dplyr::select(target) %>%
  distinct() %>%
  arrange(target)

ordered_marks2 <- ordered_marks2$target

annotation_colors_scr$target <- annotation_colors_scr$target[ordered_marks2]


# Add cluster annotation
clusters_drugs <- hclust(dist(balance.data.heatmap2), method = "complete")
clusters_drugs <- cutree(tree = clusters_drugs, k = 7)
clusters_drugs <- data.frame(clusters_drugs)

balance.data.heatmap2.clusters <- cbind(balance.data.heatmap2, clusters_drugs) %>% 
  as_tibble() %>%
  mutate(drug_conc = paste(drug, conc_char, sep = " "))

clusters_drugs <- balance.data.heatmap2.clusters %>%
  distinct(drug_conc, clusters_drugs)

target_set_all <- target_set_drugs %>%
  rownames_to_column("drug_conc") %>%
  left_join(clusters_drugs) %>%
  na.omit()
rownames(target_set_all) <- target_set_all$drug_conc
target_all <- target_set_all %>%
  dplyr::select(target, 
                clusters_drugs,
                conc_char, viab)
```

```{r S2A TIF heatmaps, warning = FALSE, fig.width = 10, fig.height = 20}
# pdf(paste0(figure_out, "rs20220623_indelfrequency_heatmap_allconc.pdf"), width=20, height=8)
plt1 = pheatmap(balance.data.heatmap2.clusters %>%
                  arrange(target_all) %>%
                  column_to_rownames('drug_conc') %>%
                  dplyr::select(contains('IPR')),
                border_color = F,
                cellwidth = 8,
                cellheight = 8,
                breaks = myBreaks,
                cluster_cols = T,
                cluster_rows = T,
                angle_col = 90,
                na_col = "white",
                main = 'efficiency change, all concentrations',
                annotation_row = target_all,
                annotation_col = chromatin,
                # color = colorRampPalette(c("#e07a5f", "#e5e5e5", "#3d405b"))(palette_length),
                color = diverge_hcl(palette_length, "Blue-Red"),
                annotation_colors = annotation_colors_scr, 
                annotation_legend = T,
                cutree_row = 7)
```



```{r Aurora Kinase, echo = FALSE}
aurora_targets <- data.frame("drug" = c("Alisertib","Aurora A Inhibitor I", "Barasertib","CCT129202", "CCT137690", "CYC116",
                                        "ENMD-2076","Hesperadin","JNJ-7706621","KW-2449","MK-5108","MLN8054","PHA-680632","SNS-314 Mesylate","ZM 447439"),
                             "A_B" = c("A", "A", "B", "A+B", "A+B","A+B", "A", "B", "A+B", "A", "A", "A", "A", "A+B", "A+B"),
                             "B" = c("No", "No", "Yes", "Yes", "Yes", "Yes", "No", "Yes", "Yes", "No", "No", "No", "No", "Yes", "Yes"),
                             "A" = c("Yes", "Yes", "No", "Yes", "Yes", "Yes", "Yes", "No", "Yes", "Yes", "Yes", "Yes", "Yes", "Yes", "Yes"))

ggplot(indel.data %>%
                filter(sample == "Epigenetic Compound") %>%
                filter(target == "Aurora Kinase") %>%
                distinct(MMEJratio, drug, conc_char, MMEJ_zscore_global_comb) %>%
                mutate(MMEJratio = ave(MMEJratio, drug, conc_char, FUN = mean)) %>%
                distinct() %>%
                mutate(MMEJ_pval_global_comb = 2*pnorm(q = abs(MMEJ_zscore_global_comb), lower.tail = F)) %>%
                mutate(MMEJ_pval_adj_global_comb = p.adjust(MMEJ_pval_global_comb, method = 'fdr')) %>%
         mutate(drug = gsub(" [(].*[)]", "", drug)) %>%
         left_join(aurora_targets),
              aes(y = -log10(MMEJ_pval_adj_global_comb), x = MMEJratio,
                  color = A_B)) +
  geom_point(size = 2) +
  #geom_label_repel(data = indel.data.freq2 %>% filter(flag == "TRUE") %>% unique(), 
                   #aes(label = drug)) +
  geom_hline(linetype = "dashed", yintercept = -log10(0.05)) +
  geom_vline(linetype = "dashed", xintercept = (dmso_bal$dmso_bal + 0.02)) +
  geom_vline(linetype = "dashed", xintercept = (dmso_bal$dmso_bal - 0.02)) +
  #geom_vline(linetype = "twodash", xintercept = unique(indel.data.freq$max_dmso_bal))+
  scale_color_manual(values = c("#6d6875", "#b5838d", "#ffb4a2")) +
  #facet_wrap(~conc_char) +
  #annotate("rect",xmin=(dmso_bal$dmso_bal + 0.02),xmax=unique(indel.data.freq$max_dmso_bal),ymin=-log10(0.05),ymax=Inf, alpha=0.1, fill="#e07a5f") +
  #annotate("rect",xmin=unique(indel.data.freq$max_dmso_bal),xmax=Inf,ymin=-Inf,ymax=Inf, alpha=0.25, fill="black") +
  #annotate("rect",xmin=-Inf,xmax=(dmso_bal$dmso_bal - 0.02),ymin=-log10(0.05),ymax=Inf, alpha=0.1, fill="#3d405b") +
  coord_flip()
```


## Visualisation
```{r, fig.width = 8, fig.height = 4}
# rmarkdown::render("3_Processing_FACS.Rmd")
all.samples = readRDS("FACS_set1.RDS")

vadj.G2 = all.samples %>% filter(variable %in% c("G2", "S", "G1")) %>% group_by(drug_conc, ID) %>% summarise(vadj = sum(mean_value)) %>% mutate(variable = "G1")
vadj.S = all.samples %>% filter(variable %in% c("S", "G1")) %>% group_by(drug_conc, ID) %>% summarise(vadj = sum(mean_value)) %>% mutate(variable = "S")
vadj.G1 = all.samples %>% filter(variable %in% c("G1")) %>% group_by(drug_conc, ID) %>% summarise(vadj = sum(mean_value)) %>% mutate(variable = "G2")

vadj.tib = rbind(vadj.G1, vadj.S, vadj.G2)

all.samples.plot = all.samples  %>% 
  as_tibble() %>% 
  filter(variable != "Apoptotic cells") %>% 
  left_join(vadj.tib) %>%
  left_join(target_set_drugs) %>%
  mutate(variable = factor(variable, levels = c("G2", "S", "G1")),
         target = ifelse(drug == "CX-6258", "PIM",
                         ifelse(drug == "DMSO", "Vehicle",
                                ifelse(drug == "DZNeP", "HMT",
                                       ifelse(drug == "Suramin", "Sirtuin",target)))),
         ID = gsub("GFP", "-sgRNA", ID))



all.samples.plot %>% filter(target %in% c("Aurora Kinase")) %>%
ggplot(., aes(y = mean_value, x = ID, fill = variable)) +
  geom_bar(stat="identity") + 
   geom_errorbar(aes(ymin = vadj-SD, ymax = vadj+SD, color = variable), width = 0.2)+
  labs(title = "cell cycle arrest upon treatment with Aurora Kinase inhibitors", 
       x = "GFP/LBR2 transfection", y = "G1, S, and G2 fractions") + 
  scale_fill_manual(values = c("#DED89C","#BF7538","#749075"))+
  facet_wrap(~ drug_conc, nrow = 1)
```

```{r, fig.width = 4, fig.height = 4}
# Barplot of each drug next to each other
all.samples.plot %>% filter(target %in% c("Vehicle")) %>%
ggplot(., aes(y = mean_value, x = ID, fill = variable)) +
  geom_bar(stat="identity") + 
   geom_errorbar(aes(ymin = vadj-SD, ymax = vadj+SD, color = variable), width = 0.2)+
  labs(title = "Cll cycle distribution in control setting", 
       x = "GFP/LBR2 transfection", y = "G1, S, and G2 fractions") + 
  scale_fill_manual(values = c("#DED89C","#BF7538","#749075"))
```

## Plot HDAC inhibitor effects on different chromatin types
```{r, fig.width = 4, fig.height = 4}
chromatin_ipr <- chromatin %>%
  rownames_to_column("IPR")

balance.data.heatmap3 <- balance.data.heatmap2 %>%
  pivot_longer(contains("IPR"), names_to = "IPR", values_to = "MMEJ_ratio_norm")

chromatin_effect <- merge(balance.data.heatmap3, chromatin_ipr) %>%
  #filter(target == "HDAC") %>%
  mutate(MMEJ_ratio_norm = ave(MMEJ_ratio_norm, drug, chromatin, conc_char, FUN = mean)) %>%
  distinct(MMEJ_ratio_norm, drug, chromatin, conc_char, target)

sigFunc = function(x){
  if(x < 0.001){"***"} 
  else if(x < 0.01){"**"}
  else if(x < 0.05){"*"}
  else{NA}}

ggplot(chromatin_effect %>%
         filter(target == "HDAC"),
              aes(x = chromatin, y = MMEJ_ratio_norm, fill = chromatin)) +
  geom_boxplot(outlier.shape = NA) +
  geom_quasirandom() +
  geom_signif(comparisons = combn(sort(unique(chromatin_effect$chromatin)), 2, simplify = F), 
              map_signif_level=sigFunc, 
              step_increase = 0.1) +
  theme_classic_lines_45() +
  scale_fill_manual(values = chrom_colors) +
  theme(legend.position = "none") +
  facet_wrap(~target)
```




## D: Correlation of MMEJ-ratio z-score with Efficiency z-score
Do the changes in MMEJ-ratio change correlate with changes in efficiency? Can MMEJ changes be explained by opened up/closed chromatin?

```{r, fig.width = 8, fig.height = 8,  warning = F}
for (i in unique(indel.data$target)[-1]) {
  
  x <- indel.data %>%
    filter(sample == "Epigenetic Compound") %>%
    filter(target == i) %>%
    mutate(mean_eff_pval_global_comb = 2*pnorm(q = abs(mean_eff_zscore_global_comb), lower.tail = F)) %>%
    mutate(mean_eff_pval_adj_global_comb = p.adjust(mean_eff_pval_global_comb, method = 'fdr')) %>%
    filter(mean_eff_pval_adj_global_comb < 0.01) %>%
    distinct(MMEJ_ratio_norm, freqCut_norm_mean, drug, conc_char, target, IPR) %>%
    mutate(MMEJ_ratio_norm = log2(ave(MMEJ_ratio_norm, drug, conc_char, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
    mutate(freqCut_norm_mean = log2(ave(freqCut_norm_mean, drug, conc_char, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
    distinct() %>%
    mutate(drug_conc = paste(drug, conc_char, sep = "_")) %>%
    filter(!is.na(MMEJ_ratio_norm))
  
  if (length(unique(x$drug_conc)) > 1) {
  p<- ggplot(x ,
       aes(x = MMEJ_ratio_norm, y = freqCut_norm_mean)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~drug_conc) +
  stat_cor(method = "spearman") +
  ggtitle(paste("efficiency vs. mmej-ratio per target group", i))
  
  print(p)
  }
}

ggplot_custom(indel.data %>%
    filter(sample == "Epigenetic Compound") %>%
    filter(drug == "PCI-24781 (Abexinostat)", conc_char == "100 nM") %>%
    mutate(mean_eff_pval_global_comb = 2*pnorm(q = abs(mean_eff_zscore_global_comb), lower.tail = F)) %>%
    mutate(mean_eff_pval_adj_global_comb = p.adjust(mean_eff_pval_global_comb, method = 'fdr')) %>%
    filter(mean_eff_pval_adj_global_comb < 0.001) %>%
    distinct(MMEJ_ratio_norm, freqCut_norm_mean, drug, conc_char, target, IPR) %>%
    mutate(MMEJ_ratio_norm = log2(ave(MMEJ_ratio_norm, drug, conc_char, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
    mutate(freqCut_norm_mean = log2(ave(freqCut_norm_mean, drug, conc_char, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
    mutate(drug_conc = paste(drug, conc_char, sep = "_")),
    aes(x = MMEJ_ratio_norm, y = freqCut_norm_mean)) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_cor(method = "spearman") +
  ggtitle("efficiency vs. mmej-ratio per target group")


eff_mmej_corr <- indel.data %>%
  filter(sample == "Epigenetic Compound") %>%
  filter(abs(mean_eff_zscore_global_comb) > 4) %>%
  filter(abs(MMEJ_zscore_global_comb) > 4) %>%
  distinct(MMEJ_ratio_norm, freqCut_norm_mean, drug, conc_char, target, IPR) %>%
  mutate(MMEJ_ratio_norm = log2(ave(MMEJ_ratio_norm, drug, conc_char, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
  mutate(freqCut_norm_mean = log2(ave(freqCut_norm_mean, drug, conc_char, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
  mutate(drug_conc = paste(drug, conc_char, sep = "_")) %>%
  mutate(slope = NA, term = NA, p.value = NA)

for (i in unique(eff_mmej_corr$drug_conc)) {
    model.correlation <- lm(formula = MMEJ_ratio_norm ~ freqCut_norm_mean, 
                               data = eff_mmej_corr[eff_mmej_corr$drug_conc == i,]) %>% 
      tidy()
    
    eff_mmej_corr$slope[eff_mmej_corr$drug_conc == i] <- 
      model.correlation$estimate
    
    eff_mmej_corr$term[eff_mmej_corr$drug_conc == i] <- 
      model.correlation$term
    
    eff_mmej_corr$p.value[eff_mmej_corr$drug_conc == i] <- 
      model.correlation$p.value
}



```

```{r, fig.width = 4, fig.height = 4}
eff_mmej_corr_heatmap <- eff_mmej_corr %>%
  filter(term != "(Intercept)") %>%
  mutate(p.value = p.adjust(p.value, method = "fdr")) %>%
  #filter(p.value < 0.05) %>%
  dplyr::select(-term, -IPR, -freqCut_norm_mean, -MMEJ_ratio_norm) %>%
  distinct()

ggplot_custom(eff_mmej_corr_heatmap %>%
                mutate(mean_slope = ave(slope, target, FUN = function(x) mean(x, na.rm=T))),
              aes(x = reorder(target, slope), y = slope)) +
  geom_boxplot(alpha = 0.4, outlier.shape = NA) +
  geom_quasirandom(aes(color = ifelse(p.value < 0.05, "green", "black"))) +
  theme_classic_lines_90()

```

```{r, fig.width = 4, fig.height = 4}
eff_mmej_corr_heatmap_plot <- indel.data %>%
  mutate(drug_conc = paste(drug, conc_char, sep = "_")) %>%
  filter(drug_conc %in% eff_mmej_corr_heatmap$drug_conc) %>%
  distinct(MMEJ_ratio_norm, freqCut_norm_mean, drug_conc, conc_char, target, IPR) %>%
  mutate(MMEJ_ratio_norm = log2(ave(MMEJ_ratio_norm, drug_conc, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
  mutate(freqCut_norm_mean = log2(ave(freqCut_norm_mean, drug_conc, IPR, FUN = function(x) mean(x, na.rm=T)))) %>%
  distinct()

pval <- eff_mmej_corr_heatmap %>%
  distinct(drug_conc, p.value, slope)

eff_mmej_corr_heatmap_plot <- merge(eff_mmej_corr_heatmap_plot, pval)

eff_mmej_corr_heatmap_plot <- eff_mmej_corr_heatmap_plot %>%
         filter(target %in% c("HDAC", "Aurora Kinase", "Epigenetic Reader Domain"))

ggplot(eff_mmej_corr_heatmap_plot,
       aes(x = MMEJ_ratio_norm, y = freqCut_norm_mean, group = drug_conc)) +
  geom_abline(linetype = "twodash") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point(alpha = 0.1, aes(color = ifelse(p.value < 0.05 & slope < -0.1, "green", 
                                                       ifelse(p.value < 0.05 & slope > 0.1, "yellow","blue")))) +
  geom_smooth(method = "lm", se = F, aes(color = ifelse(p.value < 0.05 & slope < -0.1, "green", 
                                                       ifelse(p.value < 0.05 & slope > 0.1, "yellow","blue")))) +
  facet_wrap(~target, nrow = 3) +
  ggtitle("efficiency vs. mmej-ratio per target group") +
  scale_color_manual(values = c("#C2C2C2", "#3d405b", "#e07a5f")) 
```


```{r export}
# setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/")
# filename <- SetFileName("_indel.data", "mt")
# save(indel.data, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

