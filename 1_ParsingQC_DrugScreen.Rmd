---
title: "Parsing_QC"
author: "Ruben Schep"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  pdf_document:
    toc: yes
  editor_options:
    chunk_output_type: console
  html_document:
    theme: journal
    highlight: monochrome
    toc: yes
    toc_float: yes
    code_folding: show
---

knitr document van Steensel lab

# Parsing and starcode quality control
# Introduction
After demultiplexing all the samples from the sequencing data, the data has been processed by the CRISPR-TRIP snakemake script. This script maps the barcodes from the iPCR (iPCR from 5 feb 2018). It calls the true barcodes with the starcode script for both the mutation and mapping reads. It call the mutations on all the mutation samples and spits them in mapped, unmapped and non genuine.


Here we want to do a QC of the parsing of the mapping, the barcodes and mutations. We will load the statistics data of all the files. We will also look at barcode counts from the table files (those list the barcodes from the starcode stript). I obtained the counts though shell with 

Pasted the result in a text editor and changes all `^ ` and changed the spaces to `\t`, removed the last total row, removed `.table` at the end and saved as text file. 
I will export a bed file also containing the broad integrations for the generation of mean chip values over the integration sites. 


# Data loading and processing 

## Path, Libraries, Parameters and Useful Functions  

```{r message=FALSE}
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 

# libraries:
library(plyr)
library(dplyr)
library(GenomicRanges)
library(RColorBrewer)
library(ggplot2)
library(magrittr)
library(platetools)
library(grid)
library(gridExtra)
library(purrr)
```
 
## Custom functions  

Functions used in this script:   

```{r}
MakeGranges <- function(x) {
  x$end_pos <- as.numeric(as.character(x$start_pos+3))
  colnames(x) <- c("name",
                   "seqname", 
                   "strand", 
                   "start",
                   "total_mapped", 
                   "mapq_sum1", 
                   "reads1", 
                   "mapq_sum2", 
                   "reads2", 
                   "seq", 
                   "end")
  gr <- makeGRangesFromDataFrame(x, keep.extra.columns = T)
  return(gr)
}

BarcodeOverlap <- function(read1, read2) {
  counts <- c(nrow(read1), 
              nrow(read2), 
              sum(read2$barcode %in% read1$barcode), 
              sum(!read1$barcode %in% read2$barcode),
              sum(!read2$barcode %in% read1$barcode))
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, substr(gsub("-","",Sys.time()),1,8), filename)
  filename
}
```

## Data loading  

These are data from the crispr-trip.snake script, and a text file that has has been obtained as explained above.  

```{r}
# Import metadata 
file = "/DATA/projects/DSBrepair/config/rs20210628_E177_E1504_EpiScreen_metadata.txt"
meta_data = fread(file, header = TRUE)

# load the statistics data from the indels.
file.list <- list.files(path = "/DATA/projects/DSBrepair/data/rs20210628_EpiScreen/parsed", pattern="indel*.*statistics.txt", full.names = TRUE)
indel.statistics.list <- lapply(file.list, read.table, 
                                  header = TRUE)
names(indel.statistics.list)<- gsub(".*//indelPCR.indel_(.*?).statistics.txt", 
                                      "\\1", 
                                      file.list)

# Format the statistics and bind the meta data
indel.statistics.tib <- do.call(rbind.data.frame, 
                               indel.statistics.list) %>% 
  rownames_to_column(var = "ID") %>%
  as_tibble() %>%
  mutate(ID = gsub(".*indelPCR.(.*).statistics.txt", "\\1", ID)) %>%
  left_join(meta_data)
  
# Calculate fraction written
indel.statistics.tib %<>% 
  mutate(r_written_pct = reads_written / reads)
```

### Indel parsing  


```{r}
ggplot(indel.statistics.tib, aes(well, log10(reads))) + 
  geom_bar(stat = "identity", aes(fill = as.character(concentration))) + 
  facet_grid(replicate ~ plate, scales = "free")

# How many reads per sample?
indel.statistics.tib %>% 
  group_by(replicate, seq_barcode) %>% 
  dplyr::summarise(reads = sum(reads)) %>%
  ggplot(., aes(seq_barcode, reads, fill = seq_barcode)) + 
  geom_bar(stat = "identity") + 
  facet_grid(. ~ replicate)
# How many reads per row?
indel.statistics.tib %>% 
  separate(well, c("column", "row"), sep = 1) %>% 
  group_by(replicate, row) %>% dplyr::summarise(reads = sum(reads)) %>%
  ggplot(., aes(row, reads, fill = row)) + 
  geom_bar(stat = "identity") + 
  facet_grid(. ~ replicate)
# How many reads per column?
indel.statistics.tib %>% 
  separate(well, c("column", "row"), sep = 1) %>% 
  group_by(replicate, column) %>% dplyr::summarise(reads = sum(reads)) %>%
  ggplot(., aes(column, reads, fill = column)) + 
  geom_bar(stat = "identity") + 
  facet_grid(. ~ replicate)

# How many reads per well (for the 96 index) replicate 1?
well.statistics <- indel.statistics.tib %>% 
  filter(replicate == "E177") %>%
  group_by(well) %>% 
  dplyr::summarise(reads = sum(reads))

raw_map(well.statistics$reads, 
                 well.statistics$well) + 
  scale_fill_distiller(type = "div", name = "reads")

# How many reads per well (for the 96 index) replicate 2?
well.statistics <- indel.statistics.tib %>% 
  filter(replicate == "E1504") %>%
  group_by(well) %>% 
  dplyr::summarise(reads = sum(reads))
  
raw_map(well.statistics$reads, 
                 well.statistics$well) + 
  scale_fill_distiller(type = "div", name = "reads")


# % of reads written from the total reads :


```

```{r reads per well replicate 1, fig.width = 12, fig.height = 4}
for (i in 1:18) {
  
  # Select the flowjo data set
  data <- filter(indel.statistics.tib, plate == i, replicate == "E177")
  
  # Find reasonable limits 
  limits <- c(1000, 35000)
  
    # Plot this, first the read cound density
  y <- density(data$reads)
  plt1 <- ggplot(data.frame(x = y$x, y = y$y),
                 aes(x = x, y = y)) +
    geom_line() +
    geom_segment(aes(xend = x, yend = 0, colour = x)) +
    xlim(limits) +
    scale_color_distiller(type = "div", limits = limits, name = "reads") +
    theme_bw() +
    theme(legend.position="none")
  
  # Then the plate with color-coded wells
  plt2 <- raw_map(data$reads, 
                 data$well) +
    ggtitle(unique(gsub("(.*)_...$", "\\1", data$ID))) +
    scale_fill_distiller(type = "div", limits = limits, name = "reads")
  
  grid.arrange(plt1, plt2, ncol = 2, widths = c(1, 1.3))
}
```

```{r reads per well replicate 2, fig.width = 12, fig.height = 4}
for (i in 1:18) {
  
  # Select the flowjo data set
  data <- filter(indel.statistics.tib, plate == i, replicate == "E1504")
  
  # Find reasonable limits 
  limits <- c(1000, 300000)

  # Plot this, first the read cound density
  y <- density(data$reads)
  plt1 <- ggplot(data.frame(x = y$x, y = y$y),
                 aes(x = x, y = y)) +
    geom_line() +
    geom_segment(aes(xend = x, yend = 0, colour = x)) +
    xlim(limits) +
    scale_color_distiller(type = "div", limits = limits, name = "reads") +
    theme_bw() +
    theme(legend.position="none")
  
  # Then the plate with color-coded wells
  plt2 <- raw_map(data$reads, 
                 data$well) +
    ggtitle(unique(gsub("(.*)_...$", "\\1", data$ID))) +
    scale_fill_distiller(type = "div", limits = limits, name = "reads")
  
  grid.arrange(plt1, plt2, ncol = 2, widths = c(1, 1.3))
}
```


# Conclusion
- In general, the data looks very good
- Some plates have wells with 0 reads - other wells take over the reads in this plate - we have to investigate further whether this can be a problem.

# Session Info  
```{r}
sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))

```