---
title: "DSB Episcreen data analysis & plotting"
author: 
  - name: "Max Trauernicht"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site IPRs was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
$(document).ready(function() {
$items = $('div#TOC li');
$items.each(function(idx) {
num_ul = $(this).parentsUntil('#TOC').length;
$(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
});

});
</script>

```{css, echo = FALSE}
div.sourceCode {
overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(ggpubr)
library(tidyr)
library(Laurae)
library(tibble)
library(pheatmap)
library(RColorBrewer)
library(ggrastr)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
  ## Methods 'Hommel', 'BH', 'BY' and speed improvements
  ## contributed by Gordon Smyth
  method <- match.arg(method)
  if(method == "fdr") method <- "BH"	# back compatibility
  nm <- names(p)
  p <- as.numeric(p)
  p0 <- setNames(p, nm)
  if(all(nna <- !is.na(p))) nna <- TRUE
  p <- p[nna]
  lp <- length(p)
  # stopifnot(n >= lp)
  if (n <= 1) return(p0)
  if (n == 2 && method == "hommel") method <- "hochberg"
  
  p0[nna] <-
    switch(method,
           bonferroni = pmin(1, n * p),
           holm = {
             i <- seq_len(lp)
             o <- order(p)
             ro <- order(o)
             pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
           },
           hommel = { ## needs n-1 >= 2 in for() below
             if(n > lp) p <- c(p, rep.int(1, n-lp))
             i <- seq_len(n)
             o <- order(p)
             p <- p[o]
             ro <- order(o)
             q <- pa <- rep.int( min(n*p/i), n)
             for (j in (n-1):2) {
               ij <- seq_len(n-j+1)
               i2 <- (n-j+2):n
               q1 <- min(j*p[i2]/(2:j))
               q[ij] <- pmin(j*p[ij], q1)
               q[i2] <- q[n-j+1]
               pa <- pmax(pa,q)
             }
             pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
           },
           hochberg = {
             i <- lp:1L
             o <- order(p, decreasing = TRUE)
             ro <- order(o)
             pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
           },
           BH = {
             i <- lp:1L
             o <- order(p, decreasing = TRUE)
             ro <- order(o)
             pmin(1, cummin( n / i * p[o] ))[ro]
           },
           BY = {
             i <- lp:1L
             o <- order(p, decreasing = TRUE)
             ro <- order(o)
             q <- sum(1L/(1L:n))
             pmin(1, cummin(q * n / i * p[o]))[ro]
           },
           none = p)
  p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {
  
  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)
  
  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }
  
  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())
  
  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]
  
  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }
  
  p <- p +
    theme(panel.background = element_rect(fill = corCol))
  
  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

theme_classic_lines <- function() {
  theme_pubr(border = F, legend = "top") +
    theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
          strip.background = element_rect(fill = "#ced4da")
    )
}
theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
    theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
          strip.background = element_rect(fill = "#ced4da")
    )
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 90) +
    theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
          strip.background = element_rect(fill = "#ced4da")
    )
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#9AC1AE", "#5D987B", "#f2cc8f", "#e76f51")
colors_drugs <- c("#FA8D62", "#65BFA4", "#8CA0C4", "#808184", "#F6D289", "#E5E5E5", "#ACACAC", "#737373")
#colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
# Import data from preprocessing script
validations_ratios = readRDS("/DATA/projects/DSBrepair/data/R/rs20220208_episcreen/rs20220208_episcreen_validation_ratios.RDS")
validations_indels = readRDS("/DATA/projects/DSBrepair/data/R/rs20220208_episcreen/rs20220208_episcreen_validation_indels.RDS")
screen_indels = readRDS("/DATA/projects/DSBrepair/data/R/rs20220207_episcreen/rs20220207_episcreen_mutations.RDS")
screen_ratios = readRDS("/DATA/projects/DSBrepair/data/R/rs20220207_episcreen/rs20220207_episcreen_ratios.RDS")

# Complete data without exlcluding wells <0.45 viability (I need this for plotting)
viability.data = as.data.table(readRDS("/DATA/projects/DSBrepair/git/EpiScreen/files_scripts/rs20211221_Episcreen_Reads_Viab_Metadata.RDS")) %>%
  dplyr::select(ID, drug, target, replicate, viability, conc_char, tech)

# Chromatin info
chromatin.features <- colnames(screen_ratios)[grepl("[.]zscore", colnames(screen_ratios))]
chrom_data = screen_ratios %>% dplyr::select(barcode, all_of(chromatin.features)) %>% distinct()

chromatin.features
chromatin.feature.colors = c()

# Figure out folder
figure_out = "/DATA/projects/DSBrepair/scratch/episcreen/"

```


## Figure 1A
```{r}

```
# Prepare data

## Calculate distances
```{r}
# Data table and compute log2_ratio (This line needs to be adjusted)
filtered_drug_conc = screen_ratios %>%
  filter(abs(mean_eff_zscore_comb) > 1.96 | abs(MMEJ_zscore_comb) > 1.96 | drug == "DMSO") %>%
  mutate(drug_conc = paste(drug, conc_char, sep = "_"),
         effect_on_indelrate = ifelse(abs(mean_eff_zscore_comb) > 1.96, TRUE, FALSE),
         effect_on_ratio = ifelse(abs(MMEJ_zscore_comb) > 1.96, TRUE, FALSE)) %>%
  distinct(drug, conc_char, drug_conc, effect_on_indelrate, effect_on_ratio) %>%
  mutate(counts = ave(drug_conc, drug, conc_char, FUN = function(x) length(x)),
         keep = ifelse(counts > 1 & !effect_on_indelrate | counts > 1 & !effect_on_ratio, FALSE, TRUE)) %>%
  filter(keep) %>% 
  distinct(drug, conc_char, drug_conc, effect_on_indelrate, effect_on_ratio)


ratios_tib <- screen_ratios %>%
  mutate(drug_conc_char = paste(drug, conc_char, sep = "_")) %>%
  semi_join(filtered_drug_conc) %>%
  distinct(NHEJratio, freqCut, drug, conc_char, target, barcode) %>%
  mutate(NHEJratio = ave(NHEJratio, drug, conc_char, barcode, FUN = mean)) %>%
  mutate(NHEJratio.log2 = log2(NHEJratio)) %>%
  mutate(freqCut = (ave(freqCut, drug, conc_char, barcode, FUN = mean))) %>%
  mutate(freqCut.log2 = log2(freqCut)) %>%
  distinct()

dmso_ratios_tib <- screen_ratios %>%
  filter(drug == "DMSO") %>%
  distinct(NHEJratio, freqCut, barcode) %>%
  mutate(DMSO.ratio = ave(NHEJratio, barcode, FUN = mean)) %>%
  mutate(DMSO.ratio.log2 = log2(DMSO.ratio)) %>%
  mutate(DMSO.freqCut = ave(freqCut, barcode, FUN = mean)) %>%
  mutate(DMSO.freqCut.log2 = log2(DMSO.freqCut)) %>%
  dplyr::select(-NHEJratio, -freqCut) %>%
  distinct()

ratios_tib <- merge(ratios_tib, dmso_ratios_tib) %>% 
  dplyr::group_by(barcode, drug, conc_char) %>% 
  mutate(log2.dist.ratio = NHEJratio.log2 - DMSO.ratio.log2, 
         log2.dist.freqCut = freqCut.log2 - DMSO.freqCut.log2) %>%
  left_join(chrom_data)
```

The log2 distance ratio in our case is positive if it promotes NHEJ and negative if it promotes NHEJ

## Calculate slopes
```{r}
# Perform analysis across all features for three test genes
ratios_tib %<>% mutate(drug_conc = paste(drug, conc_char, sep = "_"))

slope.protein.features <- tibble(drug_conc = NA, feature = NA,  term = NA, 
                                 indelrate = NA, p.value.indelrate = NA, 
                                 ratio = NA, p.value.ratio = NA)

for (i in unique(ratios_tib$drug_conc)) {
  for (j in chromatin.features) {
    model_tib <- ratios_tib %>% filter(drug_conc == i) 
    
    # Indel rates
    model.indelrate.log2 <- lm(formula = log2.dist.freqCut ~ unlist(model_tib[j]), 
                               data = model_tib) %>% 
      tidy()
    
    # Pathway balance
    model.ratio.log2 <- lm(formula = log2.dist.ratio ~ unlist(model_tib[j]), 
                           data = model_tib) %>% 
      tidy()
    
    slope.protein.features <- slope.protein.features %>% 
      add_row(drug_conc = i, 
              feature = j, 
              term = model.indelrate.log2 %>%
                pull(term),
              indelrate = model.indelrate.log2 %>% 
                pull(estimate), 
              p.value.indelrate = model.indelrate.log2 %>% 
                pull(p.value),
              ratio = model.ratio.log2 %>% 
                pull(estimate), 
              p.value.ratio = model.ratio.log2 %>% 
                pull(p.value))
  }
}

# Remove the 1st NA column
slope.protein.features %<>% 
  filter(!is.na(.)) %>%
  mutate(term = ifelse(term == "(Intercept)", "intercept", "slope"))
```

## Filter the slop
```{r synergy filtering}
# Calculate postition where the linear model crosses y = 0, we do this by -intercept / slope
synergy_tib = slope.protein.features %>% 
  distinct(drug_conc, term, feature, indelrate, ratio) %>% 
  pivot_wider(., names_from = term, values_from = c(indelrate, ratio)) %>%
  mutate(x_intercept_indelrate = -indelrate_intercept / indelrate_slope,
         x_intercept_ratio = -ratio_intercept / ratio_slope)

effect_compounts = ratios_tib %>%
  group_by(drug_conc)  %>% 
  mutate(indelrate_pos = sum(log2.dist.freqCut > 0),
         indelrate_effect = ifelse(indelrate_pos >= 17, "indel_rate_increase", 
                                   ifelse(indelrate_pos <= 1, "indel_rate_decrease", "mixed")),
         ratio_pos = sum(log2.dist.ratio > 0),
         ratio_effect = ifelse(ratio_pos >= 17, "NHEJ_increase", 
                               ifelse(ratio_pos <= 1, "MMEJ_increase", "mixed"))) %>%
  distinct(drug_conc, indelrate_effect, ratio_effect) %>% 
  left_join(distinct(filtered_drug_conc, drug_conc, effect_on_indelrate, effect_on_ratio))

p.vals = slope.protein.features %>% filter(term == "slope") %>% dplyr::select(-term, -indelrate , -ratio) %>% distinct()

synergy_tib %<>% left_join(effect_compounts)  %>% 
  left_join(p.vals) %>%
  mutate(
    # x_intercept_indelrate = ifelse(p.value.indelrate < 0.05,
    #                                x_intercept_indelrate, NA),
    # x_intercept_ratio = ifelse(p.value.ratio < 0.05,
    #                            x_intercept_ratio, NA),
    indelrate_slope_plot = ifelse(x_intercept_indelrate < 1 & effect_on_indelrate, indelrate_slope, NA),
    ratio_slope_plot = ifelse(x_intercept_ratio < 1 & effect_on_ratio, ratio_slope, NA))  
```


```{r tile plots}
## Quick tile plot for indel rate
synergy_tib %>% 
  distinct(drug_conc, feature, indelrate_slope_plot) %>%
  filter(grepl("100 nM", drug_conc) & complete.cases(.)) %>%
  ggplot() + 
  geom_tile(aes(drug_conc,feature, fill = indelrate_slope_plot)) + 
  scale_fill_gradient2() + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))

synergy_tib %>% 
  distinct(drug_conc, feature, indelrate_slope_plot) %>%
  filter(grepl("1 µM", drug_conc) & complete.cases(.)) %>%
  ggplot() + 
  geom_tile(aes(drug_conc,feature, fill = indelrate_slope_plot)) + 
  scale_fill_gradient2() + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))

synergy_tib %>% 
  distinct(drug_conc, feature, indelrate_slope_plot) %>%
  filter(grepl("10 µM", drug_conc) & complete.cases(.)) %>%
  ggplot() + 
  geom_tile(aes(drug_conc,feature, fill = indelrate_slope_plot)) + 
  scale_fill_gradient2() + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))

## Quick tile plot for ratio
synergy_tib %>% 
  distinct(drug_conc, feature, ratio_slope_plot) %>%
  filter(grepl("100 nM", drug_conc) & complete.cases(.)) %>%
  ggplot() + 
  geom_tile(aes(drug_conc,feature, fill = ratio_slope_plot)) + 
  scale_fill_gradient2() + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))

synergy_tib %>% 
  distinct(drug_conc, feature, ratio_slope_plot) %>%
  filter(grepl("1 µM", drug_conc) & complete.cases(.)) %>%
  ggplot() + 
  geom_tile(aes(drug_conc,feature, fill = ratio_slope_plot)) + 
  scale_fill_gradient2() + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))

synergy_tib %>% 
  distinct(drug_conc, feature, ratio_slope_plot) %>%
  filter(grepl("10 µM", drug_conc) & complete.cases(.)) %>%
  ggplot() + 
  geom_tile(aes(drug_conc,feature, fill = ratio_slope_plot)) + 
  scale_fill_gradient2() + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))

```


```{r processing for heatmaps}
slope.features.tib <- synergy_tib %>% 
  dplyr::select(drug_conc, ratio_slope_plot, indelrate_slope_plot, feature) %>%
  group_by(drug_conc) %>%
  mutate(count_ratio = sum(is.na(ratio_slope_plot)), 
         count_rate = sum(is.na(indelrate_slope_plot)),
         feature = gsub(".zscore", "", feature))

all_compounds_pathway_synergy = slope.features.tib %>% 
  dplyr::select(drug_conc, ratio_slope_plot, feature, count_rate) %>%
  filter(count_rate != 25) %>% 
  dplyr::select(-count_rate) %>%
  group_by(feature, drug_conc) %>%
  mutate(count_feature_rate = sum(ratio_slope_plot),
         drug_conc = gsub("_", " ", drug_conc)) %>%
  filter(count_feature_rate != 0) %>% # remove if 25x NA
  dplyr::select(-count_feature_rate) %>%
  reshape2::dcast(drug_conc ~ feature, value.var = "ratio_slope_plot", fill = 0) %>% 
  column_to_rownames(var = "drug_conc") %>%
  mutate_all(type.convert)

all_compounds_indelrate_synergy = slope.features.tib %>% 
  dplyr::select(drug_conc, indelrate_slope_plot, feature, count_rate) %>%
  filter(count_rate != 25) %>% 
  dplyr::select(-count_rate) %>%
  group_by(feature, drug_conc) %>%
  mutate(count_feature_rate = sum(indelrate_slope_plot),
         drug_conc = gsub("_", " ", drug_conc)) %>%
  filter(count_feature_rate != 0) %>% # remove if 25x NA
  dplyr::select(-count_feature_rate) %>%
  reshape2::dcast(drug_conc ~ feature, value.var = "indelrate_slope_plot", fill = 0) %>% 
  column_to_rownames(var = "drug_conc") %>%
  mutate_all(type.convert)
```



```{r heatmaps annotation}
domains_c5 = screen_ratios %>% distinct(IPR, chromatin) %>% column_to_rownames(var = "IPR")
domains_c5[c("IPR9", "IPR5", "IPR15"), ] <- "transcription"
domains_c5[c("IPR3", "IPR19"), ] <- "euchromatin-regulation"
domains_c5[c("IPR8", "IPR13", "IPR17"), ] <- "other"


# colors <- brewer.pal(length(unique(barcode.annotation$cluster)), "Pastel2")
# names(colors) <- unique(barcode.annotation$cluster)
annotation_colors_scr = list(
  target = c(HDAC="#60988D", HAT="#C6D0A8", Sirtuin="#8FCAAC",
             HMT="#FDCDAC", DNMT="#D69C81", `Histone Demethylase`="#FFF2AE",
             HIF="#E3DCD5", JAK="#C8D7E2", PIM="#9AB8C4", `Aurora Kinase`="#F4CAE4",
             PARP="#CB546F", `Epigenetic Reader Domain`= "#476D61", 
             `DNA-PK`="#E07A43", `Negative Control` = "gray50", MRN = "black"),
  conc_char = c(`100 nM` = "#78BF84", `1 µM`  = "#1E9532", `10 µM` = "#0F4A19"),
  chromatin = c(H3K27me3 = "#E5077E", `euchromatin-regulation` = "#FFE156", 
  transcription = "#F08217", `late_replicating-LAD-H3K9me2` = "#4B235D", other = "#AFB5A6"),
  group = c(insulator="#A53860", repressive="#141414", polycomb ="#450920", euchromatin="#698996",
                 transcribing="#407076", HDAC="#EBBAB9", accessibility='#97B1A6',
                 methylation='#C9C5BA'))


ordered_marks2 <- c("Negative Control", "MRN", "DNA-PK",
                    "Epigenetic Reader Domain", "HDAC",  "Sirtuin", "HAT", 
                    "Histone Demethylase", "HMT", "DNMT", 
                    "HIF", "JAK", "PIM",
                    "Aurora Kinase", "PARP")

#Epistatic interaction colors
slope.colors <- tibble(color = c("#8c510a", "#f5f5f5","#01665e"),label = c("negative","none","positive"), feature = "synergy")

annotation_colors_scr$target <- annotation_colors_scr$target[ordered_marks2]

clone5.matrix = screen_ratios %>% dplyr::select(IPR, ends_with(".zscore")) %>% 
  setNames(., gsub(".zscore", "", names(.))) %>% 
  distinct() %>%
  column_to_rownames(var="IPR")

clone5_map = hclust(dist(t(clone5.matrix)))

# Set annotation for heatmap
# Row annotation: annotate drugs with the target group
target <- screen_ratios %>% 
  mutate(drug_conc = paste(drug, conc_char, sep = " ")) %>%
  distinct(target, conc_char, drug_conc) %>% 
  column_to_rownames(var="drug_conc")

annotation_colors_scr$target <- annotation_colors_scr$target[ordered_marks2]

clustering = data.frame(row.names=c('LMNB1', 'late_replicating', 'H3K9me2',"H3K9me3",
                                    'H3K27me3', 'EZH2', 'CTCF', 'SMC3',
                                    'HDAC3', 'HDAC2', 'HDAC1', 'H3K4me1',
                                    'H3K4me2', 'H3K4me3', 'H3K27ac',
                                    'H4K5acK8ac', 'H2AFZ', 'DNAse', 'Dam', 'm5C',
                                    'H3K79me2', 'TTseq', 'H3K36me3', 'POL2AS2',
                                    'POL2'),
                        group=factor(c(rep('repressive', 4), rep('polycomb',2 ), rep('insulator', 2),
                                       rep('HDAC', 3), rep('euchromatin', 6),
                                       rep('accessibility', 2), 'methylation',
                                       rep('transcribing', 5)),
                                     levels=c('transcribing', 'accessibility',
                                              'methylation', 'euchromatin',
                                              'HDAC', 'insulator','polycomb', 'repressive')))

```


# Figure Panels
## Panel A - MMEJ ratio z-scores
```{r all compounds pathway z-score}
filtered_drug_conc_ratio = filtered_drug_conc %>% 
  filter(effect_on_ratio) %>%
  mutate(drug_conc = gsub("_", " ", drug_conc)) %>% 
  pull(drug_conc)

ratios_tib = screen_ratios %>% 
  mutate(drug_conc = paste(drug, conc_char, sep = " ")) %>% 
  filter(drug_conc %in% filtered_drug_conc_ratio & 
           drug != "DNA-PKi") %>%
  distinct(IPR, MMEJ_zscore_comb, drug_conc, drug, conc_char) 

mmejzscore_matrix = ratios_tib %>%
  distinct(drug_conc, IPR, MMEJ_zscore_comb) %>% 
  pivot_wider(names_from = IPR, values_from = MMEJ_zscore_comb) %>%
  column_to_rownames(var = "drug_conc")

clone5_map_ipr_18 = hclust(dist(clone5.matrix))
# clone5_map_ipr_19 = chip_clone5 %>% 
#   select(-barcode, -group, -pool, -binsize, -ID) %>%
#   column_to_rownames(var = "IPR") %>% 
#   as.matrix() %>%
#   dist() %>% 
#   hclust()

quant_breaks <- quantile(mmejzscore_matrix, c(.01,.99), na.rm = T) # change these numbers according to where you want to set the cutoff
palette_length <- 1000

breaks <- c(seq(quant_breaks[1], 
                quant_breaks[1]/palette_length, 
                length.out=ceiling(palette_length/2) + 1), 
            seq(quant_breaks[2]/palette_length,  
                quant_breaks[2], 
                length.out=floor(palette_length/2)))

colors = colorRampPalette(slope.colors %>% pull(color))(length(breaks))
colors[-which(breaks < -1.96 | breaks > 1.96 )] = "gray90"

# 
pdf(paste0(figure_out, "rs20220210_zscorepathwayratio_all.pdf"), width=10, height=20)

pheatmap(mmejzscore_matrix[, clone5_map_ipr_18$labels],
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         cluster_cols = clone5_map_ipr_18,
         breaks = breaks,
         annotation_row = target,
         main = "MMEJ z-scores per IPR and compound",
         color = colors,
         annotation_colors = annotation_colors_scr, annotation_legend = T,
         annotation_col = domains_c5,
         cutree_rows = 7)

dev.off()

# pdf(paste0(figure_out, "rs20220210_zscorepathwayratio_all.pdf"), width=10, height=20)
# 
# pheatmap(mmejzscore_matrix[, clone5_map_ipr_18$labels],
#          border_color = F,
#          cellwidth = 8,
#          cellheight = 8,
#          cluster_cols = clone5_map_ipr_18,
#          breaks = breaks,
#          annotation_row = target,
#          main = "MMEJ z-scores of the synergy hits",
#          color = colors,
#          annotation_colors = annotation_colors_scr, annotation_legend = T,
#          annotation_col = domains_c5,
#          cutree_rows = 7)
# 
# dev.off()
# 
# pdf(paste0(figure_out, "rs20220210_zscorepathwayratio_all_autocluster.pdf"), width=10, height=20)
# 
# pheatmap(mmejzscore_matrix[, clone5_map_ipr_18$labels],
#          border_color = F,
#          cellwidth = 8,
#          cellheight = 8,
#          # cluster_cols = clone5_map_ipr_18,
#          breaks = breaks,
#          annotation_row = target,
#          main = "MMEJ z-scores of the synergy hits",
#          color = colors,
#          annotation_colors = annotation_colors_scr, annotation_legend = T,
#          annotation_col = domains_c5,
#          cutree_rows = 7)
# 
# dev.off()
```


```{r all concentrations combined pathway}
# giveNAs = which(is.na(as.matrix(dist(all_compounds_pathway_synergy))),arr.ind=TRUE)
# unique(giveNAs)
# 
# tab = sort(table(c(giveNAs)),decreasing=TRUE)
# checkNA = sapply(1:length(tab),function(i){
# sum(is.na(as.matrix(dist(all_compounds_pathway_synergy[-as.numeric(names(tab[1:i])),]))))
# })
# rmv = names(tab)[1:min(which(checkNA==0))]

# screen_ratios %>% dis

quant_breaks <- quantile(all_compounds_pathway_synergy, c(.01,.99), na.rm = T) # change these numbers according to where you want to set the cutoff
palette_length <- 1000
breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
            seq(quant_breaks[2]/palette_length, quant_breaks[2], length.out=floor(palette_length/2)))
colors = colorRampPalette(slope.colors %>% pull(color))(length(breaks))
colors[which(quant_breaks == 0)-1] = "gray90"


pdf(paste0(figure_out, "rs20220210_synergy_pathwayratio_all.pdf"), width=10, height=13)

pheatmap(all_compounds_pathway_synergy[, clone5_map$labels],
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         # cluster_cols = clone5_map,
         breaks = breaks,
         annotation_row = target,
         main = "Pathway balance slopes for all compounds with significant hit",
         color = colors,
         annotation_colors = annotation_colors_scr, annotation_legend = T,
         annotation_col = clustering,
         cutree_rows = 8)

dev.off()
```


# Panel B
```{r}

```







```{r export}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/")
filename <- SetFileName("_screen_ratios", "mt")
save(screen_ratios, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

