---
title: "DSB Episcreen data analysis & plotting"
author: 
  - name: "Max Trauernicht"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site IPRs was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(ggpubr)
library(tidyr)
library(Laurae)
library(tibble)
library(pheatmap)
library(RColorBrewer)
library(ggrastr)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
boundaries <- c(0.7,0.75,0.8,0.85)
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(techn_repl %>% filter(large_effect == "0_yes") %>% dplyr::select(contains("E1")), mapping$x)
  y   <- eval_data_col(techn_repl %>% filter(large_effect == "0_yes") %>% dplyr::select(contains("E1")), mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

theme_classic_lines <- function() {
  theme_pubr(border = F, legend = "top") +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}
theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 90) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#9AC1AE", "#5D987B", "#f2cc8f", "#e76f51")
colors_drugs <- c("#FA8D62", "#65BFA4", "#8CA0C4", "#808184", "#F6D289", "#E5E5E5", "#ACACAC", "#737373")
#colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
# Import data from preprocessing script
#indel.data <- readRDS("/DATA/projects/DSBrepair/data/R/rs20220120_episcreen2/rs20220120_episcreen_ratios.RDS")
indel.data <- readRDS("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/mt20220120_episcreen.RDS")
```

---

## A: Cutting efficiency change per drug
Are there any drugs (per concentration) that significantly change the cutting efficiency significantly across all IPRs?
```{r warning = FALSE}
# A: Cutting efficiency per drug - beeswarm plot
ggplot_custom(indel.data %>%
                filter(sample == "drug") %>%
                distinct(eff_zscore_pooled_global_comb, drug, conc_char),
              aes(x = conc_char, y = eff_zscore_pooled_global_comb, color = ifelse(Mod(eff_zscore_pooled_global_comb) > 1.645, "red", "black"))) +
  geom_quasirandom() +
  geom_hline(linetype = "dashed", yintercept = 1.645) +
  geom_hline(linetype = "dashed", yintercept = -1.645)
```

*Figure 2A: Compound-induced change in cutting efficiency of all tested compounds. Mean per drug & concentration vs. p-value from t-test.*

**Conclusion: Yes, some drugs do alter cutting efficiency significantly. Changes go in both directions, at lower concentration the efficiency is mostly increased (at higher concentrations the decrease might be due to toxicity)**

---

## B: Cutting efficiency change per target group
Are there any target groups that are prone to changes in cutting efficiency?
```{r warning = FALSE}
# B: Cutting efficiency change per target group, all concentrations together
ggplot_custom(indel.data %>%
                filter(sample == "drug") %>%
                distinct(eff_zscore_pooled_global_comb, drug, conc_char, target) %>%
                mutate(mean_eff_target = ave(eff_zscore_pooled_global_comb, target, conc_char, FUN = mean)), 
              aes(y = eff_zscore_pooled_global_comb, x = reorder(target, -mean_eff_target, FUN = median))) + 
    geom_boxplot(position = position_dodge(0.75), alpha = 0.4, outlier.shape = NA) +
  geom_quasirandom(aes(color = ifelse(Mod(eff_zscore_pooled_global_comb) > 1.645, "red", "black"))) +
  theme_classic_lines_90() +
  facet_wrap(~conc_char)
```

*Figure 2B: Compound-induced change in cutting efficiency per compound target groups.*

**Conclusion: Yes, specifically HDACs seem to increase cutting efficiency. Some other interesting observations can also be made from this plot.**

---

## C: Cutting efficiency change per target group
Are there any target groups that are prone to changes in cutting efficiency?
```{r warning = FALSE}
# C: Bar plot
eff.data <- indel.data %>%
  filter(sample == "drug", conc_char == "100 nM") %>%
  distinct(eff_zscore_pooled_global_comb, drug, target)

eff.data$sign <- "Yes"
eff.data$sign[Mod(eff.data$eff_zscore_pooled_global_comb) < 1.645] <- "No"

eff.data <- eff.data %>%
  mutate(number = ave(target, target, sign, FUN = length)) %>%
  mutate(number = as.numeric(number)) %>%
  distinct(target, sign, number) %>%
  spread(sign, number, fill = 0) %>%
  mutate(fraction = Yes / (No + Yes)) %>%
  pivot_longer(Yes:No, names_to = "sign", values_to = "number")

ggplot_custom(eff.data ,
              aes(y = reorder(target, fraction), x = number, fill = sign)) +
  geom_bar(stat = "identity")
```

*Figure 2C: Number of compounds with significant changes in cutting efficiency per target group.*

**Conclusion: Same as B)**

---

## D: Efficiency heatmap
Are the effects on cutting efficiency global or local? Can we plot all interesting effects in one heatmap per concentration?
```{r warning = FALSE}
# Set annotation for heatmap
# Row annotation: annotate drugs with the target group
target <- indel.data %>% 
  filter(!target %in% c("Negative Control", "MRN", "DNA-PK")) %>% 
  distinct(drug, target) %>% 
  column_to_rownames(var="drug")

file_list = list.files("/DATA/projects/DSBrepair/data/R/rs20210813_episcreen_2", full.names = TRUE)
file_list
episcreen_ratios = readRDS(file_list[[3]])

chromatin <- readRDS(
  "/DATA/usr/x.vergara/XV_ChIPIndels/XV20200902_DDR_RS_revision/XV20200902_DDR_RS_revision/data/xv20200915_DDR_data_CHIP.rds") %>% 
  distinct(barcode, chromatin) %>%
  left_join(distinct(episcreen_ratios, barcode, IPR)) %>%
  filter(IPR != "<NA>") %>% 
  select(-barcode) %>%
  column_to_rownames(var="IPR")

# Change colors of annotations
chrom_colors = c("Euchromatin" = "#264653",
                  "other-heterochromatin" = "#e9c46a",  
                     "H3K27me3" = "#e76f51", 
                  "Triple Heterochromatin" = "#f4a261")

# colors <- brewer.pal(length(unique(barcode.annotation$cluster)), "Pastel2")
# names(colors) <- unique(barcode.annotation$cluster)

annotation_colors_scr = list(
  chromatin = chrom_colors,
  type = c(Active="#669966", Repressive="grey90"),
  target = c(HDAC="#60988D", HAT="#C6D0A8", Sirtuin="#8FCAAC",
             HMT="#FDCDAC", DNMT="#D69C81", `Histone Demethylase`="#FFF2AE",
             HIF="#E3DCD5", JAK="#C8D7E2", PIM="#9AB8C4", `Aurora Kinase`="#F4CAE4",
             PARP="#CB546F", `Epigenetic Reader Domain`= "#476D61", `DNA-PK`="#E07A43"
             ))



# Order the annotation legend
ordered_marks <- c("Euchromatin", 
                     "other-heterochromatin",  
                     "H3K27me3", 
                     "Triple Heterochromatin")

annotation_colors_scr$chromatin <- annotation_colors_scr$chromatin[ordered_marks]

ordered_marks2 <- c("DNA-PK","Epigenetic Reader Domain", "HDAC",  "Sirtuin", "HAT", 
                    "Histone Demethylase", "HMT", "DNMT", 
                    "HIF", "JAK", "PIM",
                    "Aurora Kinase", "PARP")
annotation_colors_scr$target <- annotation_colors_scr$target[ordered_marks2]


# Generate heatmap: select top 15 drugs (highest change at any IPR) per concentration
eff.data.heatmap <- indel.data %>%
  filter(target != "Aurora Kinase") %>%
  filter(sample == "drug" | drug == "DMSO") %>%
  distinct(conc_char,drug, IPR, eff_zscore_pooled_comb)


eff.data.heatmap2 <- eff.data.heatmap %>%
  mutate(mod = Mod(eff_zscore_pooled_comb)) %>%
  mutate(max = ave(mod, drug, conc_char, FUN = max)) %>%
  filter(max > 2.9) %>%
  dplyr::select(-mod, -max) %>%
  spread(IPR, eff_zscore_pooled_comb)

breaks <- seq(-5, 5, 0.1)



for (i in unique(eff.data.heatmap2$conc_char)) {
  pheatmap(as.matrix(eff.data.heatmap2[eff.data.heatmap2$conc_char == i,] %>%
                       column_to_rownames('drug') %>%
                       dplyr::select(contains('IPR')) %>%
                       t()),
           border_color = "white",
           cellwidth = 12,
           cellheight = 12,
           breaks = breaks,
           cluster_rows = F,
           main = paste('efficiency change, concentration =', i),
           annotation_col = target,
           annotation_row = chromatin,
           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
           annotation_colors = annotation_colors_scr, annotation_legend = T)
}
```

*Figure 2D: Heatmap of cutting efficiency change induced by HDAC inhibitors at 19 genomic locations.*

**Conclusion: Many different HDAC inhibitors can change cutting efficiency locally. As expected, heterochromatin is more prone to an increase in cutting efficiency.**



## SA: Correlation of cutting efficiency between replicates of significant hits
We know that the cutting efficiency does not correlate well if all data is taken. However, because of the high noise level and the low effect size of the efficiency changes, it makes more sense to only investigate whether significant hits are robust throughout all replicates. 
```{r warning = FALSE}
# SA: Correlation between technical replicates efficiency: only significant hits
# significant_hits_efficiency <- eff.data %>%
#   filter(pval_adj < 0.05) %>%
#   distinct(drug, conc_char, IPR) %>%
#   mutate(drug_conc = paste(drug, conc_char, IPR, paste = "_"))

techn_repl <- indel.data %>%
  mutate(drug_conc = paste(drug, conc_char, IPR, paste = "_")) %>%
  #filter(drug_conc %in% significant_hits_efficiency$drug_conc) %>%
  dplyr::distinct(freqCut_norm, drug, tech, replicate, conc_char, sample, IPR) %>%
  mutate(freqCut_norm = log2(ave(freqCut_norm, drug, tech, replicate, conc_char, IPR, FUN = mean))) %>%
  unique() %>%
  mutate(rep = paste(replicate, tech, sep = "_")) %>%
  dplyr::select(-replicate, -tech) %>%
  mutate(max = ave(freqCut_norm, drug, conc_char, IPR, FUN = max),
         min = ave(freqCut_norm, drug, conc_char, IPR, FUN = min)) %>%
  distinct() %>%
  spread(rep, freqCut_norm) %>%
  na.omit() 
  
techn_repl$large_effect <- "1_no"
techn_repl$large_effect[techn_repl$max > 0.3 | techn_repl$min < -0.3] <- "0_yes"

ggpairs(techn_repl %>% 
       #filter(conc_char == "1 µM") %>% #1 µM
       # filter(drug %in% c("Vorinostat (SAHA, MK0683)", "Scriptaid",   "Decitabine" , "(+)-JQ1" ,  "PCI-24781 (Abexinostat)")) %>%
          dplyr::select(contains("E1")),
       mapping = aes(color = techn_repl$large_effect),
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data, mapping = mapping, alpha = 0.5, size = 0.2) +
                   geom_abline(slope = 1, lty = "dashed", col = "red")}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red")})) +
  # xlim(.4, .7) + 
  xlab("Cutting efficiency") +
  ylab("Cutting efficiency") +
  scale_color_manual(values = colors_diverse)
```

*Figure S2A: Correlation between cutting efficiency of significant hits.*

**Conclusion: The correlation between 'strong' changers of efficiency is OK, not very good, but OK.**



# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

