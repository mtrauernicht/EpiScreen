---
title: "DSB Episcreen data analysis & plotting"
author:
- name: Max Trauernicht
  email: m.trauernicht@nki.nl
  affiliation: Netherlands Cancer Institute
date: "`r format(Sys.time(), "%d/%m/%Y")`"

output:
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '4'
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site IPRs was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(ggpubr)
library(tidyr)
library(Laurae)
library(tibble)
library(pheatmap)
library(RColorBrewer)
library(ggrastr)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
boundaries <- c(0.7,0.75,0.8,0.85)
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(techn_repl %>% filter(large_effect == "0_yes") %>% dplyr::select(contains("E1")), mapping$x)
  y   <- eval_data_col(techn_repl %>% filter(large_effect == "0_yes") %>% dplyr::select(contains("E1")), mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

theme_classic_lines <- function() {
  theme_pubr(border = T, legend = "top") +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "white", color = "white")
            )
}
theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "white", color = "white")
            )
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 90) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "white", color = "white")
            )
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#9AC1AE", "#5D987B", "#f2cc8f", "#e76f51")
colors_drugs <- c("#FA8D62", "#65BFA4", "#8CA0C4", "#808184", "#F6D289", "#E5E5E5", "#ACACAC", "#737373")
#colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
# Import data from preprocessing script
#indel.data <- readRDS("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/mt20220125_episcreen.RDS")
indel.data <- readRDS("/DATA/projects/DSBrepair/data/R/rs20220127_episcreen/initials20220127_episcreen_ratios.RDS")
```

---

## A: Cutting efficiency change per drug
Are there any drugs (per concentration) that significantly change the cutting efficiency significantly across all IPRs?
```{r warning = FALSE}
# A: Cutting efficiency per drug - beeswarm plot
ggplot(indel.data %>%
                filter(sample == "drug") %>%
                distinct(freqCut_norm_global_mean, drug, conc_char, mean_eff_zscore_global_comb) %>%
                mutate(freqCut_norm_global_mean = ave(freqCut_norm_global_mean, drug, conc_char, FUN = mean)) %>%
                distinct() %>%
                mutate(mean_eff_pval_global_comb = 2*pnorm(q = abs(mean_eff_zscore_global_comb), lower.tail = F)) %>%
                mutate(mean_eff_pval_adj_global_comb = p.adjust(mean_eff_pval_global_comb, method = 'fdr')),
              aes(y = -log10(mean_eff_pval_adj_global_comb), x = log2(freqCut_norm_global_mean), 
                  color = ifelse(mean_eff_pval_adj_global_comb < 0.05 & freqCut_norm_global_mean > 1.025, "green", 
                               ifelse(mean_eff_pval_adj_global_comb < 0.05 & freqCut_norm_global_mean < 0.975, "yellow","blue")))) +
  geom_point() +
  geom_hline(linetype = "dashed", yintercept = -log10(0.05)) +
  geom_vline(linetype = "dashed", xintercept = log2(1.025)) +
  geom_vline(linetype = "dashed", xintercept = log2(0.975)) +
  ggtitle("first z-score per tech. rep., then mean of z-scores") +
  scale_color_manual(values = c("#C2C2C2", "#3d405b", "#e07a5f")) +
  facet_wrap(~conc_char, scales = "free") +
  annotate("rect",xmin=log2(1.025),xmax=log2(0.975),ymin=-Inf,ymax=Inf, alpha=0.1, fill="black") +
  annotate("rect",xmin=-Inf,xmax=Inf,ymin=-Inf,ymax=-log10(0.05), alpha=0.1, fill="black")
```

*Figure 2A: Compound-induced change in cutting efficiency of all tested compounds. Mean per drug & concentration vs. p-value from t-test.*

**Conclusion: Yes, some drugs do alter cutting efficiency significantly. Changes go in both directions, at lower concentration the efficiency is mostly increased (at higher concentrations the decrease might be due to toxicity)**


---

## B: Cutting efficiency change per target group
Are there any target groups that are prone to changes in cutting efficiency?
```{r warning = FALSE}
# C: Bar plot
eff.data <- indel.data %>%
  filter(sample == "drug") %>%
  distinct(mean_eff_zscore_global_comb, drug, target, conc_char, freqCut_norm_global_mean) %>%
  mutate(freqCut_norm_global_mean = ave(freqCut_norm_global_mean, drug, conc_char, FUN = mean)) %>%
  distinct() %>%
  mutate(mean_eff_pval_global_comb = 2*pnorm(q = abs(mean_eff_zscore_global_comb), lower.tail = F)) %>%
  mutate(mean_eff_pval_adj_global_comb = p.adjust(mean_eff_pval_global_comb, method = 'fdr'))

eff.data$sign <- "2_No"
eff.data$sign[eff.data$freqCut_norm_global_mean > 1.025 & eff.data$mean_eff_pval_adj_global_comb < 0.05] <- "1_Up"
eff.data$sign[eff.data$freqCut_norm_global_mean < 0.975 & eff.data$mean_eff_pval_adj_global_comb < 0.05] <- "0_Down"

eff.data <- eff.data %>%
  mutate(number = ave(target, target, sign, conc_char, FUN = length)) %>%
  mutate(number = as.numeric(number)) %>%
  distinct(conc_char, target, sign, number) %>%
  spread(sign, number, fill = 0) %>%
  mutate(fraction = (`1_Up` + `0_Down`) / (`2_No` + (`1_Up` + `0_Down`))) %>%
  pivot_longer(`0_Down`:`2_No`, names_to = "sign", values_to = "number")

ggplot_custom(eff.data,
              aes(y = reorder(target, -number), x = number, fill = sign, color = "black")) +
  geom_bar(stat = "identity") +
  facet_wrap(~conc_char)+
  scale_fill_manual(values = c("#e07a5f", "#3d405b", "#C2C2C2"))
```

*Figure 2B: Number of compounds with significant changes in cutting efficiency per target group.*

**Conclusion: Many HDACis have increased indel rates, especially at lower concentrations already. AURK and ERD inhibitors decrease efficiency at higher concentrations.**

---

## C: Efficiency heatmap
Are the effects on cutting efficiency global or local? Can we plot all interesting effects in one heatmap per concentration?
```{r warning = FALSE}
# Set annotation for heatmap
# Row annotation: annotate drugs with the target group
target <- indel.data %>% 
  filter(!target %in% c("Negative Control", "MRN", "DNA-PK")) %>% 
  distinct(drug, target) %>% 
  column_to_rownames(var="drug")

chromatin <- readRDS(
  "/DATA/usr/x.vergara/XV_ChIPIndels/XV20200902_DDR_RS_revision/XV20200902_DDR_RS_revision/data/xv20200915_DDR_data_CHIP.rds") %>% 
  distinct(barcode, chromatin) %>%
  left_join(distinct(indel.data, barcode, IPR)) 
# chromatin$IPR[is.na(chromatin$IPR)] <- "IPR1"
chromatin <- chromatin %>%
  filter(IPR != "<NA>") %>% 
  select(-barcode) %>%
  column_to_rownames(var="IPR")

# Change colors of annotations
chrom_colors = c("Euchromatin" = "#EAEEE8",
                  "other-heterochromatin" = "#CAD6C2",  
                     "H3K27me3" = "#a5a58d", 
                  "Triple Heterochromatin" = "#6b705c")

# colors <- brewer.pal(length(unique(barcode.annotation$cluster)), "Pastel2")
# names(colors) <- unique(barcode.annotation$cluster)

annotation_colors_scr = list(
  chromatin = chrom_colors,
  target = c(HDAC="#60988D", HAT="#C6D0A8", Sirtuin="#8FCAAC",
             HMT="#FDCDAC", DNMT="#D69C81", `Histone Demethylase`="#FFF2AE",
             HIF="#E3DCD5", JAK="#C8D7E2", PIM="#9AB8C4", `Aurora Kinase`="#F4CAE4",
             PARP="#CB546F", `Epigenetic Reader Domain`= "#476D61", `DNA-PK`="#E07A43"
             ))



# Order the annotation legend
ordered_marks <- c("Euchromatin", 
                     "other-heterochromatin",  
                     "H3K27me3", 
                     "Triple Heterochromatin")

annotation_colors_scr$chromatin <- annotation_colors_scr$chromatin[ordered_marks]


# Generate heatmap: select top drugs (highest change at any IPR) per concentration
eff.data.heatmap <- indel.data %>%
  #filter(target != "Aurora Kinase") %>%
  filter(sample == "drug") %>%
  #filter(Mod(mean_eff_zscore_comb) >= 2.58) %>%  # we can choose to display all drugs that have significant global hits
  distinct(conc_char, drug, target, IPR, mean_eff_zscore_comb, freqCut_norm_mean) %>%
  mutate(freqCut_norm_mean = log2(ave(freqCut_norm_mean, drug, conc_char, IPR, FUN = mean))) %>%
  distinct()

## Select drugs that have a large effect size in at least one location (some drugs might have a small global effect size, but large local)
eff.data.heatmap <- eff.data.heatmap %>%
  mutate(mean_eff_zscore_comb = 2*pnorm(q = abs(mean_eff_zscore_comb), lower.tail = F)) %>%
  mutate(mean_eff_zscore_comb = p.adjust(mean_eff_zscore_comb, method = 'fdr')) %>%
  mutate(min = ave(mean_eff_zscore_comb, drug, conc_char, FUN = min)) %>%
  filter(min < 0.01)

#eff.data.heatmap2$freqCut_norm_mean[eff.data.heatmap2$mean_eff_zscore_comb > 0.05] <- NA
eff.data.heatmap2 <- eff.data.heatmap %>%
  dplyr::select(-min, -mean_eff_zscore_comb) %>%
  spread(IPR, freqCut_norm_mean)

chromatin_ord <- chromatin %>% 
  rownames_to_column('IPR') %>%
  mutate(chromatin = gsub("Euc", "0_Euc", chromatin)) %>%
  mutate(chromatin = gsub("other-heterochromatin", "1_other-heterochromatin", chromatin)) %>%
  mutate(chromatin = gsub("H3K27me3", "2_H3K27me3", chromatin)) %>%
  mutate(chromatin = gsub("Triple Heterochromatin", "3_Triple Heterochromatin", chromatin)) %>%
  arrange(chromatin)

eff.data.heatmap2 <- eff.data.heatmap2[,c("drug","conc_char", "target", chromatin_ord$IPR)]

breaks <- quantile(unlist(eff.data.heatmap2 %>% dplyr::select(contains('IPR'))), c(.01,.99), na.rm = T) # change these numbers according to where you want to set the cutoff
palette_length <- 100

myBreaks <- c(seq(breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
              seq(breaks[2]/palette_length, breaks[2], length.out=floor(palette_length/2)))

ordered_marks2 <- eff.data.heatmap2 %>% 
  dplyr::select(target) %>%
  distinct() %>%
  arrange(target)

ordered_marks2 <- ordered_marks2$target

annotation_colors_scr$target <- annotation_colors_scr$target[ordered_marks2]

for (i in unique(eff.data.heatmap2$conc_char)) {
  pheatmap(eff.data.heatmap2[eff.data.heatmap2$conc_char == i,] %>%
                       arrange(target) %>%
                       column_to_rownames('drug') %>%
                       dplyr::select(contains('IPR')) %>%
                       t(),
           border_color = F,
           cellwidth = 8,
           cellheight = 8,
           breaks = myBreaks,
           cluster_rows = T,
           cluster_cols = T,
           na_col = "white",
           main = paste('efficiency change, concentration =', i),
           annotation_col = target,
           annotation_row = chromatin,
           color = colorRampPalette(c("#e07a5f", "#e5e5e5", "#3d405b"))(palette_length),
           annotation_colors = annotation_colors_scr, 
           annotation_legend = T)
}
```


## Are the changes in indel rate correlated with the starting indel rates?

```{r warning = FALSE}
## Correlation with DMSO
dmso_freq <- indel.data %>%
  filter(drug == "DMSO") %>%
  distinct(IPR, freqCut) %>%
  mutate(freqCut = ave(freqCut, IPR, FUN = mean)) %>%
  dplyr::select('dmso_eff' = freqCut, IPR) %>%
  distinct()

corr_dmso <- merge(eff.data.heatmap, dmso_freq) %>%
  mutate(drug_conc = paste(drug, conc_char, sep = "_"))# %>%
  #filter(conc_char == "100 nM")

viab_drugs <- indel.data %>%
  mutate(drug_conc = paste(drug, conc_char, sep = "_")) %>%
  filter(drug_conc %in% corr_dmso$drug_conc) %>%
  distinct(viab_mean, drug_conc) %>%
  mutate(viab_mean = ave(viab_mean, drug_conc, FUN = mean)) %>%
  distinct()

corr_dmso <- merge(corr_dmso, viab_drugs)

h3k27me3 <- indel.data %>%
  distinct(IPR, H3K27me3.zscore, late_replicating.zscore)

corr_dmso <- merge(corr_dmso, h3k27me3)

for (i in unique(corr_dmso$drug_conc)) {
  corr_dmso$corr[corr_dmso$drug_conc == i] <- cor(corr_dmso$dmso_eff[corr_dmso$drug_conc == i],
                                                  corr_dmso$freqCut_norm_mean[corr_dmso$drug_conc == i])
}

for (i in unique(corr_dmso$drug_conc)) {
  corr_dmso$corr_h3k27me3[corr_dmso$drug_conc == i] <- cor(corr_dmso$H3K27me3.zscore[corr_dmso$drug_conc == i],
                                                  corr_dmso$freqCut_norm_mean[corr_dmso$drug_conc == i])
}

for (i in unique(corr_dmso$drug_conc)) {
  corr_dmso$corr_repli[corr_dmso$drug_conc == i] <- cor(corr_dmso$late_replicating.zscore[corr_dmso$drug_conc == i],
                                                  corr_dmso$freqCut_norm_mean[corr_dmso$drug_conc == i])
}

target1 <- target %>%
  rownames_to_column("drug")
target2 <- expand.grid("conc_char" = unique(corr_dmso$conc_char), "drug" =target1$drug)
target1 <- merge(target1, target2) %>%
  mutate(drug_conc = paste(drug, conc_char, sep = "_")) %>%
  distinct(drug_conc, target) %>%
  column_to_rownames("drug_conc")

pheatmap(corr_dmso %>%
           #filter(target == "HDAC") %>%
           distinct(drug_conc, corr, corr_h3k27me3, corr_repli, viab_mean) %>%
           mutate(viab_mean = viab_mean - 0.4) %>%
           column_to_rownames("drug_conc") %>%
           t(),
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         annotation_col = target1)

pheatmap(corr_dmso %>%
#           filter(target == "HDAC") %>%
           distinct(drug_conc, corr, corr_h3k27me3) %>%
           mutate(corr = abs(corr),
                  corr_h3k27me3 = abs(corr_h3k27me3)) %>%
           column_to_rownames("drug_conc") %>%
           t(),
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         annotation_col = target1)
  



ggplot(corr_dmso %>%
         filter(target == "HDAC"),
       aes(x = corr, y = corr_h3k27me3)) +
  geom_point()
s

ggplot(corr_dmso %>% filter(drug_conc == "AZ 960_10 µM"),
              aes(x = freqCut_norm_mean, y = late_replicating.zscore)) +
  geom_point() +
  geom_abline(lty = "twodash") +
  geom_smooth(method = "lm", color = "red", lty = "dashed") +
  stat_cor(method = "pearson")



ggplot(corr_dmso,
              aes(x = dmso_eff, y = freqCut_norm_mean, color = target)) +
  geom_point() +
  facet_wrap(~drug_conc) +
  geom_abline(lty = "twodash") +
  geom_smooth(method = "lm", color = "red", lty = "dashed") +
  stat_cor(method = "pearson") +
  scale_color_brewer(palette = "Set3")

ggplot(corr_dmso %>% filter(drug_conc == "AZ 960_10 µM"),
              aes(x = dmso_eff, y = freqCut_norm_mean)) +
  geom_point() +
  geom_abline(lty = "twodash") +
  geom_smooth(method = "lm", color = "red", lty = "dashed") +
  stat_cor(method = "pearson") 

ggplot(corr_dmso,
       aes(x = corr, y = viab_mean)) +
  geom_point()

ggplot(corr_dmso %>%
         distinct(target, drug, corr),
              aes(x = target, y = corr)) +
  geom_quasirandom() +
  theme_classic_lines_90()


```

*Figure 2C: Heatmap of cutting efficiency change induced by HDAC inhibitors at 19 genomic locations.*

**Conclusion: Many different HDAC inhibitors can change cutting efficiency locally. As expected, heterochromatin is more prone to an increase in cutting efficiency.**



## SA: Correlation of cutting efficiency between replicates of significant hits
We know that the cutting efficiency does not correlate well if all data is taken. However, because of the high noise level and the low effect size of the efficiency changes, it makes more sense to only investigate whether significant hits are robust throughout all replicates. 
```{r warning = FALSE}
# SA: Correlation between technical replicates efficiency: only significant hits
# significant_hits_efficiency <- eff.data %>%
#   filter(pval_adj < 0.05) %>%
#   distinct(drug, conc_char, IPR) %>%
#   mutate(drug_conc = paste(drug, conc_char, IPR, paste = "_"))

# techn_repl <- indel.data %>%
#   mutate(drug_conc = paste(drug, conc_char, IPR, paste = "_")) %>%
#   #filter(drug_conc %in% significant_hits_efficiency$drug_conc) %>%
#   dplyr::distinct(freqCut_norm, drug, tech, replicate, conc_char, sample, IPR) %>%
#   mutate(freqCut_norm = log2(ave(freqCut_norm, drug, tech, replicate, conc_char, IPR, FUN = mean))) %>%
#   unique() %>%
#   mutate(rep = paste(replicate, tech, sep = "_")) %>%
#   dplyr::select(-replicate, -tech) %>%
#   mutate(max = ave(freqCut_norm, drug, conc_char, IPR, FUN = max),
#          min = ave(freqCut_norm, drug, conc_char, IPR, FUN = min)) %>%
#   distinct() %>%
#   spread(rep, freqCut_norm) %>%
#   na.omit() 
#   
# techn_repl$large_effect <- "1_no"
# techn_repl$large_effect[techn_repl$max > 0.3 | techn_repl$min < -0.3] <- "0_yes"
# 
# ggpairs(techn_repl %>% 
#        #filter(conc_char == "1 µM") %>% #1 µM
#        # filter(drug %in% c("Vorinostat (SAHA, MK0683)", "Scriptaid",   "Decitabine" , "(+)-JQ1" ,  "PCI-24781 (Abexinostat)")) %>%
#           dplyr::select(contains("E1")),
#        mapping = aes(color = techn_repl$large_effect),
#                upper = list(continuous = corColor),
#                lower = list(continuous = function(data, mapping, ...) {
#                    ggally_points(data = data, mapping = mapping, alpha = 0.5, size = 0.2) +
#                    geom_abline(slope = 1, lty = "dashed", col = "red")}),
#                diag = list(continuous = function(data, mapping, ...) {
#                    ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red")})) +
#   # xlim(.4, .7) + 
#   xlab("Cutting efficiency") +
#   ylab("Cutting efficiency") +
#   scale_color_manual(values = colors_diverse)
```

*Figure S2A: Correlation between cutting efficiency of significant hits.*

**Conclusion: The correlation between 'strong' changers of efficiency is OK, not very good, but OK.**



# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

