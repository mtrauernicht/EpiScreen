---
title: "Indel data & viability preprocessing"
author: "Max Trauernicht & Ruben Schep"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---
knitr document van Steensel lab

# Preprocessing of the indel data
# Introduction

In this script I want to prepocess the raw data from the epigenetic screening into one dataframe containing all information: +1/-7 ratio, efficiency, etc. This should all be integrated with the drug and the drug target group corresponding to the well. 
This will be used for plotting indel patterns, calculating ratios later on and such.

* Efficiency (All mutations / Total or (Total - WT sequences) / Total)  
* +1 / -7  


## Description of Data

For this analysis we need the mapping and the indel data of the TRIP integrations. These 
files are obtained with the crispr_trip.snake script that C. Leemans edited. This data 
contains the genomic locations of the TRIP integrations (hg38) and the indel frequencies 
at each integration.

The mutations were called by counting the distance between two constant regions. These
were separated by barcode. The barcodes were also filtered on the starcode, to pick out
the most abundant, and considered real, ones.

Mutations files : *genuine_mapped.table

| barcode  | type | score | 
| ------- | --------- | ----- | 
| TTCTATTCGCACACAA | ins | 1 |
| TTTCCCACATCAGGAG | wt | 0 |
| CCATAGTAGTGATTAC | del | -4 |

# Data importing and processing
## Path, Libraries, Parameters and Useful Functions
```{r setup, message=FALSE, warnings=FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 

# libraries:
# library(devtools)
# install_github("lawremi/rtracklayer")
library(tidyverse)
library(data.table)
library(ggplot2)
library(car)
library(parallel)
library(gtools)
library(rtracklayer)
library(platetools)
library(plyr)
library(ggpubr)
```
## Custom functions
Functions used include all functions that have been used previously by Ruben (some of them might not be needed anymore, but are kept anyway). Functions 'CallTrueBarcodes' & 'RemoveLowReads' have been added by Max.
```{r functions}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, substr(gsub("-","",Sys.time()),1,8), filename)
  filename
}

CallTrueBarcodes <- function(df) {
  df %<>% filter(barcode %in% barcodes.list)
  df
}

RemoveLowReads <- function(reads) {
  if (sum(reads$count) < 2000) {
    reads <- NULL
  } else {
    reads 
  } 
}

Read_Counts <- function(x) {
  #This function sums all the reads per barcode
  tmp <- x %>% group_by(barcode) %>% summarise(sum = sum(count))
  tmp$barcode <- as.character(tmp$barcode)
  colnames(tmp) <- c("barcode", "sum")
  tmp
}


MutationsToDataframe <- function(mutations) {
  # This function does
  tmp <- dcast(mutations, formula = barcode ~ indel, value.var = "count", fun = sum)
  tmp
}

RownamesList <- function(list) {
  rownames(list) <- list$"V2"
  list
}
  # n <- colnames(tmp)
  # names(tmp) <- n

IndelsOnly <- function(x) {
  #This function removes the "not_clear and "point_mut" from the indels.
  tmp <- x[!x$call %in% c("not_clear", "wt_point_mut"), ]
  tmp
}

Not_Clear_Counts <- function(x){
  tmp <- x[x$V3 == "not_clear", ]
  tmp <- tmp[, c("V2", "V1")]
  colnames(tmp) <- c("barcode", "not_clear")
  tmp
}

Point_Mut_Counts <- function(x){
  tmp <- x[x$V3 == "wt_point_mut", ]
  tmp <- tmp[, c("V2", "V1")]
  colnames(tmp) <- c("barcode", "point_mut")
  tmp
}

RenameBarcodes <- function(list, pool) {
# This function renames the barcodes in the samples to barcode.pool to remove ambuguity between the cell pools
    for (i in pool) {
    list[[i]]$V2 <- paste(list[[i]]$V2, deparse(substitute(pool)), sep = ".")
  }
  list
}

NAToZero <- function(DT) {
  # This function changes NA to 0 in a data.table by name :
  for (j in names(DT))
    set(DT,which(is.na(DT[[j]])),j,0)
  return(DT)
  }

RemoveBarcodeFromList_RN <- function(x, barcode) {
  tmp <- x[!rownames(x)==barcode, ]
  tmp
}

RemoveBarcodeFromList_barcode <- function(x, barcode) {
  tmp <- x[!x$barcode==barcode, ]
  tmp
}

CalculateRatio <- function(mutations, indel) {
  # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel) %in% names(mutations)) {
    indel_reads <- mutations[,as.character(indel)]
    indel_reads <- as.matrix(indel_reads)
    rownames(indel_reads) <- rownames(mutations)
    
    ratio=ifelse(((indel_reads==0) | mutations[, "0"]==0), NA, 
                 as.numeric(mutations[,as.character(indel)]/(rowSums(mutations)-mutations[, "0"])))
                 
    ratio=round(ratio,3)
    
    df <- data.frame(barcode = as.character(row.names(mutations)),
             ratio = ratio,
             stringsAsFactors = FALSE)
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel)))
    df
  } else {
    df <- data.frame(barcode = as.character(row.names(mutations)),
             ratio = NA, 
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel)))
    df
  }
}

CalculatePercentage <- function(mutations, indel) {
  # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel) %in% names(mutations)) {
    indel_reads <- mutations[,as.character(indel)]
    indel_reads <- as.matrix(indel_reads)
    rownames(indel_reads) <- rownames(mutations)
    
    percentage=ifelse((indel_reads==0), 0, 
                 as.numeric(mutations[,as.character(indel)]/(rowSums(mutations))*100))
                 
    percentage=round(percentage,3)
    
    df <- data.frame(barcode = as.character(row.names(mutations)),
             percentage = percentage,
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("percentage.", as.character(indel)))
    df
  } else {
    df <- data.frame(barcode = as.character(row.names(mutations)),
             ratio = NA,
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("percentage.", as.character(indel)))
    df
  }
}


CalculateRatio_internal <- function(mutations, indel1, indel2){
   # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel1) %in% names(mutations) & as.character(indel2) %in% names(mutations)) {
    indel1_reads <- mutations[,as.character(indel1)]
    indel1_reads <- as.matrix(indel1_reads)
    rownames(indel1_reads) <- rownames(mutations)
    
    indel2_reads <- mutations[,as.character(indel2)]
    indel2_reads <- as.matrix(indel2_reads)
    rownames(indel2_reads)=rownames(mutations)
    
    ratio=ifelse(((indel1_reads==0 & indel2_reads==0) | indel2_reads==0), NA, 
                 as.numeric(mutations[,as.character(indel1)]/mutations[,as.character(indel2)]))
                 
    ratio=round(ratio,3)
    
    df <- data.frame(barcode = row.names(mutations),
             ratio = ratio,
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel1), "_", as.character(indel2)))
    df
  } else {
    df <- data.frame(barcode = row.names(mutations),
             ratio = NA, 
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel1), "_", as.character(indel2)))
    df
  }
}

CalculateEfficiencies <- function(efficiencies) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(efficiencies),
             efficiency = (1 - efficiencies/ rowSums(efficiencies)) * 100)
}

CalculateInsertions <- function(insertions) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(insertions),
             insertions = (rowSums(insertions[, -grep('^[-0]',colnames(insertions))]) / rowSums(insertions)) * 100)
}

CalculateDeletions <- function(deletions) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(deletions),
             deletions = (rowSums(deletions[ ,grep('-',colnames(deletions))]) / rowSums(deletions)) * 100)
}
```

## Data import
Data import from mapping, files were generated on 21.01.2019.
```{r import}
# Import files in list and make individual tables
# I use this if all the samples are good. Here however I do not use all the samples.
file.list <- list.files("/DATA/projects/DSBrepair/data/rs20210628_EpiScreen/indelPCR_counts/",
                        pattern="_.*[.]count", full.names=T)

# import the data
df.list <- mclapply(file.list, 
                    read.table, 
                    mc.cores = 20, 
                    header = TRUE, 
                    stringsAsFactors = FALSE, 
                    col.names = c("barcode", "type", 
                                  "mutation", "count"))
# rename the lists
names(df.list) <- gsub(".*?/(.*?)[.]cou.*", "\\1", file.list)
# names(df.list) <- gsub("split", "-", names(df.list))


# names(df.list) <- file.list
# these are the samples
head(names(df.list))
# count the sample number
n.samples <- length(df.list)

# Load the indel statistics with the metadata generated in the parsing script.
indel.statistics.dt = as.data.table(readRDS("/DATA/projects/DSBrepair/git/EpiScreen/files_scripts/rs20210626_Episcreen_Reads_Viab_Metadata.RDS"))

setnames(indel.statistics.dt, "ID", "exp")

# Import RSTP2 clone 5 barcode list (in total 19 barcodes) - "CTCTTAATCGCTGCC" (20)
barcodes.list <- c("AGGGCGTAAAATATTT", "TATGGCTGTCGGGTAG", "TGTCCCTTAGTACTTT", 
                   "AGAAAATAATATGACG","CGGCCTGAAGGTCAGG","TTGAACGCGGGCTCGG",
                   "GCTAACATCACGAATC", "GCGCACCCTTTAATTG","ACTGTCGAGTTGTCCG",
                   "CCGGGGACGTATGCAC","TCTTTTGAGGAGCTGA","ATATCGTTGCTGGAGA",
                   "CATCCACCACACTTCA","ACCCCTAAAGGCGCTG","ATACTATATTTAACGG",
                   "CATTTCTGATCAATAA","GAGCGCGTCACCGGGT",
                   "GTACCTCTCGATAGTG","TGGCCAATATTTGTCT")
```


```{r indel data table list}
# Call true barcodes
df.list <- mclapply(df.list, CallTrueBarcodes, mc.cores = 10)

# To be able to setup the functions in a general way. This means in cases where we have A
# and B samples.
mut.list = mclapply(names(df.list), function(exp){
  dt = data.table(df.list[[exp]])
  dt[, mutation := as.character(mutation)]
  # dt = dtLet's keep this for later
  dt_exp = data.table(exp = exp,
                         dt)
  return(dt_exp)
}, mc.cores = 10)
```


### not clear and point mutatins
Check how many reads are in general not clear or called as point mutations. 

```{r indeldataframe}
mutations.dt = do.call(rbind, c(mut.list, fill = T))
dim(mutations.dt) 
# Remove NA counts
mutations.dt = mutations.dt[!is.na(count)]
dim(mutations.dt)

## Not clear reads:
notclear = mutations.dt %>% filter(type == "not_clear") %>% pull(count) %>% sum()
all = mutations.dt %>%  pull(count) %>% sum()
notclear / all * 100

# remove the inf from the datatable
mutations.dt = mutations.dt[type != "not_clear"]
dim(mutations.dt)
# Point mutations: 
pointmut = mutations.dt %>% filter(type == "wt_point_mut") %>% pull(count) %>% sum()
pointmut / all * 100

# remove the point mutations from the datatable
mutations.dt = mutations.dt[type != "wt_point_mut"]
dim(mutations.dt)

## For the time being, let's also remove the +1 and -1 WT. 
# until I understand what Christ means with it
mutations.dt = mutations.dt[!(type == "wt" & mutation != 0)]
dim(mutations.dt)
# same for ssODN
mutations.dt = mutations.dt[type != "ssODN"]
dim(mutations.dt)

setnames(mutations.dt, "type", "mut_type")
```

0.27% of all the reads are not clear and 1.8% of all the reads are point mutations in the guide sequence.

```{r merging technical replicates and calculating frequencies}
# First measure the ratio before doing the sum of the technical replicates: 
mutations.dt[, norm_split := count/sum(count), by=exp,]
mutations.dt[, c("freq_split", "sum_bc_tech_reads") := list(norm_split/sum(norm_split, na.rm = TRUE), sum(count)), 
             by = c("barcode","exp")]

mutations.dt[!mutation%in%c(0,NA), 
             ratio_indels_split := norm_split/sum(norm_split, na.rm = TRUE), 
             by=c("barcode","exp")]

mutations.dt = mutations.dt[sum_bc_tech_reads > 100]

# Add an ID column that removes the technical replicates information 
mutations.dt[, ID := gsub("^(E1504|E177)_[0-9][0-9]_(1|10|100)_[123]_([12]_...$)", 
                                   "\\1_\\2_\\3", 
                                   exp, 
                                   perl = TRUE)]
# Merge the indel statistics
mutations.dt = merge(mutations.dt, indel.statistics.dt)
# Filter the low viability reads
mutations.dt = mutations.dt[viab_norm > 0.5]

# Calculate the data now from the summed values. 
mutations.dt[, c("pooled_counts", "count_rep", "viab_norm_pooled") := list(sum(count), sum(norm_split), mean(viab_norm)), by = c("ID", "barcode", "mutation")]

cols = c("barcode", "ID", "mutation", "count_rep", "pooled_counts")
mutations.pool.dt = mutations.dt[, ..cols]
mutations.pool.dt = unique(mutations.pool.dt)

mutations.pool.dt[, norm_pooled := count_rep/sum(count_rep), by = ID]

mutations.pool.dt[, c("freq_pooled", "sum_pooled_bc_reads") := 
               list(norm_pooled/sum(norm_pooled, na.rm = TRUE), sum(pooled_counts)), 
             by = c("barcode","ID")]

mutations.pool.dt[!mutation%in%c(0,NA), 
             ratio_indels_pooled := norm_pooled/sum(norm_pooled, na.rm = TRUE), 
             by=c("barcode","ID")]

# Merge the data
screen.indel.dt = merge(mutations.dt, mutations.pool.dt, by = c("barcode", "ID", "mutation", "count_rep", "pooled_counts"))
```


```{r}
# c("barcode", "ID", "mutation", "count_rep", "pooled_counts", "exp",  "type", "count",  "norm_split", "freq_split", "sum_bc_tech_reads", "ratio_indels_split", "reads", "replicate",  "plate", "concentration", "tech", "drug_plate", "well", "seq_barcode", "seq_index", "file", "PCR_type",  "index_length", "drug_no",  "drug_well", "drug", "target",  "r_written_pct", "viability", "viab_norm", "conc_char", "viab_norm_pooled", "norm_pooled", "freq_pooled", "sum_pooled_bc_reads", "ratio_indels_pooled")

# Fix large deletions for every deletion above 25
largedels <- as.character(seq(-130, -15))
columnstokeep <- names(screen.indel.dt)[!names(screen.indel.dt) %in% c("mutation", "mut_type",  "count_rep", "pooled_counts", "count",  "norm_split", "freq_split", "sum_bc_tech_reads", "ratio_indels_split", "reads",  "norm_pooled", "freq_pooled", "sum_pooled_bc_reads", "ratio_indels_pooled")]

# "viability", "viab_norm", "viab_norm_pooled", "r_written_pct",

mutations.large.del.dt = screen.indel.dt[mutation %in% largedels, ]
mutations.large.del.dt = mutations.large.del.dt[, lapply(.SD, sum, na.rm=TRUE), by=c(columnstokeep),
                                                .SDcols=c("count_rep", "pooled_counts", "count",  "norm_split", "freq_split", "sum_bc_tech_reads", "ratio_indels_split", "reads",  "norm_pooled", "freq_pooled", "sum_pooled_bc_reads", "ratio_indels_pooled")]
mutations.large.del.dt[, c("mutation", "mut_type", "type") := list("<-14", "del", "grouped_indel")]


# Fix large insertions for every insertions above 3
largeins <- as.character(seq(3, 20))
mutations.large.ins.dt = screen.indel.dt[mutation %in% largeins, ]
mutations.large.ins.dt = mutations.large.ins.dt[, lapply(.SD, sum, na.rm=TRUE), by=c(columnstokeep),
                                                .SDcols=c("count_rep", "pooled_counts", "count",  "norm_split", "freq_split", "sum_bc_tech_reads", "ratio_indels_split", "reads",  "norm_pooled", "freq_pooled", "sum_pooled_bc_reads", "ratio_indels_pooled")]
mutations.large.ins.dt[, c("mutation", "mut_type", "type") := list(">2", "ins", "grouped_indel")]

mutations.large.del.dt
mutations.large.ins.dt

large.indels.dt = rbind(mutations.large.del.dt, mutations.large.ins.dt)

######## UNTIL HERE 20210730 RUBEN #######

large.indels.dt[mutation %in% c(">2", "<-14"), color := "other"]

setcolorder(large.indels.dt,c("exp", "exp_pool", "barcode", "nexp", "no", "exp_ID",
                              "replicate", "cell_line", "pool", "plasmid", "time", "drug",
                              "ssODN", "siRNA", "GCF","seq_barcode","seq_index", 
                              "sum_reads", "sum_bc_reads",
                              "cells", "mutation", "count", "norm",
                              "sd_norm", "ratio_indels", "sd_ratio_indels", "freq", "sd_freq"))
all.mutations.sep.dt = copy(all.mutations.dt)
dim(all.mutations.sep.dt)
all.mutations.trunc.dt = rbind(all.mutations.sep.dt, large.indels.dt) %>% filter(count != 0)
all.mutations.trunc.dt = all.mutations.trunc.dt[!mutation %in% largedels, ]
all.mutations.trunc.dt = all.mutations.trunc.dt[!mutation %in% largeins, ]
dim(all.mutations.trunc.dt)


muts <- unique(all.mutations.dt$mutation)
min_indel <- min(as.numeric(muts[-grep("ssODN|<|>", muts)]))
max_indel <- max(as.numeric(muts[-grep("ssODN|<|>", muts)]))
indels.odn <- c(as.character(seq(min_indel, max_indel)), "ssODN")

muts <- unique(all.mutations.trunc.dt$mutation)
min_indel <- min(as.numeric(muts[-grep("ssODN|<|>", muts)]))
max_indel <- max(as.numeric(muts[-grep("ssODN|<|>", muts)]))
indels.trunc.odn <- c("<-14", as.character(seq(min_indel, max_indel)), ">2", "ssODN")

# head(trip_tib_mut_2000)
all.mutations.trunc.dt$mutation <- factor(all.mutations.trunc.dt$mutation, levels=indels.trunc.odn)
all.mutations.dt$mutation <- factor(all.mutations.dt$mutation, levels=indels.odn)


all.mutations.dt[, color := "other"]
all.mutations.dt[mutation == 0, color := "wt"]
all.mutations.dt[mutation == 1, color := "NHEJ"]
all.mutations.dt[mutation == -7, color := "MMEJ"]
all.mutations.dt[mutation == "ssODN", color := "SSTR"]
```



# Add identifiers and compute indel ratios
```{r calculate_ratios}
# Calculate NHEJ/MMEJ ratios and efficiences

### WIP #####
ratios_split_tib <- screen.indel.dt %>%
  as_tibble() %>%
  dplyr::distinct(exp, barcode, mutation, ratio_indels_split) %>% 
  pivot_wider(names_from = mutation, 
              values_from = ratio_indels_split, 
              values_fill = 0) %>%
  mutate(freqMMEJ_split = `-7` / 1,
         freqNHEJ_split = `1` / 1,
         NHEJMMEJratio_split = freqMMEJ_split / freqNHEJ_split,
         MMEJscore_split = freqMMEJ_split / (freqMMEJ_split + freqNHEJ_split),
         NHEJscore_split = freqNHEJ_split / (freqNHEJ_split + freqMMEJ_split)) %>%
  distinct(exp, barcode, freqMMEJ_split, freqNHEJ_split, NHEJMMEJratio_split, MMEJscore_split, NHEJscore_split)

ratios_pooled_tib <- screen.indel.dt %>%
  as_tibble() %>%
  dplyr::distinct(exp, barcode, mutation, ratio_indels_pooled) %>% 
  pivot_wider(names_from = mutation, 
              values_from = ratio_indels_pooled, 
              values_fill = 0) %>%
  mutate(freqMMEJ = `-7` / 1,
         freqNHEJ = `1` / 1,
         NHEJMMEJratio = freqMMEJ / freqNHEJ,
         MMEJscore = freqMMEJ / (freqMMEJ + freqNHEJ),
         NHEJscore = freqNHEJ / (freqNHEJ + freqMMEJ)) %>%
  distinct(exp, barcode, freqMMEJ, freqNHEJ, NHEJMMEJratio, MMEJscore, NHEJscore)

freqs_ratios_tib <- screen.indel.dt %>%
  as_tibble() %>%
  filter(mutation == "0") %>%
  dplyr::distinct(exp, barcode, mutation, freq_split, freq_pooled) %>% 
  mutate(freqCut_split = 1 - freq_split,
         freqCut = 1 - freq_pooled) %>%
  distinct(exp, barcode, freqCut_split, freqCut) %>% 
  left_join(ratios_split_tib) %>%
  left_join(ratios_pooled_tib)

screen.indel.dt = merge(screen.indel.dt, freqs_ratios_tib, by = c("exp", "barcode"))

screen_indel_tib = screen.indel.dt %>% as_tibble() %>% # make tibble
  # Add sample type, drug, or one of the controls for plotting.
  mutate(sample = ifelse(drug == "DMSO", "DMSO", ifelse(
    drug == "DNA-PKi", "DNA-PKi", ifelse(
      drug == "Mirin", "Mirin", "drug"))))
```


```{r calculating z-scores}
# First check if the DMSO data is normally distributed. For both split and pooled and MMEJscore and freqCut
# Pooled
for (i in barcodes.list) {
norm_pooled = screen_indel_tib %>%
  filter(drug == "DMSO", barcode == i) %>%
  distinct(ID, barcode, freqCut, MMEJscore, replicate)
plt1 = qplot(sample = freqCut, data = norm_pooled, color=replicate) +
  theme_bw() +
  ggtitle(paste0("pooled freqCut Barcode: ", i))
plt2 = qplot(sample = MMEJscore, data = norm_pooled, color=replicate) +
  theme_bw() +
  ggtitle(paste0("pooled MMEJscore Barcode: ", i))
grid.arrange(plt1, plt2)
}

for (i in barcodes.list) {
norm_pooled = screen_indel_tib %>%
  filter(drug == "DMSO", barcode == i) %>%
  distinct(exp, barcode, freqCut_split, MMEJscore_split, replicate)
plt1 = qplot(sample = freqCut_split, data = norm_pooled, color=replicate) +
  theme_bw() +
  ggtitle(paste0("split freqCut Barcode: ", i))
plt2 = qplot(sample = MMEJscore_split, data = norm_pooled, color=replicate) +
  theme_bw() +
  ggtitle(paste0("split MMEJscore Barcode: ", i))
grid.arrange(plt1, plt2)
}
```


```{r loading and adding the chromatin data}


```


## Processed data export
The files will be saved in the processed data folder.
```{r export}
setwd("/DATA/projects/DSBrepair/data/R/EpiScreen/")
# The mutations list that can be loaded for the indel spectra plots.
filename <- SetFileName("_drug_screen_mutations_rep2", "rs")
save(indels_tib, file = filename)
```

### Conclusions 
Looks all fine! Now, we can generate indel plots and look in detail at the ratios.

### Session Info
```{r session_info}
sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))

```

