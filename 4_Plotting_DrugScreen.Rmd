---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  pdf_document:
    toc: yes
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

```


## Data import
```{r data import}
setwd("~/mydata/EpiScreen/epigenetic-screening-on-trip-clone/Data/")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20190125RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,47,54,55,119:124,127)]

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```

## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
indel.data <- merge(mean.ratio.data, indel.data)

setnames(indel.data, old = ".id", new = "condition")
setnames(indel.data, old = "rn", new = "barcode")

# Remove weird barcode?
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG",]

# We want to exclude reads from cells that have reduced viability (set cut-off at 50% reduced viability)
indel.data <- indel.data[indel.data$viability > 50000,]

# Also, we want to exclude remaining barcodes with very low reads
indel.data <- indel.data[indel.data$read.count1.7 > 30,]


# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]


# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"
```


# Analysis

## Data analysis
```{r data analysis}
# Perform statistical test to remove not significant hits
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Compute relative viability
indel.data$viability <- ave(indel.data$viability, FUN = function(x) x/max(x))

# Calculate mean values per group
# Mean ratio per barcode
indel.data$mean.ratio.new <- ave(indel.data$ratio, indel.data$barcode, FUN = function(x) mean(x))
# Mean ratio per target group
indel.data$mean.ratio.target <- ave(indel.data$ratio, indel.data$Target, FUN = function(x) mean(x))
# Mean efficiency per target group
indel.data$mean.eff.n <- ave(indel.data$efficiency, indel.data$Target, FUN = function(x) mean(x))
# Mean viability per target group
indel.data$mean.viability <- ave(indel.data$viability, indel.data$Target, FUN = function(x) mean(x))


# Plate normalization: substract log(DMSO.mean) for each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- mean(indel.data$logratio[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  print(dmso.mean)
  indel.data$logratio.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$logratio[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.mean
  print(indel.data$logratio)
  }
}


# t-test
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$condition)
indel.data$classifier.bc <- do.call(paste, c(indel.data[c("classifier", "barcode")], sep = "_")) 


for (i in unique(indel.data$barcode)) {
  
    for (j in unique(indel.data$classifier)) {
    x <- indel.data[indel.data$Drug == "DMSO" & indel.data$barcode == i,]
    y <- indel.data[indel.data$classifier == j & indel.data$barcode == i,]
    
  if (nrow(y)>1) {
    
    indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$p.value
    
    indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$statistic
  
    indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[1]
  
    indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[2]
    
  }
    else {
      indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$p.value
      
      indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$statistic
      
      indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[1]
      
      indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[2]
      
      indel.data$conf.int <- abs(indel.data$conf.int2 - indel.data$conf.int1)
    }
}
}

# Adjust p-values for multiple testing
indel.data$p.value.adjust <- p.adjust(indel.data$p.value, n = 
                                            length(indel.data$p.value))

# t outlier df
t.outlier.df <- indel.data[abs(indel.data$statistic) > 5,]

# Calculate the mean of the three replicates
indel.data$logratio.mean <- ave(indel.data$logratio.platenorm, indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))
indel.data$efficiency.mean <- ave(indel.data$efficiency, indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))
# indel.data2 <- indel.data[!duplicated(indel.data$logratio.mean),]

# Calculate the chi square scores
indel.data$chisq <- ave(indel.data$logratio.platenorm, indel.data$barcode, 
                      FUN=function(x) scores(x, type = "chisq"))

# Create an outlier dataframe
chi.outlier.df <- indel.data[indel.data$chisq > 3.841,] 
chi.outlier.df <- chi.outlier.df[-grep("DNA-PK", chi.outlier.df$Target),]



```

## Visualization
```{r visualization}
# Density plots t-distribution, only Mirin & DNA-PKi
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=5),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-5),linetype="dashed", size=1)

# Density plots t-distribution
ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)


# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("amount outliers") + xlab("target group")

# Total amount of drugs per target group in outlier df
ggplot(t.outlier.df, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("amount outliers") + xlab("target group")

# Total amount of drugs per target group in outlier df, no DNA-PKi
ggplot(t.outlier.df[t.outlier.df$Drug != "DNA-PKi",], aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("amount outliers") + xlab("target group")











# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = logratio.mean, 
                         colour = ifelse(abs(statistic) > 4,
                                         "outlier","non-outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode") + labs(title = "Outlier plot", colour = "Outlier based on t-statistic value > 4") + scale_color_manual(values=c("#999999", "#E69F00"))

# ggplot specifying group of drugs
ggplot(data = indel.data) +
  geom_quasirandom(mapping = aes(x = barcode, y = logratio.mean, colour = Target)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode") 

# ggplot specifying the drug ratio
ggplot(data = indel.data, aes(x = barcode, y = logratio.mean, colour = conc)) +
  geom_quasirandom() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode")


# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.mean, colour = Target)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode") + labs(fill="titel")
  print(p)
}


# Make chr.states

indel.data$chr.state <- "intermediate"
indel.data[grep("CATCCACCACACTTCA|CATTTCTGATCAATAA|ACTGTCGAGTTGTCCG|GTACCTCTCGATAGTG|TCTTTTGAGGAGCTGA|TGGCCAATATTTGTCT", indel.data$barcode),]$chr.state <- "closed"
indel.data[grep("AGAAAATAATATGACG|AGGGCGTAAAATATTT|ATACTATATTTAACGG|GCTAACATCACGAATC", indel.data$barcode),]$chr.state <- "open"



for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == sort.list(c(i,"Negative control")), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = logratio.comb, y = efficiency, colour = Target, size = chr.state)) +
    ylab("cutting efficiency") + xlab("log2(+1/-7 ratio)") + labs(fill="titel")
  print(p)
}


# Same as before, colour indicates number of reads
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio, shape = Target, colour = read.count1.7)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode") + labs(fill="titel")
  print(p)
}

# Boxplot of efficiencies 
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) 


# Correlation efficiency vs +1/-7 ratio
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=logratio, y=efficiency, colour = Target))

# Correlation mean efficiency vs mean ratio
ggplot(data = indel.data, aes(x=mean.ratio.target, y=mean.eff.n)) +
    geom_point() + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation plot viability vs. efficiency
ggplot(data = indel.data, aes(x=viability, y=efficiency)) +
  geom_point() + geom_smooth(method = lm)

# Correlation plot mean viability vs. mean efficiency
ggplot(data = indel.data, aes(x=mean.viability, y=mean.eff)) +
  geom_point() + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation plot mean viability vs. mean ratio
ggplot(data = indel.data, aes(x=mean.viability, y=mean.ratio.target)) +
  geom_point() + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation viability vs. +1/-7 ratio
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=viability, y=logratio, colour = Target))

# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
ggplot(data = indel.data[indel.data$Target == "Negative control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.new))) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) + scale_x_continuous(breaks=c(2, 4, 6, 8))

# Correlation IC50 vs viability
ggplot(data = indel.data, aes(x=viability, y=IC50..µM., colour = conc)) +
  geom_point()

correlation.plot <- indel.data[,c(24,25,26)]
pairs(correlation.plot)

# Correlation rep1 vs rep2
ggplot(data = indel.data, aes(x=logratio, y=rep2_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep1 vs rep3
ggplot(data = indel.data, aes(x=logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep2 vs rep3 per group
ggplot(data = indel.data, aes(x=rep2_logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation matrix plot
correlation.plot.rep <- indel.data[,c(22,28,29)]
pairs(correlation.plot.rep)

# Correlation plot plate 1uM_plate1
correlation.plot.weird.plate <- indel.data[grep("1um_.*_plate1",indel.data$condition),]
correlation.plot.weird.plate <- correlation.plot.weird.plate[,c(22,28,29)]
pairs(correlation.plot.weird.plate)

# Correlation reads vs. viability
ggplot(data = indel.data) +
  geom_point(mapping = aes(x=read.count, y=viability, colour = plate.nr))

# Outlier plot
ggplot(data = outlier.df) + 
  geom_point(mapping = aes(x = barcode, y = logratio, colour = Target)) + 
  geom_step(data = indel.data, mapping = aes(x = barcode, y = logratio)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))
```
We can see that there is a very high correlation between all 3 replicates, even when you look at the plates which have shifted amounts of reads (some wells have very low amount of reads and others have very high amounts of reads), meaning that we can use the data of all 3 replicates.
# Results
```{r}

```

# Conclusions
```{r}
```

## Exporting potential data. 
```{r export}
setwd("/DATA/usr/m.trauernicht/EpiScreen/epigenetic-screening-on-trip-clone/Data/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)

filename <- SetFileName("_indel.data2", "mt")
save(indel.data2, file = filename)

filename <- SetFileName("_outlier.df", "mt")
save(outlier.df, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

