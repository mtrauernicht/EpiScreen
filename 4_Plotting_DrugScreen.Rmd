---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  pdf_document:
    toc: yes
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

```


## Data import
```{r data import}
setwd("~/mydata/EpiScreen/epigenetic-screening-on-trip-clone/Data/")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20190125RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,47,54,55,119:124,127)]

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```

## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
indel.data <- merge(mean.ratio.data, indel.data)
all.indel.data <- merge(mean.ratio.data, indel.data)


setnames(indel.data, old = ".id", new = "condition")
setnames(indel.data, old = "rn", new = "barcode")

# Remove weird barcode?
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG",]

# We want to exclude reads from cells that have reduced viability (set cut-off at 50% reduced viability)
indel.data <- indel.data[indel.data$viability > 50000,]

# Also, we want to exclude remaining barcodes with very low reads
indel.data <- indel.data[indel.data$read.count1.7 > 30,]


# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]


# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"

## Compute some useful entities for data analysis
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Compute relative viability
indel.data$viability <- ave(indel.data$viability, FUN = function(x) x/max(x))

# Divide barcodes over 3 chromatin states based on cutting efficiency
indel.data$chr.state <- "intermediate"
indel.data$mean.efficiency.bc <- ave(indel.data$efficiency, indel.data$barcode, FUN = function (x) mean(x))
indel.data$chr.state[indel.data$mean.efficiency.bc > 0.6] <- "open"
indel.data$chr.state[indel.data$mean.efficiency.bc < 0.4] <- "closed"

```


# Analysis

## Data analysis
```{r data analysis}
## Normalize the data
# Plate normalization: substract log(DMSO.mean) for each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- mean(indel.data$logratio[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$logratio.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$logratio[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.mean
  }
}

# Plate normalization for efficiency
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.eff.mean <- mean(indel.data$efficiency[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$efficiency.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <-
    indel.data$efficiency[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.eff.mean
  }
}


## Perform t-test
# Create classifier, needed for subsequent t-test analysis
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$condition)

# Run t-test within each well for each barcode
for (i in unique(indel.data$barcode)) {
  
    for (j in unique(indel.data$classifier)) {
    x <- indel.data[indel.data$Drug == "DMSO" & indel.data$barcode == i,]
    y <- indel.data[indel.data$classifier == j & indel.data$barcode == i,]
    
  if (nrow(y)>1) {
    
    indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$p.value
    
    indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$statistic
  
    indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[1]
  
    indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[2]
    
  }
    else {
      indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$p.value
      
      indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$statistic
      
      indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[1]
      
      indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[2]
      
      indel.data$conf.int <- abs(indel.data$conf.int2 - indel.data$conf.int1)
    }
}
}

# Adjust p-values for multiple testing
indel.data$p.value.adjust <- p.adjust(indel.data$p.value, n = 
                                            length(indel.data$p.value))

# Create outlier df based on t-statistic
t.outlier.df <- indel.data[abs(indel.data$statistic) > 4,]

# Calculate the mean of the three replicates
indel.data$logratio.mean <- 
  ave(indel.data$logratio.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))

indel.data$efficiency.mean <- 
  ave(indel.data$efficiency.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))
# indel.data2 <- indel.data[!duplicated(indel.data$logratio.mean),]

# Calculate the chi square scores
indel.data$chisq <- ave(indel.data$logratio.platenorm, indel.data$barcode, 
                      FUN=function(x) scores(x, type = "chisq"))

# Create an outlier dataframe
chi.outlier.df <- indel.data[indel.data$chisq > 3.841,] 
chi.outlier.df <- chi.outlier.df[-grep("DNA-PK", chi.outlier.df$Target),]



```

## Visualization: checking quality of data
```{r visualization quality data}
## Make some density plots to get a feeling for the data
# Density plot logratio of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = logratio.platenorm, fill = Target)) + geom_density() + xlab("logratio") + labs(title = "logratio density of the controls")

# Density plot logratio 
ggplot(data = indel.data, aes(x = logratio.platenorm, fill = Target)) + geom_density() + xlab("logratio")+ labs(title = "logratio density of all targets")

# Integral of logratio density plot per target group
ggplot(data = indel.data, 
       aes(x = logratio.platenorm)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = Target))+ labs(title = "accumulative logratio of all targets")

# Integral of logratio density plot per barcode group
ggplot(data = indel.data, 
       aes(x = logratio)) +
    xlab("logratio") + ylab("accumulative value") + stat_ecdf(aes(colour = chr.state))+ labs(title = "accumulative logratio of all targets")

# Density plot logratio per target
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ Target, nrow = 4)

# Density plot logratio per barcode
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ barcode, nrow = 6, scales = "free")

# Density plot logratio in the three chromatin states
ggplot(data = indel.data, 
       aes(x = logratio, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ chr.state, nrow = 3)

# Density plot efficiency
ggplot(data = indel.data, aes(x = efficiency, fill = Target)) + geom_density() +
xlab("efficiency")

# Density plot efficiency per target
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_grid(rows = vars(Target))

# Density plot efficiency per barcode
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_wrap(~ Target, nrow = 4)

# Integral of density plot
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = Target))

# Density plot normalized efficiency of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density() +
  xlab("efficiency: normalized over plate")

# Density plots t-distribution, only Mirin & DNA-PKi
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic")

# Density plots t-distribution
ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic")

# Density plot t-statistic + facet_wrap
 ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
+     geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic") + facet_wrap(~Target, nrow = 4, scales = "free")

# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("amount outliers") + xlab("target group")

# Total amount of drugs per target group in outlier df
ggplot(t.outlier.df, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("amount outliers") + xlab("target group")

# Relative amount of drugs in outlier df
ggplot(NULL,aes(x = reorder(Target,Target,function(x)-length(x)))) + 
      geom_bar(aes(fill="amount non-outliers"), data = indel.data, alpha = 0.5)+
  geom_bar(aes(fill="amount outlier"), data = t.outlier.df, alpha = 0.5)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("count") + xlab("target group") + labs(title = "outlier vs. non-outlier distribution per drug category", fill = "groups")


# Density plot of reads.count using only PAO data -> these are the input reads
ggplot(data = all.indel.data[all.indel.data$Drug == c("PAO","DMSO"),], aes(x = read.count, fill = Drug, group = Drug)) + geom_density() + facet_wrap(~rn, nrow = 6)

# Density plot per target group, comparing effect on opposite chromatin states
ggplot(data = indel.data[indel.data$chr.state == c("open","closed"),], aes(x = statistic, fill = chr.state)) + 
  geom_density(alpha = 0.5) + xlab("t-statistic") +
  labs(title = "t-statistic density for each target, comparing chr. states") +
  facet_wrap(~Target, nrow = 4, scales = "free")+
  geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) +
  geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)

```




## Visualizaton: 
```{r visualization}
# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = logratio.mean, 
                         colour = ifelse(abs(statistic) < 4,
                                         "non-outlier","outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode") + labs(title = "Outlier plot", colour = "Outlier based on t-statistic value > 4") + scale_color_manual(values=c("#999999", "#E69F00"))

# Boxplot of efficiencies 
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) 

# Boxplot of efficiencies normalized
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency.platenorm)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) 

# Beeswarm plot of efficiencies
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = efficiency.mean, 
                         colour = ifelse(abs(statistic) < 4,
                                         "non-outlier","outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("efficiency") + xlab("barcode") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on t-statistic value > 4") + scale_color_manual(values=c("#999999", "#E69F00"))

# ggplot specifying group of drugs
ggplot(data = indel.data) +
  geom_quasirandom(mapping = aes(x = barcode, y = logratio.mean, colour = Target)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode") 

# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.mean, colour = Target)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode") + labs(fill="titel")
  print(p)
}

# Same for efficiency
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = logratio.platenorm, y = efficiency.platenorm, colour = Target, size = chr.state)) +
    ylab("cutting efficiency") + xlab("log2(+1/-7 ratio)") + labs(fill="titel")
  print(p)
}
```


## Visualization: correlation plots
```{r}
# Correlation mean efficiency vs mean ratio
indel.data$mean.logratio.target = 
  ave(indel.data$logratio.platenorm, indel.data$Target, FUN = function(x) mean(x))
indel.data$mean.efficiency.target = 
  ave(indel.data$efficiency.platenorm, indel.data$Target, FUN = function(x) mean(x))
ggplot(data = indel.data[indel.data$Drug != "DNA-PKi",], aes(x=mean.logratio.target, y=mean.efficiency.target)) +
    geom_point(mapping = aes(colour = Target)) + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,vjust=10,parse=TRUE)+
  labs(title="Correlation efficiency vs. logratio")

# Correlation plot mean viability vs. mean efficiency
indel.data$mean.viability.target = 
  ave(indel.data$viability, indel.data$Target, FUN = function(x) mean(x))
ggplot(data = indel.data, aes(x=mean.viability.target, y=mean.efficiency.target)) +
  geom_point(mapping = aes(colour = Target)) + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation plot mean viability vs. mean ratio
ggplot(data = indel.data, aes(x=mean.viability.target, y=mean.logratio.target)) +
  geom_point() + geom_smooth(method = lm) + 
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
indel.data$mean.ratio.bc <- ave(indel.data$ratio, indel.data$barcode, FUN = function(x) mean(x))
ggplot(data = indel.data[indel.data$Target == "Negative control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.bc))) +
  geom_point() + geom_smooth(method = lm) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  scale_x_continuous(breaks=c(2, 4, 6, 8))+ xlab("logratio previous experiments") +
  ylab("logratio this experiment") + labs(title = "correlation of predicted and actual logratio per barcode")

# Correlation plots of the replicates
indel.data.rep1 <- indel.data[grep("rep1", indel.data$condition),]
indel.data.rep1 <- indel.data.rep1[,c(1,23)]
indel.data.rep2 <- indel.data[grep("rep2", indel.data$condition),]
indel.data.rep2 <- indel.data.rep2[,c(1,23)]
indel.data.rep3 <- indel.data[grep("rep3", indel.data$condition),]
indel.data.rep3 <- indel.data.rep3[,c(1,23)]
setnames(indel.data.rep1, old = "logratio.platenorm", new = "rep1")
setnames(indel.data.rep2, old = "logratio.platenorm", new = "rep2")
setnames(indel.data.rep3, old = "logratio.platenorm", new = "rep3")
indel.data.rep <- merge(indel.data.rep1, indel.data.rep2)


ggplot(data = indel.data, aes(x=logratio, y=rep2_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep1 vs rep3
ggplot(data = indel.data, aes(x=logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep2 vs rep3 per group
ggplot(data = indel.data, aes(x=rep2_logratio, y=rep3_logratio)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation matrix plot
correlation.plot.rep <- indel.data[,c(22,28,29)]
pairs(correlation.plot.rep)

# Correlation plot plate 1uM_plate1
correlation.plot.weird.plate <- indel.data[grep("1um_.*_plate1",indel.data$condition),]
correlation.plot.weird.plate <- correlation.plot.weird.plate[,c(22,28,29)]
pairs(correlation.plot.weird.plate)
```
We can see that there is a very high correlation between all 3 replicates, even when you look at the plates which have shifted amounts of reads (some wells have very low amount of reads and others have very high amounts of reads), meaning that we can use the data of all 3 replicates.
# Results
```{r}

```

# Conclusions
```{r}
```

## Exporting potential data. 
```{r export}
setwd("/DATA/usr/m.trauernicht/EpiScreen/epigenetic-screening-on-trip-clone/Data/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)

filename <- SetFileName("_chi.outlier.df", "mt")
save(chi.outlier.df, file = filename)

filename <- SetFileName("_t.outlier.df", "mt")
save(t.outlier.df, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

