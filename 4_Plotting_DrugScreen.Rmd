---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

```


## Data import
```{r data import}
setwd("/DATA/usr/m.trauernicht/EpiScreen/epigenetic-screening-on-trip-clone/Data")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20190305_RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,48,55,56,120:125,128)]

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```

## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
setnames(indel.data, old = "V2", new = "rn")
indel.data <- merge(mean.ratio.data, indel.data, all = T)
all.indel.data <- indel.data


setnames(indel.data, old = ".id", new = "condition")
setnames(indel.data, old = "rn", new = "barcode")

# Remove weird barcode?
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG" &
                           indel.data$barcode != "CTCTTAATCGCTGCC",]

# We want to exclude reads from cells that have reduced viability (set cut-off at 50% reduced viability)
indel.data <- indel.data[indel.data$viability > 45000,]

# Also, we want to exclude remaining barcodes with very low reads
indel.data <- indel.data[indel.data$read.count1.7 > 30,]


# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]


# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"

## Compute some useful entities for data analysis
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Compute relative viability
indel.data$viability <- ave(indel.data$viability, FUN = function(x) x/max(x))

# Divide barcodes over 3 chromatin states based on cutting efficiency
indel.data$chr.state <- "intermediate"
indel.data$mean.efficiency.bc <- ave(indel.data$efficiency, indel.data$barcode, FUN = function (x) mean(x))
indel.data$chr.state[indel.data$mean.efficiency.bc > 0.6] <- "open"
indel.data$chr.state[indel.data$mean.efficiency.bc < 0.4] <- "closed"

```


# Analysis

## Data analysis
```{r data analysis}
## Normalize the data
# Plate normalization: substract log(DMSO.mean) for each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- mean(indel.data$logratio[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$logratio.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$logratio[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.mean
  }
}

# Plate normalization for efficiency
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.eff.mean <- mean(indel.data$efficiency[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$efficiency.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <-
    indel.data$efficiency[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.eff.mean
  }
}


## Perform t-test
# Create classifier, needed for subsequent t-test analysis
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$condition)

# Run t-test within each well for each barcode
for (i in unique(indel.data$barcode)) {
  
    for (j in unique(indel.data$classifier)) {
    x <- indel.data[indel.data$Drug == "DMSO" & indel.data$barcode == i,]
    y <- indel.data[indel.data$classifier == j & indel.data$barcode == i,]
    
  if (nrow(y)>1) {
    
    indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$p.value
    
    indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$statistic
  
    indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[1]
  
    indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[2]
    
  }
    else {
      indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$p.value
      
      indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$statistic
      
      indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[1]
      
      indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, mu = y$logratio.platenorm)$conf.int[2]
      
      indel.data$conf.int <- abs(indel.data$conf.int2 - indel.data$conf.int1)
    }
}
}

# Adjust p-values for multiple testing
indel.data$p.value.adjust <- p.adjust(indel.data$p.value, n = 
                                            length(indel.data$p.value))

# Create outlier df based on t-statistic
t.outlier.df <- indel.data[abs(indel.data$statistic) > 4,]

# Calculate the mean of the three replicates
indel.data$logratio.mean <- 
  ave(indel.data$logratio.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))

indel.data$efficiency.mean <- 
  ave(indel.data$efficiency.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))
# indel.data2 <- indel.data[!duplicated(indel.data$logratio.mean),]

# Calculate the chi square scores
indel.data$chisq <- ave(indel.data$logratio.platenorm, indel.data$barcode, 
                      FUN=function(x) scores(x, type = "chisq"))

# Create an outlier dataframe
chi.outlier.df <- indel.data[indel.data$chisq > 3.841,] 
chi.outlier.df <- chi.outlier.df[-grep("DNA-PK", chi.outlier.df$Target),]



```


\newpage
# Results
## Visualization: checking quality of data
```{r Quality check data, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
## Make some density plots to get a feeling for the data
# Density plot logratio of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = logratio.platenorm, fill = Target)) + geom_density() + xlab("logratio") + labs(title = "logratio density of the controls")

# Density plot logratio 
ggplot(data = indel.data, aes(x = logratio.platenorm, fill = Target)) + geom_density() + xlab("logratio")+ labs(title = "logratio density of all targets")

# Integral of logratio density plot per target group
ggplot(data = indel.data, 
       aes(x = logratio.platenorm)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = Target))+ labs(title = "accumulative logratio of all targets")

# Integral of logratio density plot per barcode group
ggplot(data = indel.data, 
       aes(x = logratio)) +
    xlab("logratio") + ylab("accumulative value") + stat_ecdf(aes(colour = chr.state))+ labs(title = "accumulative logratio of all targets")

# Density plot logratio per target
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "logratio density per target")

# Density plot logratio per barcode
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ barcode, nrow = 6, scales = "free")+ 
  labs(title = "logratio density per barcode")

# Density plot logratio in the three chromatin states
ggplot(data = indel.data, 
       aes(x = logratio, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ chr.state, nrow = 3)+ 
  labs(title = "logratio density per barcode group")

# Density plot efficiency
ggplot(data = indel.data, aes(x = efficiency, fill = Target)) + geom_density() +
xlab("efficiency")+ labs(title = "efficiency density")

# Density plot efficiency per target
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_grid(rows = vars(Target))+ 
  labs(title = "efficiency density per target group")

# Density plot efficiency per barcode
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "efficiency density per barcode")

# Integral of density plot
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = Target))+ 
  labs(title = "integral of efficiency density")

# Density plot normalized efficiency of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density() +
  xlab("efficiency: normalized over plate")+ 
  labs(title = "normalized efficiency density of controls")

# Density plots t-distribution, only Mirin & DNA-PKi
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic")+ labs(title = "t-statistic density of controls")

# Density plots t-distribution
ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic")+ labs(title = "t-statistic density")

# Density plot t-statistic + facet_wrap
 ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() + geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic") + facet_wrap(~Target, nrow = 4, scales = "free")+ labs(title = "t-statistic density per target group")

# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("datapoints") + xlab("target group")+ labs(title = "datapoints per target group")

# Relative amount of drugs in outlier df
ggplot(NULL,aes(x = reorder(Target,Target,function(x)-length(x)))) + 
      geom_bar(aes(fill="amount non-outliers"), data = indel.data, alpha = 0.5)+
  geom_bar(aes(fill="amount outlier"), data = t.outlier.df, alpha = 0.5)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("datapoints") + xlab("target group") + labs(title = "outlier vs. non-outlier distribution per drug category", fill = "groups")


# Density plot of reads.count using only PAO data -> these are the input reads
ggplot(data = all.indel.data[all.indel.data$Drug == c("PAO","DMSO"),], aes(x = read.count, fill = Drug, group = Drug)) + geom_density() + facet_wrap(~barcode, nrow = 6)+ labs(title = "read count before cutting (PAO) and after cutting (DMSO)")

# Density plot per target group, comparing effect on opposite chromatin states
ggplot(data = indel.data[indel.data$chr.state == c("open","closed"),], aes(x = statistic, fill = chr.state)) + 
  geom_density(alpha = 0.5) + xlab("t-statistic") +
  labs(title = "t-statistic density for each target, comparing chr. states") +
  facet_wrap(~Target, nrow = 4, scales = "free")+
  geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) +
  geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)

```



\newpage
## Visualization: correlation plots for quality check
```{r correlation plots, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Correlation mean efficiency vs mean ratio
indel.data$mean.logratio.drug = 
  ave(indel.data$logratio.platenorm, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$mean.efficiency.drug = 
  ave(indel.data$efficiency.platenorm, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))


for (i in unique(indel.data$conc)) {
  data <- indel.data[indel.data$conc == i,]
p <- ggplot(data = data, aes(x=mean.efficiency.drug, y=mean.logratio.drug, label = Drug, color = Target)) +
    geom_point(size = 0.001) + 
  labs(title = paste("correlation logratio vs. efficiency, concentration:",i)) +
  geom_text(aes(label = ifelse(abs(mean.logratio.drug)>0.5, as.character(Drug),'')), 
            hjust=0,vjust=0, angle = 45, size = 3, family = "symbol")
print(p)
}


  
# Correlation plot mean viability vs. mean efficiency
indel.data$mean.viability.drug = 
  ave(indel.data$viability, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))

for (i in unique(indel.data$conc)) {
  data <- indel.data[indel.data$conc == i,]
p <- ggplot(data = data, aes(x=mean.viability.drug, y=mean.efficiency.drug, label = Drug, color = Target)) +
    geom_point(size = 0.001) + 
  labs(title = paste("correlation efficiency vs. viability, concentration:",i)) +
  geom_text(aes(label = ifelse(abs(mean.efficiency.drug)>0.05, as.character(Drug),'')), 
            hjust=0,vjust=0, angle = 45, size = 3, family = "symbol")
print(p)
}


# Correlation plot mean viability vs. mean ratio
for (i in unique(indel.data$conc)) {
  data <- indel.data[indel.data$conc == i,]
p <- ggplot(data = data, aes(x=mean.viability.drug, y=mean.logratio.drug, label = Drug, color = Target)) +
    geom_point(size = 0.001) + 
  labs(title = paste("correlation logratio vs. viability, concentration:",i)) +
  geom_text(aes(label = ifelse(abs(mean.logratio.drug)>0.5, as.character(Drug),'')), 
            hjust=0,vjust=0, angle = 45, size = 3, family = "symbol")
print(p)
}


# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
indel.data$mean.ratio.bc <- ave(indel.data$ratio, indel.data$barcode, FUN = function(x) mean(x))
ggplot(data = indel.data[indel.data$Target == "Negative control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.bc))) +
  geom_point() + geom_smooth(method = lm) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  scale_x_continuous(breaks=c(2, 4, 6, 8))+ xlab("logratio previous experiments") +
  ylab("logratio this experiment") + labs(title = "correlation of predicted and actual logratio per barcode")

# Correlation plots of the replicates
indel.data.rep1 <- indel.data[grep("rep1", indel.data$condition),]
indel.data.rep1 <- indel.data.rep1[,c(1,5,14,23)]
indel.data.rep2 <- indel.data[grep("rep2", indel.data$condition),]
indel.data.rep2 <- indel.data.rep2[,c(1,5,14,23)]
indel.data.rep3 <- indel.data[grep("rep3", indel.data$condition),]
indel.data.rep3 <- indel.data.rep3[,c(1,5,14,23)]
setnames(indel.data.rep1, old = "logratio.platenorm", new = "rep1")
setnames(indel.data.rep2, old = "logratio.platenorm", new = "rep2")
setnames(indel.data.rep3, old = "logratio.platenorm", new = "rep3")
indel.data.rep <- merge(indel.data.rep1, indel.data.rep2, all = T)
indel.data.rep <- merge(indel.data.rep, indel.data.rep3, all = T)

ggplot(data = indel.data.rep, aes(x=rep1, y=rep2)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep1 vs rep3
ggplot(data = indel.data.rep, aes(x=rep1, y=rep3)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) 

# Correlation rep2 vs rep3 per group
ggplot(data = indel.data.rep, aes(x=rep2, y=rep3)) +
  geom_point() + geom_smooth(method = lm) + stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE)

# Correlation matrix plot
correlation.plot.rep <- indel.data.rep[,c(4,5,6)]
pairs(correlation.plot.rep)
```

### Conclusion correlation plots
We can see that there is a very high correlation between all 3 replicates, meaning that we can use the data of all 3 replicates.


\newpage
## Visualizaton: Spotting outliers
```{r visualization spotting outliers, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = logratio.mean, 
                         colour = ifelse(abs(statistic) < 4,
                                         "non-outlier","outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode") + 
  labs(title = "Outlier plot", colour = "Outlier based on t-statistic value > 4") + scale_color_manual(values=c("#999999", "#E69F00"))

# Boxplot of efficiencies 
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  labs(title = "Efficiency distribution per barcode") 

# Boxplot of efficiencies normalized
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency.platenorm)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  labs(title = "Efficiency distribution per barcode after normalization") 

# Beeswarm plot of efficiencies
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = efficiency.mean, 
                         colour = ifelse(abs(statistic) < 4,
                                         "non-outlier","outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("efficiency") + xlab("barcode") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on t-statistic value > 4") + scale_color_manual(values=c("#999999", "#E69F00"))


# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.platenorm, colour = Target)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode")+ labs(title= paste("logratio of",i, "compared to DMSO"))
  print(p)
}

# Visualize drug outliers per concentration
logratio.outlier <- indel.data[abs(indel.data$logratio.platenorm) > 1 | indel.data$Drug == "DMSO",]
logratio.outlier.low <- logratio.outlier[logratio.outlier$conc == "100nm",]
logratio.outlier.med <- logratio.outlier[logratio.outlier$conc == "1um",]
logratio.outlier.high <- logratio.outlier[logratio.outlier$conc == "10um",]


for (i in unique(logratio.outlier.low$Drug)) {
  data <- logratio.outlier.low[logratio.outlier.low$Drug == c(i,"DMSO"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.platenorm, colour = Drug)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode")+ labs(title= paste("logratio of",i, "compared to DMSO, 100nm"))
  print(p)
}

for (i in unique(logratio.outlier.med$Drug)) {
  data <- logratio.outlier.med[logratio.outlier.med$Drug == c(i,"DMSO"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.platenorm, colour = Drug)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode")+ labs(title= paste("logratio of",i, "compared to DMSO, 1uM"))
  print(p)
}

for (i in unique(logratio.outlier.high$Drug)) {
  data <- logratio.outlier.high[logratio.outlier.high$Drug == c(i,"DMSO"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.platenorm, colour = Drug)) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode")+ labs(title= paste("logratio of",i, "compared to DMSO, 10uM"))
  print(p)
}


# Any barcodes more frequently low/high ratios? - Generate barplot
low <- as.data.frame(table(logratio.outlier.low[-grep("DNA-PKi", logratio.outlier.low$Drug),]$barcode))
low$Freq <- ave(low$Freq, FUN = function(x) x/max(x))
med <- as.data.frame(table(logratio.outlier.med[-grep("DNA-PKi", logratio.outlier.med$Drug),]$barcode))
med$Freq <- ave(med$Freq, FUN = function(x) x/max(x))
high <- as.data.frame(table(logratio.outlier.high[-grep("DNA-PKi", logratio.outlier.high$Drug),]$barcode)) 
high$Freq <- ave(high$Freq, FUN = function(x) x/max(x))
setnames(low, old = "Freq", new = "low")
setnames(high, old = "Freq", new = "high")
setnames(med, old = "Freq", new = "med")
freq <- merge(low, med)
freq <- merge(freq, high)
freq <- melt(freq)

ggplot(freq, aes(Var1, value, fill = variable)) +
  geom_bar(stat="identity", position="dodge")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
  ylab("outlier datapoints") + xlab("barcode")+ labs(title = "relative amount of datapoints of abs(logratio-change) > 1 per barcode")

```

## Conclusion
The data looks very nice, we can already spot the first outliers. Now we need to generate more sophisticated plots and integrate chromatin data to select hits.



## Exporting potential data. 
```{r export}
setwd("/DATA/usr/m.trauernicht/EpiScreen/epigenetic-screening-on-trip-clone/Data/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)

filename <- SetFileName("_chi.outlier.df", "mt")
save(chi.outlier.df, file = filename)

filename <- SetFileName("_t.outlier.df", "mt")
save(t.outlier.df, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

