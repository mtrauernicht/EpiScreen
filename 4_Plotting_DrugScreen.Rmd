---
title: "Plotting of the epigenetic screening results"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    code_folding: show
    highlight: monochrome
    theme: journal
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  editor_options:
    chunk_output_type: console
---

# knitr document van Steensel lab

# TRIP Clone identification

# Introduction

## Description of Data
How to make a good rendering table: 
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| column1	|	column2	|	column3	|	
|----|----|----|
|1	|	2	|	3	|	
|a	|	b	|	c	|	
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

# Data processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
```

### Custom functions
Functions used thoughout this script.
```{r}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[3]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


stat_smooth_func <- function(mapping = NULL, data = NULL,
                        geom = "smooth", position = "identity",
                        ...,
                        method = "auto",
                        formula = y ~ x,
                        se = TRUE,
                        n = 80,
                        span = 0.75,
                        fullrange = FALSE,
                        level = 0.95,
                        method.args = list(),
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE,
                        xpos = NULL,
                        ypos = NULL) {
  layer(
    data = data,
    mapping = mapping,
    stat = StatSmoothFunc,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      method = method,
      formula = formula,
      se = se,
      n = n,
      fullrange = fullrange,
      level = level,
      na.rm = na.rm,
      method.args = method.args,
      span = span,
      xpos = xpos,
      ypos = ypos,
      ...
    )
  )
}

StatSmoothFunc <- ggproto("StatSmooth", Stat,
                      
                      setup_params = function(data, params) {
                        # Figure out what type of smoothing to do: loess for small datasets,
                        # gam with a cubic regression basis for large data
                        # This is based on the size of the _largest_ group.
                        if (identical(params$method, "auto")) {
                          max_group <- max(table(data$group))
                          
                          if (max_group < 1000) {
                            params$method <- "loess"
                          } else {
                            params$method <- "gam"
                            params$formula <- y ~ s(x, bs = "cs")
                          }
                        }
                        if (identical(params$method, "gam")) {
                          params$method <- mgcv::gam
                        }
                        
                        params
                      },
                      
                      compute_group = function(data, scales, method = "auto", formula = y~x,
                                               se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
                                               xseq = NULL, level = 0.95, method.args = list(),
                                               na.rm = FALSE, xpos=NULL, ypos=NULL) {
                        if (length(unique(data$x)) < 2) {
                          # Not enough data to perform fit
                          return(data.frame())
                        }
                        
                        if (is.null(data$weight)) data$weight <- 1
                        
                        if (is.null(xseq)) {
                          if (is.integer(data$x)) {
                            if (fullrange) {
                              xseq <- scales$x$dimension()
                            } else {
                              xseq <- sort(unique(data$x))
                            }
                          } else {
                            if (fullrange) {
                              range <- scales$x$dimension()
                            } else {
                              range <- range(data$x, na.rm = TRUE)
                            }
                            xseq <- seq(range[1], range[2], length.out = n)
                          }
                        }
                        # Special case span because it's the most commonly used model argument
                        if (identical(method, "loess")) {
                          method.args$span <- span
                        }
                        
                        if (is.character(method)) method <- match.fun(method)
                        
                        base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
                        model <- do.call(method, c(base.args, method.args))
                        
                        m = model
                        eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                                         list(a = format(coef(m)[1], digits = 3), 
                                              b = format(coef(m)[2], digits = 3), 
                                              r2 = format(summary(m)$r.squared, digits = 3)))
                        func_string = as.character(as.expression(eq))
                        
                        if(is.null(xpos)) xpos = min(data$x)*0.9
                        if(is.null(ypos)) ypos = max(data$y)*0.9
                        data.frame(x=xpos, y=ypos, label=func_string)
                        
                      },
                      
                      required_aes = c("x", "y")
)

```


## Data import
```{r data import}
setwd("/DATA/usr/m.trauernicht/EpiScreen/epigenetic-screening-on-trip-clone/Data")

# Import data from preprocessing script
RSTP2_2000_indels.df <- get(load("mt20190305_RSTP2_2000_indels.df"))
indel.data <- RSTP2_2000_indels.df[,c(1:6,48,55,56,120:125,128)]

# Import viability data and the mean +1/-7 ratio from previous experiments
viability.data <- read.delim("mt20190124_viabilityData")
mean.ratio.data <- read.delim("mt20190124_meanratiosperbarcode")
```

## Data pre-processing
```{r pre-processing}
# Add viability data to indel.data
indel.data <- merge(viability.data, indel.data) 
setnames(indel.data, old = "V2", new = "rn")
indel.data <- merge(mean.ratio.data, indel.data, all = T)
all.indel.data <- indel.data


setnames(indel.data, old = ".id", new = "condition")
setnames(indel.data, old = "rn", new = "barcode")

# Remove weird barcode?
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG" &
                           indel.data$barcode != "CTCTTAATCGCTGCC",]


# Also, we want to exclude remaining barcodes with very low reads
# indel.data <- indel.data[indel.data$read.count1.7 > 30,]

low.indel.count <- indel.data[indel.data$read.count1.7 < 30,]
low.indel.count <- low.indel.count[low.indel.count$X0 > 100,]
low.indel.count <- low.indel.count[!low.indel.count$Drug %in% "PAO",]

# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$ratio),]
indel.data <- indel.data[indel.data$ratio != 0,]


# Add plate specifier
indel.data$plate.nr <- "1"
indel.data[grep("10um_rep1_plate2", indel.data$condition),]$plate.nr <- "2"
indel.data[grep("10um_rep2_plate1", indel.data$condition),]$plate.nr <- "3"
indel.data[grep("10um_rep2_plate2", indel.data$condition),]$plate.nr <- "4"
indel.data[grep("10um_rep3_plate1", indel.data$condition),]$plate.nr <- "5"
indel.data[grep("10um_rep3_plate2", indel.data$condition),]$plate.nr <- "6"
indel.data[grep("1um_rep1_plate1", indel.data$condition),]$plate.nr <- "7"
indel.data[grep("1um_rep1_plate2", indel.data$condition),]$plate.nr <- "8"
indel.data[grep("1um_rep2_plate1", indel.data$condition),]$plate.nr <- "9"
indel.data[grep("1um_rep2_plate2", indel.data$condition),]$plate.nr <- "10"
indel.data[grep("1um_rep3_plate1", indel.data$condition),]$plate.nr <- "11"
indel.data[grep("1um_rep3_plate2", indel.data$condition),]$plate.nr <- "12"
indel.data[grep("100nm_rep1_plate1", indel.data$condition),]$plate.nr <- "13"
indel.data[grep("100nm_rep1_plate2", indel.data$condition),]$plate.nr <- "14"
indel.data[grep("100nm_rep2_plate1", indel.data$condition),]$plate.nr <- "15"
indel.data[grep("100nm_rep2_plate2", indel.data$condition),]$plate.nr <- "16"
indel.data[grep("100nm_rep3_plate1", indel.data$condition),]$plate.nr <- "17"
indel.data[grep("100nm_rep3_plate2", indel.data$condition),]$plate.nr <- "18"

## Compute some useful entities for data analysis
# Take log values of ratio
indel.data$logratio <- ave(indel.data$ratio, FUN = function(x) log2(x))

# Compute relative viability
indel.data$viability <- ave(indel.data$viability, FUN = function(x) x/max(x))

# We want to exclude reads from cells that have reduced viability (set cut-off at 50% reduced viability)
# indel.data <- indel.data[indel.data$viability > 0.45,]

# Exclude data completely (remove the remaining datapoint) if 2 out of 3 replicates were already excluded untill now
indel.data$classifier <- gsub("_rep[0-9]", "\\1", indel.data$condition)
indel.data$uniqueID <- paste(indel.data$barcode, indel.data$classifier)
indel.data <- indel.data[indel.data$uniqueID %in% names(which(table(indel.data$uniqueID) > 1)), ]
```


# Analysis

## Statistical framework
```{r}
## Compute SD based on total indel reads
# Transform df to matrix
logratio <- indel.data[,c(1,20)]
counts <- indel.data[,c(1,16)]
logratio <- logratio[!duplicated(logratio),]
logratio2 <- as.matrix(logratio)

 # Transform matrix to DeSeq format
counts_dds <- DESeqDataSetFromMatrix(countData = rnaseq.counts,
                                     colData = samples.df,
                                     design= ~ clone)

x <- normalizationFactors(indel.data$logratio, indel.data$read.count)


```


## Compute relative barcode counts
```{r}
# Plate normalization: substract dmso bc counts from each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- 
    mean(indel.data$read.count[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$rel.counts[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$read.count[indel.data$plate.nr == i & indel.data$barcode == j] /
    dmso.mean
  }
}


# Check which drugs alter barcode count
indel.data$mean.count <- ave(indel.data$rel.counts, indel.data$Drug, indel.data$barcode, FUN = function(x) mean(x))
indel.data.bc.count <- indel.data[indel.data$mean.count >  1.5 | indel.data$mean.count < 0.666,]

ggplot(indel.data.bc.count, aes(colour = barcode, y = mean.count, x = reorder(Drug, Drug, function(x) -length(x)))) + 
    geom_point() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12)) + 
    ylab("datapoints") + xlab("target group") + labs(title = "datapoints drugs with altered bc counts")

```



## Data analysis
```{r data analysis}
## Normalize the data
# Plate normalization: substract log(DMSO.mean) for each drug per plate
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.mean <- mean(indel.data$logratio[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$logratio.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <- 
    indel.data$logratio[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.mean
  }
}

# Plate normalization for efficiency
for (i in 1:18) {
  for (j in unique(indel.data$barcode)) {
  dmso.eff.mean <- mean(indel.data$efficiency[indel.data$Drug == 
                        "DMSO" & indel.data$plate.nr == 
                        i & indel.data$barcode == j])
  indel.data$efficiency.platenorm[indel.data$plate.nr == i & indel.data$barcode == j] <-
    indel.data$efficiency[indel.data$plate.nr == i & indel.data$barcode == j] -
    dmso.eff.mean
  }
}


## Perform t-test
# Run t-test within each well for each barcode
for (i in unique(indel.data$barcode)) {
  
    for (j in unique(indel.data$classifier)) {
    x <- indel.data[indel.data$Drug == "DMSO" & indel.data$barcode == i,]
    y <- indel.data[indel.data$classifier == j & indel.data$barcode == i,]
    
  if (nrow(y)>1) {
    
    indel.data$p.value[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$p.value
    
    indel.data$statistic[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$statistic
  
    indel.data$conf.int1[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[1]
  
    indel.data$conf.int2[indel.data$classifier == j & indel.data$barcode == i] <- 
      t.test(x$logratio.platenorm, y$logratio.platenorm)$conf.int[2]
    
  }
}
}

# Adjust p-values for multiple testing
indel.data$p.value.adjust <- p.adjust(indel.data$p.value)

# Create outlier df based on t-statistic
t.outlier.df <- indel.data[indel.data$p.value <= 0.05,]

# Calculate the mean of the three replicates
indel.data$logratio.mean <- 
  ave(indel.data$logratio.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))

indel.data$efficiency.mean <- 
  ave(indel.data$efficiency.platenorm, 
      indel.data$classifier, indel.data$barcode, FUN = function(x) mean(x))


```


\newpage
# Results
## Visualization: checking quality of data
```{r Quality check data, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
## Make some density plots to get a feeling for the data
# Density plot logratio of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = logratio.platenorm, fill = Target)) + geom_density() + xlab("logratio") + labs(title = "logratio density of the controls")

# Density plot logratio 
ggplot(data = indel.data, aes(x = logratio.platenorm, fill = Target)) + 
  geom_density() + xlab("logratio")+ labs(title = "logratio density of all targets") +
  theme(legend.text=element_text(size=18))

# Integral of logratio density plot per target group
ggplot(data = indel.data, 
       aes(x = logratio.platenorm)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = Target))+ labs(title = "accumulative logratio of all targets")


# Density plot logratio per target
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "logratio density per target")

# Density plot logratio per barcode
ggplot(data = indel.data, 
       aes(x = logratio.platenorm, fill = Target)) + geom_density()+
  xlab("logratio") + facet_wrap(~ barcode, nrow = 6, scales = "free")+ 
  labs(title = "logratio density per barcode")

# Density plot efficiency
ggplot(data = indel.data, aes(x = efficiency, fill = Target)) + geom_density() +
xlab("efficiency")+ labs(title = "efficiency density")

# Density plot efficiency per target
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_grid(rows = vars(Target))+ 
  labs(title = "efficiency density per target group")

# Density plot efficiency per barcode
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density()+
  xlab("efficiency: normalized over plate") + facet_wrap(~ Target, nrow = 4)+ 
  labs(title = "efficiency density per barcode")

# Integral of density plot
ggplot(data = indel.data, 
       aes(x = efficiency.platenorm)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = Target))+ 
  labs(title = "integral of efficiency density")

# Density plot normalized efficiency of the controls
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = efficiency.platenorm, fill = Target)) + geom_density() +
  xlab("efficiency: normalized over plate")+ 
  labs(title = "normalized efficiency density of controls")

# Density plots t-distribution, only Mirin & DNA-PKi
ggplot(data = indel.data[indel.data$Drug == c("DMSO","DNA-PKi","Mirin"),], aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic")+ labs(title = "t-statistic density of controls")

# Density plots t-distribution
ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() +
geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic")+ labs(title = "t-statistic density")

# Density plot t-statistic + facet_wrap
 ggplot(data = indel.data, aes(x = statistic, fill = Target)) + geom_density() + geom_vline(data=indel.data, aes(xintercept=4),linetype="dashed", size=1) + geom_vline(data=indel.data, aes(xintercept=-4),linetype="dashed", size=1)+ xlab("t-statistic") + facet_wrap(~Target, nrow = 4, scales = "free")+ labs(title = "t-statistic density per target group")

# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(Target,Target, function(x)-length(x)))) +
  geom_bar()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group")+ labs(title = "datapoints per target group")

# Relative amount of drugs in outlier df
ggplot(NULL,aes(x = reorder(Target,Target,function(x)-length(x)))) + 
      geom_bar(aes(fill="amount non-outliers"), data = indel.data, alpha = 0.5)+
  geom_bar(aes(fill="amount outlier"), data = t.outlier.df, alpha = 0.5)+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group") + labs(title = "outlier vs. non-outlier distribution per drug category", fill = "groups")


# Density plot of reads.count using only PAO data -> these are the input reads
ggplot(data = all.indel.data[all.indel.data$Drug == c("PAO","DMSO"),], aes(x = read.count, fill = Drug, group = Drug)) + geom_density() + facet_wrap(~barcode, nrow = 6)+ labs(title = "read count before cutting (PAO) and after cutting (DMSO)")


```



\newpage
## Visualization: correlation plots for quality check
```{r correlation plots, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Correlation mean efficiency vs mean ratio
indel.data$mean.logratio.drug = 
  ave(indel.data$logratio.platenorm, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$mean.efficiency.drug = 
  ave(indel.data$efficiency.platenorm, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))


for (i in unique(indel.data$conc)) {
  data <- indel.data[indel.data$conc == i,]
p <- ggplot(data = data, aes(x=mean.efficiency.drug, y=mean.logratio.drug)) +
  geom_point(size = 0.001) + 
  gghighlight(abs(mean.logratio.drug) > 0.5, label_key = Drug) + 
  labs(title = paste("correlation logratio vs. efficiency, concentration:",i)) 
print(p)
}


# Correlation plot mean viability vs. mean efficiency
indel.data$mean.viability.drug = 
  ave(indel.data$viability, indel.data$Drug, indel.data$conc, FUN = function(x) mean(x))
indel.data$Drug <- as.character(indel.data$Drug)

for (i in unique(indel.data$conc)) {
  data <- indel.data[indel.data$conc == i,]
p <- gghighlight_point(data = data, aes(x=mean.viability.drug, y=mean.efficiency.drug), abs(mean.efficiency.drug) > 0.05, label_key = Drug) +
  labs(title = paste("correlation efficiency vs. viability, concentration:",i)) +
print(p)
}


# Correlation plot mean viability vs. mean ratio
for (i in unique(indel.data$conc)) {
  data <- indel.data[indel.data$conc == i,]
p <- ggplot(data = data, aes(x=mean.viability.drug, y=mean.logratio.drug, label = Drug, color = Target)) +
    geom_point(size = 0.001) + 
  labs(title = paste("correlation logratio vs. viability, concentration:",i)) +
  geom_text(aes(label = ifelse(abs(mean.logratio.drug)>0.5, as.character(Drug),'')), 
            hjust=0,vjust=0, angle = 45, size = 3, family = "symbol")
print(p)
}


# Correlation old (predicted) +1/-7 ratio vs. +1/-7 ratio of this experiment 
indel.data$mean.ratio.bc <- ave(indel.data$ratio, indel.data$barcode, FUN = function(x) mean(x))
ggplot(data = indel.data[indel.data$Target == "Negative control",], aes(x=log2(mean.ratio), y=log2(mean.ratio.bc))) +
  geom_point() + geom_smooth(method = lm) +
  stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  scale_x_continuous(breaks=c(2, 4, 6, 8))+ xlab("logratio previous experiments") +
  ylab("logratio this experiment (only DMSO treated data)") + 
  labs(title = "correlation logratio per barcode of previous data with these data")

# Correlation plots of the replicates
indel.data.DNAPK <- indel.data[-grep("DNA-PK", indel.data$Drug),]
indel.data.rep1 <- indel.data.DNAPK[grep("rep1", indel.data.DNAPK$condition),]
indel.data.rep1 <- indel.data.rep1[,c(1,5,14,20)]
indel.data.rep2 <- indel.data.DNAPK[grep("rep2", indel.data.DNAPK$condition),]
indel.data.rep2 <- indel.data.rep2[,c(1,5,14,20)]
indel.data.rep3 <- indel.data.DNAPK[grep("rep3", indel.data.DNAPK$condition),]
indel.data.rep3 <- indel.data.rep3[,c(1,5,14,20)]
setnames(indel.data.rep1, old = "logratio", new = "rep1")
setnames(indel.data.rep2, old = "logratio", new = "rep2")
setnames(indel.data.rep3, old = "logratio", new = "rep3")
indel.data.rep <- merge(indel.data.rep1, indel.data.rep2, all = T)
indel.data.rep <- merge(indel.data.rep, indel.data.rep3, all = T)

# Correlation matrix plot
correlation.plot.rep <- indel.data.rep[,c(4,5,6)]
correlation.plot.rep <- na.omit(correlation.plot.rep)

n <- sample(1:nrow(indel.data), 5000)
boundaries <- seq(from = 0.8, by = 0.01, length.out = 4)
plt <- ggpairs(correlation.plot.rep,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") +
                   theme_bw()}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") +
                   theme_bw()})) +
  ggtitle("correlation of the three replicates") +
  theme(text = element_text(size = 20))+
  xlab("logratio") +
  ylab("logratio") 
  # theme_bw()

print(plt)

```

### Conclusion correlation plots
We can see that there is a very high correlation between all 3 replicates, meaning that we can use the data of all 3 replicates.


\newpage
## Visualizaton: Spotting outliers
```{r visualization spotting outliers, out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE}
# Spot outliers by plotting DMSO versus drugs
indel.data2 <- indel.data
indel.data2$mean.ratio.bc.drug.conc <- ave(indel.data2$efficiency, 
                                           indel.data2$conc, indel.data2$Drug, 
                                           indel.data2$barcode, FUN = function(x) mean(x))
indel.data2 <- indel.data2[,c(1,6,14,38)]
indel.data2 <- indel.data2[!duplicated(indel.data2),]
indel.data2.high <- indel.data2[grep("1um", indel.data2$conc),]
indel.data2.high <- indel.data2.high[,-3]

indel.data2.high <- dcast(indel.data2.high, barcode ~ Drug, value.var = "mean.ratio.bc.drug.conc")


gghighlight_point(indel.data2.high, aes(x = DMSO, y = `Vorinostat (SAHA, MK0683)`), `Vorinostat (SAHA, MK0683)` - DMSO > 0.1) + 
  geom_abline(intercept = 0, slope = 1) + 
  geom_abline(intercept = 0.1, slope = 1, linetype = "dashed") + 
  geom_abline(intercept = - 0.1, slope = 1, linetype = "dashed") +
  geom_text(aes(x = 0.4, y = 0.32, label = "-10% efficiency", angle = 35)) + 
  geom_text(aes(x = 0.4, y = 0.52, label = "+10% efficiency", angle = 35)) +
  scale_x_continuous(limits = c(0.25, 1)) +
  scale_y_continuous(limits = c(0.25, 1)) +
  labs(title = "Efficiency compared to DMSO for each barcode")

# Make a beeswarm plot with alternative colors for outliers based on chi square scores
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = logratio.mean, 
                         colour = ifelse(p.value > 0.05,
                                         "non-outlier","outlier")), alpha = 0.5) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("log2(+1/-7 ratio)") + xlab("Barcode") + 
  labs(title = "Outlier plot", colour = "Outlier based on p value < 0.05") + 
  scale_color_manual(values=c("#999999", "#E69F00"))

# Boxplot of efficiencies 
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  labs(title = "Efficiency distribution per barcode") 

# Boxplot of efficiencies normalized
ggplot(data = indel.data) +
  geom_boxplot(mapping = aes(x = barcode, y = efficiency.platenorm)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  labs(title = "Efficiency distribution per barcode after normalization") 

# Beeswarm plot of efficiencies
ggplot(data = indel.data) +
  geom_quasirandom(mapping = 
                     aes(x = barcode, y = efficiency.mean, 
                         colour = ifelse(p.value > 0.05,
                                         "non-outlier","outlier"))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
  ylab("efficiency") + xlab("barcode") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on p value < 0.05") + scale_color_manual(values=c("#999999", "#E69F00"))


# Make a loop of plots, plotting the ratio per drug target group together with DMSO
for (i in unique(indel.data$Target)) {
  data <- indel.data[indel.data$Target == c(i,"Negative control"), ]
  p <- ggplot(data = data) +
    geom_quasirandom(mapping = aes(x = barcode, y = logratio.platenorm, colour = Target), alpha = 0.8, dodge.width = -0.5) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
    ylab("log2(+1/-7 ratio)") + xlab("Barcode")+ labs(title= paste("logratio of",i, "compared to DMSO"))
  print(p)
}
```

## Conclusion
The data looks very nice, we can already spot the first outliers. Now we need to generate more sophisticated plots and integrate chromatin data to select hits.



## Exporting potential data. 
```{r export}
setwd("/DATA/usr/m.trauernicht/EpiScreen/epigenetic-screening-on-trip-clone/Data/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)

filename <- SetFileName("_t.outlier.df", "mt")
save(t.outlier.df, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

