---
title: "DSB Episcreen data analysis & plotting"
author: 
  - name: "Max Trauernicht"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site IPRs was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(tidyverse)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(ggpubr)
# library(Laurae)
library(pheatmap)
library(RColorBrewer)
library(ggrastr)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

theme_classic_lines <- function() {
  theme_pubr(border = F, legend = "top") +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}
theme_classic_lines_45 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 45) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}

theme_classic_lines_90 <- function() {
  theme_pubr(border = T, legend = "top", x.text.angle = 90) +
            theme(panel.grid.major = element_line(colour = "#adb5bd", size = 0.25),
                  strip.background = element_rect(fill = "#ced4da")
            )
}

theme_set(theme_classic_lines())

colors_diverse <- c("#264653", "#9AC1AE", "#5D987B", "#f2cc8f", "#e76f51")
colors_drugs <- c("#FA8D62", "#65BFA4", "#8CA0C4", "#808184", "#F6D289", "#E5E5E5", "#ACACAC", "#737373")
#colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 

ggplot_custom <- function(...) ggplot2::ggplot(...) + 
  scale_color_manual(values = colors_diverse) + 
  scale_fill_manual(values = colors_diverse)

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
# Import data from preprocessing script
indel.data <- readRDS("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/mt20220105_episcreen.RDS")

# Complete data without exlcluding wells <0.45 viability (I need this for plotting)
viability.data = as.data.table(readRDS("/DATA/projects/DSBrepair/git/EpiScreen/files_scripts/rs20211221_Episcreen_Reads_Viab_Metadata.RDS")) %>%
  dplyr::select(ID, drug, target, replicate, viability, conc_char, tech)
```







## Drug effects per target group

```{r Quality check data, warning = FALSE}
# Beeswarm plot of MMEJ score of all drugs, highlighting controls
ggplot_custom(data = indel.data %>%
         dplyr::select(MMEJ_zscore, sample, drug, conc_char, IPR, replicate) %>%
         unique(), 
       aes(y = MMEJ_zscore, x = 'x', color = sample)) + 
  geom_quasirandom(dodge.width = 0.75) +
  geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
  xlab("") + ylab("MMEJ z-score") +
  scale_color_manual(values = colors_diverse) +
  facet_grid(replicate~conc_char)

ggplot_custom(data = indel.data %>%
                filter(sample != "DNA-PKi (NHEJ control)", sample != "Mirin (MMEJ control)", sample != "DMSO (neg control)") %>%
                  dplyr::select(MMEJ_zscore_drug_comb, sample, drug, conc_char) %>%
                  unique(), 
              aes(y = MMEJ_zscore_drug_comb, x = conc_char)) + 
    geom_quasirandom(dodge.width = 0.75) +
    geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
    xlab("") + ylab("MMEJ z-score") 

ggplot_custom(data = indel.data %>%
                filter(sample != "DNA-PKi (NHEJ control)", sample != "Mirin (MMEJ control)", sample != "DMSO (neg control)") %>%
                  dplyr::select(freqCut_norm_mean_drug, sample, drug, conc_char) %>%
                  unique(), 
              aes(y = log2(freqCut_norm_mean_drug) , x = conc_char)) + 
    geom_quasirandom(dodge.width = 0.75) +
    geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
    xlab("") + ylab("log2(cutting efficiency)") 


      

# Integral of MMEJ-zscore density plot per target group
ggplot_custom(data = indel.data, 
       aes(x = MMEJ_zscore)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = target))+ 
  labs(title = "accumulative logratio of all targets") + facet_wrap(~replicate)

# Integral of freqCut density plot
ggplot_custom(data = indel.data, 
       aes(x = freqCut_mean)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = target))+ 
  labs(title = "integral of efficiency density")

# Total amount of drugs per target group
ggplot_custom(indel.data, aes(x = reorder(target,target, function(x)-length(x)))) +
  geom_bar()+theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group")+ labs(title = "datapoints per target group")


indel.data2 <- indel.data
indel.data2$zscore_change <- "<1"
indel.data2$zscore_change[abs(indel.data2$MMEJ_zscore)>1] <- "1-2"
indel.data2$zscore_change[abs(indel.data2$MMEJ_zscore)>2] <- ">2"
indel.data2$zscore_change <- factor(indel.data2$zscore_change, levels = c( ">2", "1-2", "<1"))
indel.data2 <- indel.data2 %>%
  mutate(size = ave(target, target, conc_char, replicate, zscore_change, FUN = function(x) length(x)),
         total_size = ave(target, target, conc_char, replicate, FUN = function(x) length(x)))


ggplot_custom(indel.data2 %>%
         dplyr::select(target, size, zscore_change, conc_char, total_size, replicate) %>%
         unique(), aes(x = reorder(target, as.numeric(total_size)), 
                   y = as.numeric(size), 
                       fill = zscore_change)) + 
      geom_bar(stat="identity") +
    labs(fill = "z-score")+
  scale_fill_manual(values = colors_diverse[rev(seq(1, length(colors_diverse), 2))])+
  coord_flip()+ 
  ylab("Amount of drugs per Category") + theme(axis.title.y = element_blank())+
  theme(text = element_text(size = 14), axis.text.y = element_text(size = 12))+
  facet_grid(replicate~conc_char)
```



## Correlation plots

```{r correlation plots, warning = FALSE}
# Technical replicate correlation MMEJ z-score
indel.data2 <- indel.data.split %>%
  filter(sample == "drug", drug != "Mirin", drug != "DNA-PKi", conc_char == '1 µM') %>%
  mutate(rep = paste(replicate, tech, sep = "_")) %>%
  dplyr::select(rep, drug, MMEJ_zscore_split_drug) %>%
  unique() %>%
  spread(rep, MMEJ_zscore_split_drug) %>%
  column_to_rownames("drug")

indel.data2.cor <- cor(indel.data2, method = "spearman")

mybreaks <- seq(0.6,1,0.004)
pheatmap(indel.data2.cor, 
         breaks = mybreaks, 
         cluster_rows = F,
         cluster_cols = F,
         border_color = "black",
         color = colorRampPalette(brewer.pal(n = 7, name = "Greys"))(100))

ggplot_custom(indel.data2, aes(x = E1504_1, y = E177_1)) +
  geom_point() +
  geom_smooth(method = "lm", color = colors_diverse[1]) 



# Plot the mean MMEJ zscore vs the SD - maybe we can identify a cutoff in that plot to remove drugs that have different effects in the two replicates (this is more informative than just correlating the two replicates)
indel.data2 <- indel.data %>% 
  filter(drug != "DNA-PKi") %>%
  dplyr::select(drug, conc_char, replicate, ID_2, MMEJscore_drug) %>%
  unique() %>%
  mutate(MMEJ_zscore_drug_sd = ave(MMEJscore_drug, ID_2, FUN = function(x) sd(x)),
         MMEJ_zscore_drug_sd = sqrt(MMEJ_zscore_drug_sd),
         mean_MMEJ = ave(MMEJscore_drug, ID_2, FUN = function(x) mean(x)))

ggplot_custom(indel.data2, aes(x = abs(mean_MMEJ), y = MMEJ_zscore_drug_sd)) +
  xlab("MMEJ score - mean per drug") +
  ylab("sqrt of SD of the two replicates") +
  geom_smooth() +
  geom_point() +
  geom_abline(intercept = 0.3, slope = 0.15, linetype = "dashed")

# The same but for the raw -7 counts
indel.data2 <- indel.data %>% 
  filter(drug != "DNA-PKi") %>%
  dplyr::select(drug, conc_char, replicate, ID_2, freqMMEJ) %>%
  unique() %>%
  mutate(freqMMEJ = ave(freqMMEJ, ID_2, replicate, FUN = function(x) mean(x))) %>%
  mutate(MMEJ_count_sd = ave(freqMMEJ, ID_2, FUN = function(x) sd(x)),
         MMEJ_count_sd = sqrt(MMEJ_count_sd),
         mean_MMEJ = ave(freqMMEJ, ID_2, FUN = function(x) mean(x))) %>%
  unique()

ggplot_custom(indel.data2, aes(x = abs(mean_MMEJ), y = MMEJ_count_sd)) +
  xlab("MMEJ z-score - mean per drug") +
  ylab("sqrt of SD of the two replicates") +
  geom_smooth() +
  geom_point() 
 # geom_hline(yintercept = 0.5, linetype = "dashed") 


# Plot viability against read counts (for already filtered data)
indel.data2 <- indel.data %>%
  dplyr::select(viab_norm, ID, sum_pooled_bc_reads) %>%
  unique()







# Visualize logratio change and efficiency change in one plot to spot outliers
indel.data2 <- indel.data %>% 
  dplyr::select(drug, conc_char, replicate, MMEJ_zscore_mean_drug, freqCut_norm_mean_drug) %>%
  filter(drug != "DNA-PKi") %>%
  unique()

ggplot_custom(indel.data2, aes(x = MMEJ_zscore_mean_drug, y = log2(freqCut_norm_mean_drug), color = MMEJ_zscore_mean_drug)) +
  geom_point()+
  scale_color_gradient() +
  xlab("MMEJ z-score") + ylab("Efficiency relative to DMSO (log2)") +
  #gghighlight(abs(mean.MMEJ_zscore.drug) > 5, label_key = drug) 
  theme(text = element_text(size = 14)) +
  facet_wrap(~conc_char)


# Correlation plot mean viability vs. mean efficiency
indel.data2 <- indel.data %>% 
  dplyr::select(drug, conc_char, replicate, viab_norm, freqCut_norm_mean_drug) %>% 
  unique() %>%
  mutate(viability_drug = ave(viab_norm, drug, conc_char, FUN = function(x) mean(x))) %>%
  dplyr::select(-viab_norm) %>%
  unique()

ggplot_custom(indel.data2, aes(x = viability_drug, y = log2(freqCut_norm_mean_drug))) +
  geom_point() +
  xlab("Viability") + ylab("Cutting Efficiency Change") +
  #gghighlight(abs(mean.efficiency_zscore.drug) > 0.1, label_key = drug) + 
  facet_wrap(~conc_char) +
  geom_smooth(method = "lm", color = "black")


# Correlation plot mean viability vs. mean ratio
indel.data2 <- indel.data %>% 
  dplyr::select(drug, concentration, MMEJ_zscore_mean_bio_drug, mean.viability.drug, replicate) %>% 
  filter(drug != "DNA-PKi") %>% 
  unique()

ggplot_custom(indel.data2, aes(x = MMEJ_zscore_mean_bio_drug, y = mean.viability.drug)) +
  geom_point(color = ifelse(abs(indel.data2$MMEJ_zscore_mean_bio_drug) > 1, "black", "grey")) +
  xlab("MMEJ z-score") + ylab("Viability") +
  #gghighlight(abs(mean.MMEJ_zscore.drug) > 1.5, label_key = drug) + 
  
  theme(text = element_text(size = 14)) +
  facet_wrap(~concentration, nrow = 1, ncol = 3)


ggplot_custom(indel.data2[indel.data2$drug != "DNA-PKi",], aes(x = MMEJ_zscore_mean_bio_drug, y = mean.viability.drug)) +
  geom_point()+
  xlab("MMEJ z-score") + ylab("Viability")+
  geom_smooth(method = lm, color = "grey") +
  theme(text = element_text(size = 14))+
  facet_wrap(~concentration, nrow = 1, ncol = 3)
  
# Do we need a more stringent viability cutoff? 0.7?




# Correlation plots of the replicates
indel.data2 <- indel.data[-grep("DNA-PK|DMSO", indel.data$drug),]
indel.data.rep1 <- indel.data2 %>%
  filter(tech == '1') %>%
  dplyr::select(IPR, replicate, drug, concentration, 'R1' = MMEJscore)
indel.data.rep2 <- indel.data2 %>%
  filter(tech == '2') %>%
  dplyr::select(IPR, replicate, drug, concentration, 'R2' = MMEJscore)
indel.data.rep3 <- indel.data2 %>%
  filter(tech == '3') %>%
  dplyr::select(IPR, replicate, drug, concentration, 'R3' = MMEJscore)

indel.data.rep <- merge(indel.data.rep1, indel.data.rep2, all = T)
indel.data.rep <- merge(indel.data.rep, indel.data.rep3, all = T)

# Correlation matrix plot
correlation.plot.rep1 <- indel.data.rep %>% 
  filter(replicate == "E177") %>%
  dplyr::select(R1, R2, R3) %>% 
  na.omit()

correlation.plot.rep2 <- indel.data.rep %>% 
  filter(replicate == "E1504") %>%
  dplyr::select(R1, R2, R3) %>% 
  na.omit()

n <- sample(1:nrow(indel.data), 5000)
boundaries <- seq(from = 0.7, by = 0.05, length.out = 4)
plt_replicate1 <- ggpairs(correlation.plot.rep1,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") 
                   }),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") 
                   })) +
  ggtitle("Correlation Between Technical Replicates - replicate 1") +
  theme(text = element_text(size = 20))+
  xlab("MMEJ score") +
  ylab("MMEJ score") 
  # 

plt_replicate2 <- ggpairs(correlation.plot.rep2,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") 
                   }),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") 
                   })) +
  ggtitle("Correlation Between Technical Replicates - replicate 2") +
  theme(text = element_text(size = 20))+
  xlab("MMEJ score") +
  ylab("MMEJ score") 
  # 

print(plt_replicate1)
print(plt_replicate2)



# Correlation between biological replicates
indel.data2 <- indel.data[-grep("DNA-PK|DMSO", indel.data$drug),] %>%
  dplyr::select(MMEJ_zscore_mean_bio_drug, replicate, drug, concentration) %>%
  unique() %>%
  spread(key = replicate, value = MMEJ_zscore_mean_bio_drug)

sp <- ggscatter(indel.data2, x = "E177", y = "E1504",
                size = 1.5, add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "mean drug effects on MMEJ-zscore rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")

sp + stat_cor(method = "pearson", label.x = -2, label.y = 1) + 
  facet_wrap(~concentration)


# Correlation between biological replicates - only DMSO - all IPRs
indel.data2 <- indel.data[grep("DMSO", indel.data$drug),] %>%
  dplyr::select(freqCut, replicate, drug, concentration, IPR, tech, drug_plate, well) %>%
  unique() %>%
  spread(key = replicate, value = freqCut)

sp <- ggscatter(indel.data2, x = "E177", y = "E1504",
                size = 1.5, add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "mean drug effects on efficiency rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")

sp + stat_cor(method = "pearson", label.x = 0.8, label.y = 0.7)
```



## Locally vs. globally acting drugs

```{r, warning = FALSE}
# Plotting efficiency per drug per IPR
ggplot_custom(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(freqCut_mean = ave(freqCut, IPR, drug, concentration, FUN = function(x) mean(x))) %>% 
         dplyr::select(freqCut_mean, IPR, drug, concentration) %>% unique(), aes(x = IPR, y = freqCut_mean)) +
  geom_quasirandom() +
  
  facet_wrap(~concentration) +
  coord_flip()

# Plotting MMEJscore per drug per IPR
ggplot_custom(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         dplyr::select(MMEJ_zscore_mean, IPR, drug) %>% unique(), aes(x = IPR, y = MMEJ_zscore_mean)) +
  geom_quasirandom() +
  
  coord_flip()




# Plotting the MMEJ z-score against the SD in the MMEJ z-score between the 18 IPRs
ggplot_custom(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(MMEJ_zscore_sd_drug = ave(MMEJ_zscore_mean, drug, concentration, FUN = function(x) sd(x))) %>%
         dplyr::select(MMEJ_zscore_mean_drug, MMEJ_zscore_sd_drug, drug, concentration) %>%
         unique(),
       aes(x = MMEJ_zscore_mean_drug, y = MMEJ_zscore_sd_drug, 
           color = ifelse(abs(MMEJ_zscore_mean_drug) >= 0.5 & MMEJ_zscore_sd_drug > 1, colors_diverse[3], colors_diverse[1]))) +
  geom_point() +
  geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.3) +
  geom_vline(xintercept = 0.5, linetype = "dashed", alpha = 0.3) +
  geom_vline(xintercept = -0.5, linetype = "dashed", alpha = 0.3) +
  xlab("MMEJ z-score per drug") +
  ylab("MMEJ z-score sd of IPRs") +
  facet_wrap(~concentration) +
  scale_color_identity()


ggplot_custom(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(MMEJ_zscore_sd_drug = ave(MMEJ_zscore_mean, drug, concentration, FUN = function(x) sd(x))) %>%
         dplyr::select(MMEJ_zscore_mean_drug, MMEJ_zscore_sd_drug, drug, concentration, target) %>%
         unique(),
       aes(x = MMEJ_zscore_mean_drug, y = MMEJ_zscore_sd_drug, 
           color = ifelse(abs(MMEJ_zscore_mean_drug) >= 0.5 & MMEJ_zscore_sd_drug > 1, colors_diverse[1], colors_diverse[2]))) +
  geom_point() +
  geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.3) +
  geom_vline(xintercept = 0.5, linetype = "dashed", alpha = 0.3) +
  geom_vline(xintercept = -0.5, linetype = "dashed", alpha = 0.3) +
    xlab("mean MMEJ z-score") +
    ylab("SD between IPRs") +
    facet_grid(concentration~target) +
    scale_color_identity()

indel.data$local <- "No"
indel.data$MMEJ_zscore_sd_drug <- ave(indel.data$MMEJ_zscore_mean, indel.data$drug, indel.data$concentration, FUN = function(x) sd(x))
indel.data$local[abs(indel.data$MMEJ_zscore_mean_drug) >= 0.5 & indel.data$MMEJ_zscore_sd_drug > 1] <- "Yes"




indel.data2 <- indel.data %>% 
  dplyr::select(drug, concentration, target, local) %>%
  unique()
indel.data2 <- indel.data2 %>%
  mutate(size = ave(target, target, concentration, local, FUN = function(x) length(x)),
         total_size = ave(target, target, concentration, FUN = function(x) length(x)))


ggplot_custom(indel.data2 %>%
         filter(concentration == "1") %>%
         dplyr::select(target, size, local, concentration, total_size) %>%
         unique(), aes(x = reorder(target, as.numeric(total_size)), 
                   y = as.numeric(size), 
                       fill = local)) + 
      geom_bar(stat="identity") +
    labs(fill = "locally acting drugs")+
  scale_fill_manual(values = colors_diverse[seq(1, length(colors_diverse), 2)])+
  coord_flip()+ 
  ylab("Amount of drugs per Category") + theme(axis.title.y = element_blank())+
  theme(text = element_text(size = 14), axis.text.y = element_text(size = 12))




ggplot_custom(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(freqCut_norm_sd_drug = ave(freqCut_norm_mean, drug, concentration, FUN = function(x) sd(x))) %>%
         dplyr::select(freqCut_norm_sd_drug, freqCut_norm_mean_drug, drug, concentration) %>%
         unique(),
       aes(x = freqCut_norm_mean_drug, y = freqCut_norm_sd_drug, 
           color = ifelse(freqCut_norm_sd_drug > 0.02, colors_diverse[3], colors_diverse[1]))) +
  geom_point() +
  geom_hline(yintercept = 0.02, linetype = "dashed", alpha = 0.3) +
  geom_vline(xintercept = 1, linetype = "dashed", alpha = 0.3) +
  
  xlab("efficiency per drug") +
  ylab("efficiency sd of IPRs") +
  facet_grid(~concentration) +
  scale_color_identity()

indel.data2 <- indel.data
indel.data2$drug_category <- "drug"
indel.data2$drug_category[indel.data2$target == "HDAC"] <- "HDAC"
indel.data2$drug_category[indel.data2$drug == "DMSO"] <- "DMSO"

ggplot_custom(indel.data2 %>%
           filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
           mutate(freqCut_norm_sd_drug = ave(freqCut_norm_mean, drug, concentration, FUN = function(x) sd(x))) %>%
           dplyr::select(freqCut_norm_sd_drug, freqCut_norm_mean_drug, drug, concentration, replicate, drug_category) %>%
           unique(),
       aes(x = freqCut_norm_mean_drug, y = freqCut_norm_sd_drug, 
           color = ifelse(freqCut_norm_sd_drug > 0.02, "red", "black"))) +
    geom_quasirandom() +
    geom_hline(yintercept = 0.02, linetype = "dashed", alpha = 0.3) +
  geom_vline(xintercept = 1, linetype = "dashed", alpha = 0.3) +
    
    xlab("efficiency per drug") +
    ylab("efficiency sd of IPRs") +
    facet_wrap(~drug_category) +
    scale_color_identity()

ggplot_custom(indel.data2 %>%
           filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
           mutate(freqCut_norm_sd_drug = ave(freqCut_norm_mean, drug, concentration, FUN = function(x) sd(x))) %>%
           dplyr::select(freqCut_norm_sd_drug, freqCut_norm_mean_drug, drug, concentration, replicate, drug_category) %>%
           unique(),
       aes(x = drug_category, y = freqCut_norm_mean_drug)) +
    geom_quasirandom() +
  geom_boxplot(alpha = 0.7) +
    
    xlab("") +
    ylab("mean cutting efficiency") +
  facet_wrap(~concentration) +
    scale_color_identity()

ggplot_custom(indel.data2 %>%
           filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
           mutate(freqCut_norm_sd_drug = ave(freqCut_norm_mean, drug, concentration, FUN = function(x) sd(x))) %>%
           dplyr::select(freqCut_norm_sd_drug, freqCut_norm_mean_drug, drug, concentration, replicate, drug_category) %>%
           unique(),
       aes(x = drug_category, y = freqCut_norm_sd_drug)) +
    geom_quasirandom() +
  geom_boxplot(alpha = 0.7) +
    
    xlab("") +
    ylab("mean cutting efficiency") +
  facet_wrap(~concentration) +
    scale_color_identity()

```

## Synergies MMEJ ratio with chromatin
### Load the processing data
```{r}
file = list.files(in.dir, pattern = "CCD_table", full.names = T) %>% tail(n = 1)
CCD_tib <- readRDS(file)
file = list.files(in.dir, pattern = "IPR_annotation_heatmap", full.names = T) %>% tail(n = 1)
chromatin_TIF <- readRDS(file)
file = list.files(in.dir, pattern = "compound_annotation_heatmap", full.names = T) %>% tail(n = 1)
target <- readRDS(file)
```


```{r Synergies chromatin - Balance all, fig.width= 10, fig.height= 20}
all_compounds_epistasis = CCD_tib %>%
  dplyr::select(drug_conc, ratio_slope_plot, feature) %>%
  group_by(drug_conc) %>%
  mutate(onlyNA = sum(is.na(ratio_slope_plot))) %>% 
  filter(onlyNA != 25) %>%
  reshape2::dcast(drug_conc ~ feature, value.var = "ratio_slope_plot", fill = 0) %>% 
  column_to_rownames(var = "drug_conc")

# change these numbers according to where you want to set the cutoff
quant_breaks <- quantile(all_compounds_epistasis, c(.01,.99), na.rm = T)
palette_length <- 100
breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
            seq(-quant_breaks[1]/palette_length, -quant_breaks[1], length.out=floor(palette_length/2)))
colors = colorRampPalette(slope.colors %>% pull(color))(length(breaks))
colors[which(quant_breaks == 0)-1] = "gray90"

target_ctrl = dplyr::rename(target, conc_char_ctrl = conc_char)

pheatmap(all_compounds_epistasis[, TRIP_chrom_clust$labels],
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         breaks = breaks,
         clustering_method = "ward.D",
         cluster_cols = TRIP_chrom_clust,
         annotation_row = target_ctrl,
         annotation_col = clustering,
         main = "Chromatin synergies - MMEJ ratio all",
         color = colors,
         annotation_colors = annotation_colors_scr, 
         annotation_legend = T)
```
CCD_xabi_matrix = CCD_xabi %>% filter(CCD_model_p_adj < 0.05, !chrom_feature %in% c("HDAC1", "HDAC2")) %>% distinct(gene, CCD_synergy_score, chrom_feature) %>% pivot_wider(names_from = chrom_feature, values_from = CCD_synergy_score) %>% column_to_rownames("gene")
```{r}
CCD_xabi = readRDS("/home/x.vergara/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/data/processed_data/xv20220811_Table_S3_DR_screen_results.rds")

CCD_xabi_matrix = CCD_xabi %>% 
  filter(CCD_model_p_adj < 0.05, 
         # !chrom_feature %in% c("HDAC1", "HDAC2")
  ) %>% 
  distinct(gene, CCD_synergy_score, chrom_feature) %>% 
  pivot_wider(names_from = chrom_feature, values_from = CCD_synergy_score) %>% 
  column_to_rownames("gene")

CCD_all = rbind(all_compounds_epistasis, CCD_xabi_matrix)

# change these numbers according to where you want to set the cutoff
quant_breaks <- quantile(CCD_all, c(.01,.99), na.rm = T)
palette_length <- 100
breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
            seq(-quant_breaks[1]/palette_length, -quant_breaks[1], length.out=floor(palette_length/2)))
colors = colorRampPalette(slope.colors %>% pull(color))(length(breaks))
colors[which(quant_breaks == 0)-1] = "gray90"

target_ctrl = dplyr::rename(target, conc_char_ctrl = conc_char)

pdf("/DATA/projects/DSBrepair/scratch/rs20220817_heatmap_all_synergies_combined.pdf", width = 10, height = 30)
pheatmap(CCD_all[, TRIP_chrom_clust$labels],
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         breaks = breaks,
         clustering_method = "ward.D",
         cluster_cols = TRIP_chrom_clust,
         # annotation_row = target_ctrl,
         annotation_col = clustering,
         main = "Chromatin synergies - MMEJ ratio all",
         color = colors,
         annotation_colors = annotation_colors_scr, 
         annotation_legend = T)
dev.off()

# ggsave("/DATA/projects/DSBrepair/scratch/rs20220817_heatmap_all_synergies_combined.pdf", width = 10, height = 30)
```



```{r Synergies chromatin - Balance per target, fig.width= 10, fig.height= 10}
targets = target %>% 
  pull(target) %>% 
  unique()

for (i in targets) {
  target_drugs = rownames(filter(target, target %in% i))
  
  # Make matrix with drugs from selected target
  mmej_synergy_matrix = all_compounds_epistasis %>% 
    rownames_to_column(var = "drug_conc") %>%
    filter(drug_conc %in% target_drugs) %>%
    column_to_rownames(var = "drug_conc")
  
  cluster_rows = ifelse(nrow(mmej_synergy_matrix) > 1, TRUE, FALSE)
  
  if(nrow(mmej_synergy_matrix) > 0) {
    # change these numbers according to where you want to set the cutoff
    quant_breaks <- quantile(mmej_synergy_matrix, c(.01,.99), na.rm = T) 
    palette_length <- 100
    breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
                seq(-quant_breaks[1]/palette_length, -quant_breaks[1], length.out=floor(palette_length/2)))
    slope.colors.temp = slope.colors
    if(all(mmej_synergy_matrix <= 0)) {
      breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length)))
      slope.colors.temp = filter(slope.colors, label != "positive")
    }
    if(all(mmej_synergy_matrix >= 0)) {
      breaks <- c(seq(0, quant_breaks[2], length.out=ceiling(palette_length)))
      slope.colors.temp = filter(slope.colors, label != "negative")
    }
    colors = colorRampPalette(slope.colors.temp %>% pull(color))(length(breaks))
    colors[which(quant_breaks == 0)-1] = "gray90"
    
    # heatmap
    p = pheatmap(mmej_synergy_matrix[, TRIP_chrom_clust$labels],
                 border_color = F,
                 cellwidth = 8,
                 cellheight = 8,
                 cluster_rows = cluster_rows,
                 cluster_cols = TRIP_chrom_clust,
                 breaks = breaks,
                 annotation_row = target_ctrl,
                 clustering_method = "ward.D",
                 main = paste("Chromatin synergies - MMEJ ratio per target :" , i, sep = " "),
                 color = colors,
                 annotation_colors = annotation_colors_scr, 
                 annotation_legend = T)
    print(p)
  }
}
```

### HDAC CCD heatmap
```{r 3B HDAC CCD, fig.width= 14, fig.height= 14}
target_drugs = cluster_HDAC %>% pull(drug_conc)

# Make matrix with drugs from selected target
bal_synergy_matrix = all_compounds_epistasis %>% 
  rownames_to_column(var = "drug_conc") %>%
  filter(drug_conc %in% target_drugs) %>%
  column_to_rownames(var = "drug_conc")

cluster_rows = ifelse(nrow(bal_synergy_matrix) > 1, TRUE, FALSE)

# change these numbers according to where you want to set the cutoff
quant_breaks <- quantile(bal_synergy_matrix, c(.01,.99), na.rm = T) 
palette_length <- 100
breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
            seq(quant_breaks[2]/palette_length, quant_breaks[2], length.out=floor(palette_length/2)))
slope.colors.temp = slope.colors
colors = colorRampPalette(slope.colors.temp %>% pull(color))(length(breaks))
colors[which(quant_breaks == 0)-1] = "gray90"

p = pheatmap(bal_synergy_matrix[, TRIP_chrom_clust$labels],
             border_color = F,
             cellwidth = 8,
             cellheight = 8,
             cluster_rows = cluster_rows,
             breaks = breaks,
             cluster_cols = TRIP_chrom_clust,
             annotation_row = target.cluster1,
             clustering_method = "ward.D2",
             main = paste("Chromatin synergies - MMEJ balance HDAC cluster"),
             color = colors,
             annotation_colors = annotation_colors_scr, 
             annotation_legend = T,
                cutree_rows = 3)
print(p)

bal_synergy_cluster <- bal_synergy_matrix %>%
  rownames_to_column("drug_conc") %>%
  left_join(cluster_HDAC) %>%
  mutate(cluster_HDAC = as.character(cluster_HDAC))

ggplot(bal_synergy_cluster,
       aes(x = cluster_HDAC, y = H3K27me3)) +
  geom_boxplot(outlier.shape = NA) +
  geom_quasirandom() +
  geom_signif(comparisons = combn(sort(unique(bal_synergy_cluster$cluster_HDAC)), 2, simplify = F), 
              map_signif_level=sigFunc, 
              step_increase = 0.1)
```

```{r}
CCD_tib_all = CCD_all %>% 
  rownames_to_column(var = "drug_conc") %>% 
  pivot_longer(cols = -drug_conc, 
               names_to = "feature", 
               values_to = "ratio_slope_plot")

for(i in unique(CCD_tib_all$feature)) {
  rank_dt = CCD_tib_all %>% 
    # left_join(rownames_to_column(target, var = "drug_conc"), by = "drug_conc") %>%
    filter(feature == i, !is.na(ratio_slope_plot)) %>%
    distinct() %>%
    arrange(desc(ratio_slope_plot))
  
  if(nrow(rank_dt) > 1) {
    rank_dt %<>%
      mutate(rank = seq(1:n()))
    
    maxrank = nrow(rank_dt)
    
    p1 = rank_dt %>% 
      ggplot(., aes(x = rank, 
                    # fill = target
                    )) +
      geom_bar() + 
      scale_x_reverse() +
      coord_flip() +
      xlab("Rank") +
      theme_classic2() +
      # scale_fill_manual(values = colors_targets) +
      # geom_label(aes(label = ifelse(width == 2, drug_conc,''))) +
      theme(legend.position = "none",
            axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank())
    
    p2 = rank_dt %>% 
      filter(!between(rank, 11, maxrank-10)) %>%
      mutate(rank = seq(1:n())) %>% 
      ggplot(., aes(x = rank, y = ratio_slope_plot, 
                    # fill = target)
             )) +
      geom_bar(stat = "identity") + 
      scale_x_reverse() +
      coord_flip() +
      ylab("MMEJ synergy score") +
      theme_classic2() +
      # scale_fill_manual(values = colors_targets) +
      # geom_label(aes(label = ifelse(width == 2, drug_conc,''))) +
      geom_text(aes(label=drug_conc)) +
      theme(legend.position = "none",
            axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank()) +
      ggtitle(paste0("Top MMEJ ratio synergies with: ", i))
    
    
    p = plot_grid(p1, p2, labels = c("E", "F"), rel_widths = c(1, 5))
    print(p)
  }
}
```

```{r}
for(i in unique(CCD_tib$feature)) {
  rank_dt = CCD_tib %>% 
    left_join(rownames_to_column(target, var = "drug_conc"), by = "drug_conc") %>%
    filter(feature == i, !is.na(ratio_slope_plot)) %>%
    distinct() %>%
    arrange(desc(ratio_slope_plot))
  
  if(nrow(rank_dt) > 1) {
    rank_dt %<>%
      mutate(rank = seq(1:n()))
    
    maxrank = nrow(rank_dt)
    
    p1 = rank_dt %>% 
      ggplot(., aes(x = rank, fill = target)) +
      geom_bar() + 
      scale_x_reverse() +
      coord_flip() +
      xlab("Rank") +
      theme_classic2() +
      scale_fill_manual(values = colors_targets) +
      # geom_label(aes(label = ifelse(width == 2, drug_conc,''))) +
      theme(legend.position = "none",
            axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank())
    
    p2 = rank_dt %>% 
      filter(!between(rank, 6, maxrank-5)) %>%
      mutate(rank = seq(1:n())) %>% 
      ggplot(., aes(x = rank, y = ratio_slope_plot, fill = target)) +
      geom_bar(stat = "identity") + 
      scale_x_reverse() +
      coord_flip() +
      ylab("MMEJ synergy score") +
      theme_classic2() +
      scale_fill_manual(values = colors_targets) +
      # geom_label(aes(label = ifelse(width == 2, drug_conc,''))) +
      geom_text(aes(label=drug_conc)) +
      theme(legend.position = "none",
            axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank()) +
      ggtitle(paste0("Top MMEJ ratio synergies with: ", i))
    
    
    p = plot_grid(p1, p2, labels = c("E", "F"), rel_widths = c(1, 5))
    print(p)
  }
}
```


```{r Z-score - Balance all, fig.width= 10, fig.height= 20}
ritios_tib_epi_effects = indel.data %>%
  mutate(drug_conc_ctrl = paste(drug, conc_char, sep = " ")) %>%
  filter(drug_conc_ctrl %in% rownames(all_compounds_epistasis)) %>%
  distinct(IPR, zscore_bal_comb_rep, drug_conc_ctrl, drug, conc_char) 

mmejzscore_matrix = ritios_tib_epi_effects %>%
  distinct(drug_conc_ctrl, IPR, zscore_bal_comb_rep) %>% 
  pivot_wider(names_from = IPR, values_from = zscore_bal_comb_rep) %>%
  column_to_rownames(var = "drug_conc_ctrl")

# clone5_map_ipr_TIF_Bal = hclust(dist(column_to_rownames(TIF_IPR, var = "IPR"))) %>% rotate(., c(1, 3, 2))

quant_breaks <- quantile(mmejzscore_matrix, c(.01,.99), na.rm = T) # change these numbers according to where you want to set the cutoff
palette_length <- 1000
breaks <- breaks <- c(seq(quant_breaks[1], -1, 
                          length.out=ceiling(palette_length/2) + 1), 
                      seq(-quant_breaks[1]/palette_length, 
                          -quant_breaks[1], 
                          length.out=floor(palette_length/2)))
colors = colorRampPalette(slope.colors %>% pull(color))(length(breaks))
colors[-which(breaks < -2.58 | breaks > 2.58 )] = "gray90"

pheatmap(mmejzscore_matrix[, clone5_map_ipr$labels],
         border_color = F,
         cellwidth = 8,
         cellheight = 8,
         breaks = breaks,
         cluster_cols = clone5_map_ipr,
         annotation_row = target_ctrl,
         
         clustering_method = "ward.D",
         main = "Z-score [< 0.01 p.val] - MMEJ ratio all",
         color = colors,
         annotation_colors = annotation_colors_scr, 
         annotation_legend = T,
         annotation_col = chromatin_TIF)
```

```{r Z-score - Balance per target, fig.width= 10, fig.height= 10}
targets = target %>% 
  pull(target) %>% 
  unique()

for (i in targets) {
  target_drugs = rownames(filter(target, target %in% i))
  
  # Make matrix with drugs from selected target
  mmejzscore_matrix = ritios_tib_epi_effects %>%
    distinct(drug_conc_ctrl, IPR, zscore_bal_comb_rep) %>% 
    filter(drug_conc_ctrl %in% target_drugs) %>%
    pivot_wider(names_from = IPR, values_from = zscore_bal_comb_rep) %>%
    column_to_rownames(var = "drug_conc_ctrl")
  
  cluster_rows = ifelse(nrow(mmejzscore_matrix) > 1, TRUE, FALSE)
  if(nrow(mmejzscore_matrix) > 0) {
    # change these numbers according to where you want to set the cutoff
    quant_breaks <- quantile(mmejzscore_matrix, c(.01,.99), na.rm = T) 
    palette_length <- 100
    breaks <- c(seq(quant_breaks[1], 0, length.out=ceiling(palette_length/2) + 1), 
                seq(-quant_breaks[1]/palette_length, -quant_breaks[1], length.out=floor(palette_length/2)))
    colors = colorRampPalette(slope.colors %>% pull(color))(length(breaks))
    colors[which(quant_breaks == 0)-1] = "gray90"
    
    # heatmap
    p = pheatmap(mmejzscore_matrix[, clone5_map_ipr$labels],
                 border_color = F,
                 cellwidth = 8,
                 cellheight = 8,
                 cluster_cols = clone5_map_ipr,
                 cluster_rows = cluster_rows,
                 
                 clustering_method = "ward.D",
                 breaks = breaks,
                 annotation_row = target_ctrl,
                 main = paste("Z-score [< 0.01 p.val] - MMEJ ratio per target :" , i, sep = " "),
                 color = colors,
                 annotation_colors = annotation_colors_scr, 
                 annotation_legend = T,
                 annotation_col = chromatin_TIF)
    print(p)
  }
}
```



## Spotting outliers
```{r, warning = FALSE}
# # Spot individual drug outliers per concentration
# indel.data2 <- indel.data
# indel.data2$MMEJ_zscore <- ave(indel.data2$MMEJ_zscore, indel.data2$concentration, indel.data2$drug, FUN = function(x) mean(x))
# indel.data2 <- indel.data2 %>% dplyr::select(drug, concentration, MMEJ_zscore)
# indel.data2 <- indel.data2[!duplicated(indel.data2),]
# indel.data2$concentration <- factor(indel.data2$concentration, levels=c("100nm", "1um", "10um"))
# 
# ggplot_custom(indel.data2 %>%
#          filter(drug != "DNA-PKi"), aes(x=concentration, y=MMEJ_zscore)) +
#   geom_quasirandom() + 
#   gghighlight(abs(MMEJ_zscore) > 6, label_key = drug) + 
#   
# # The same but only the range between 1 & 2
# ggplot_custom(indel.data2[abs(indel.data2$MMEJ_zscore) < 2,], aes(x=concentration, y=MMEJ_zscore)) +
#   geom_quasirandom() + 
#   gghighlight(abs(MMEJ_zscore) > 1.7, label_key = drug) + 
# 
# # Spot outliers by plotting DMSO versus drugs
# indel.data2 <- indel.data
# indel.data2$mean.ratio.bc.drug.conc <- ave(indel.data2$efficiency, 
#                                            indel.data2$concentration, indel.data2$drug, 
#                                            indel.data2$IPR, FUN = function(x) mean(x))
# indel.data2 <- indel.data2 %>% dplyr::select(IPR, drug, concentration, mean.ratio.bc.drug.conc)
# indel.data2 <- indel.data2[!duplicated(indel.data2),]
# indel.data2.high <- indel.data2[grep("1um", indel.data2$concentration),]
# indel.data2.high <- indel.data2.high[,-3]
# 
# indel.data2.high <- dcast(indel.data2.high, IPR ~ drug, value.var = "mean.ratio.bc.drug.conc")
# 
# 
# gghighlight_point(indel.data2.high, aes(x = DMSO, y = `Vorinostat (SAHA, MK0683)`), `Vorinostat (SAHA, MK0683)` - DMSO > 0.1) +
#   geom_abline(intercept = 0, slope = 1) +
#   geom_abline(intercept = 0.1, slope = 1, linetype = "dashed") +
#   geom_abline(intercept = - 0.1, slope = 1, linetype = "dashed") +
#   geom_text(aes(x = 0.4, y = 0.32, label = "-10% efficiency", angle = 35)) +
#   geom_text(aes(x = 0.4, y = 0.52, label = "+10% efficiency", angle = 35)) +
#   scale_x_continuous(limits = c(0.25, 1)) +
#   scale_y_continuous(limits = c(0.25, 1)) +
#   labs(title = "Efficiency compared to DMSO for each IPR") + 
# 
# # Make a beeswarm plot with alternative colors for outliers based on chi square scores
# ggplot_custom(data = indel.data) +
#   geom_quasirandom(mapping = 
#                      aes(x = reorder(IPR, order), y = logratio.mean, 
#                          colour = ifelse(p.value > 0.05,
#                                          "non-outlier","outlier")), alpha = 0.5) + 
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
#   ylab("log2(+1/-7 ratio)") + xlab("IPR") + 
#   labs(title = "Outlier plot", colour = "Outlier based on p value < 0.05") + 
#   scale_color_manual(values=c("#999999", "#E69F00"))
# 
# 
# 
# # Boxplot of logratio 
# indel.data$cluster <- "Active Promoter/Enhancer" 
# indel.data$cluster[indel.data$order == "3" | 
#                       indel.data$order == "4"] <- "H3K9me2/3 Domain"
# indel.data$cluster[indel.data$order == "5" | 
#                       indel.data$order == "6" |
#                       indel.data$order == "7" | 
#                       indel.data$order == "8"] <- "Active Gene Body"
# indel.data$cluster[indel.data$order == "9" | 
#                       indel.data$order == "10" |
#                       indel.data$order == "11" | 
#                       indel.data$order == "12"] <- "LAD"
# indel.data$cluster[indel.data$order == "13" | 
#                       indel.data$order == "14"] <- "No Chromatin Marks"
# indel.data$cluster[indel.data$order == "15" | 
#                       indel.data$order == "16" |
#                       indel.data$order == "17" | 
#                       indel.data$order == "18"] <- "H3K27me3 Domain"
# 
# ggplot_custom(data = indel.data[indel.data$drug != "DMSO",],
#        aes(x = reorder(IPR, order),
#            y = efficiency_zscore)) +
#   geom_quasirandom(color = ifelse(indel.data[indel.data$drug != "DMSO",]$efficiency_zscore > 2 | 
#                                     indel.data[indel.data$drug != "DMSO",]$efficiency_zscore < -2, 
#                                   "#343a40", "#6c757d")) +
#   ylab("MMEJ score")+
#   scale_fill_brewer(palette = "Pastel2")+
#   xlab("") +
#   +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+
#   theme(axis.title.x = element_blank()) +
#   coord_flip()
# 
# # Are the logratios of the different IPR clusters different?
# indel.data2$int <- "1"
# indel.data2$int[indel.data2$order >= 9] <- "2"
# indel.data2$logratio <- ave(indel.data2$logratio, 
#                             indel.data2$IPR, 
#                             indel.data2$rep, 
#                             FUN = function(x) mean(x))
# indel.data2 <- indel.data2 %>% dplyr::select(rep, logratio, int, IPR) %>% unique()
# indel.data2$mean <- ave(indel.data2$logratio,
#                         indel.data2$int, 
#                         indel.data2$rep,
#                         FUN = function(x) mean(x))
# indel.data2$sd <- ave(indel.data2$logratio, 
#                       indel.data2$int, 
#                       indel.data2$rep,
#                       FUN = function(x) sd(x))
# indel.data2$p.value <- t.test(indel.data2$mean[indel.data2$int == 1], indel.data2$mean[indel.data2$int == 2])$p.value
# indel.data2$mean.bio <- ave(indel.data2$mean,
#                         indel.data2$int, 
#                         FUN = function(x) mean(x))
# indel.data2$sd.bio <- ave(indel.data2$logratio, 
#                       indel.data2$int, 
#                       FUN = function(x) sd(x))
# 
# 
# # Boxplot of efficiencies normalized
# ggplot_custom(data = indel.data[indel.data$drug == "DMSO",]) +
#   geom_boxplot(mapping = aes(x = reorder(IPR,order), y = efficiency.platenorm)) + 
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
#   labs(title = "Efficiency distribution per IPR after normalization") 
# 
# # Beeswarm plot of efficiencies
# ggplot_custom(data = indel.data) +
#   geom_quasirandom(mapping = 
#                      aes(x = reorder(IPR,order), y = efficiency.mean, 
#                          colour = ifelse(p.value > 0.05,
#                                          "non-outlier","outlier"))) + 
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
#   ylab("efficiency") + xlab("IPR") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on p value < 0.05") + scale_color_manual(values=c("#999999", "#E69F00"))
# 
# 
# # Make a loop of plots, plotting the ratio per drug target group together with DMSO
# for (i in unique(indel.data$target)) {
#   data <- indel.data[indel.data$target == i | indel.data$target == "Negative Control", ]
#   p <- ggplot_custom(data = data) +
#     geom_quasirandom(mapping = aes(x = reorder(IPR,order), y = MMEJ_zscore, colour = target), alpha = 0.8, dodge.width = -0.5) + 
#     theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
#     ylab("log2(+1/-7 ratio)") + xlab("IPR")+ labs(title= paste("logratio of",i, "compared to DMSO"))
#   print(p)
# }
# 
# 
# # Aurora Kinase only
# indel.data.med <- indel.data[indel.data$concentration == "1um",]
# aurora.dmso <- indel.data.med[indel.data.med$drug == "DMSO" | indel.data.med$target == "Aurora Kinase",]
# aurora.dmso$target <- factor(aurora.dmso$target, levels = c("Negative Control", "Aurora Kinase"))
# ggplot_custom(data =  aurora.dmso) +
#     geom_quasirandom(aes(x = reorder(IPR,order), y = MMEJ_zscore, colour = target, group = target), 
#                      alpha = 0.8, dodge.width = -0.5, width = 0.1) + 
#   scale_colour_brewer(palette = "Set2")+
#   coord_flip()+
#   theme(axis.title.y = element_blank())+
#     ylab("Change log2(+1/-7 ratio)")+
#   theme(text = element_text(size = 14))+
#   geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.5)+
#   theme_classic2()
# 
# 
# # Decitabine only
# decitabine.dmso <- indel.data[indel.data$drug == "DMSO" | 
#                                 indel.data$drug == "Decitabine",]
# decitabine.dmso$drug <- factor(decitabine.dmso$drug, levels = c("DMSO", "Decitabine"))
# decitabine.dmso$concentration <- factor(decitabine.dmso$concentration, levels = c("100nm", "1um", "10um"))
# 
# ggplot_custom(decitabine.dmso, aes(x = reorder(IPR,order), 
#                             y = MMEJ_zscore, 
#                             colour = drug, group = drug,
#                             dodge.width = -0.5,
#                             width = 0.1)) +
#     geom_quasirandom() + 
#   scale_colour_brewer(palette = "Set2") +
#   coord_flip() +
#   theme(axis.title.y = element_blank()) +
#   ylab("MMEJ z-score") +
#   xlab("") +
#   theme(text = element_text(size = 14)) +
#   geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
#    facet_wrap(~concentration)
# 
# # HDACs (efficiency and logratio)
# hdac.dmso <- indel.data[indel.data$drug == "Vorinostat (SAHA, MK0683)"|
#                           indel.data$drug == "Givinostat (ITF2357)"|
#                           indel.data$drug == "PCI-24781 (Abexinostat)"|
#                           indel.data$drug == "AR-42"|
#                           indel.data$drug == "Scriptaid ",]
# hdac.dmso <- hdac.dmso[hdac.dmso$concentration == "1um",]
# 
# hdac.dmso$MMEJ_zscore <- ave(hdac.dmso$MMEJ_zscore, 
#                              hdac.dmso$IPR, hdac.dmso$drug,
#                              FUN = function(x) mean(x))
# hdac.dmso$efficiency_zscore <- ave(hdac.dmso$efficiency_zscore, 
#                                     hdac.dmso$IPR, hdac.dmso$drug,
#                                     FUN = function(x) mean(x))
# 
# 
# hdac.dmso <- hdac.dmso %>% dplyr::select(drug, MMEJ_zscore, 
#                                   efficiency_zscore, order, 
#                                   IPR) %>% unique()
# hdac.dmso$mean <- ave(hdac.dmso$MMEJ_zscore, hdac.dmso$IPR,
#                       FUN = function(x) mean(x))
# hdac.dmso$mean2 <- ave(hdac.dmso$efficiency_zscore, hdac.dmso$IPR,
#                       FUN = function(x) mean(x))
# 
# ggplot_custom() +
#   geom_bar(data = hdac.dmso %>%
#              dplyr::select(mean, IPR, order) %>%
#              unique(), stat="identity", aes(x =  reorder(IPR,order), y = mean, alpha = 0.2)) +
#   geom_point(data = hdac.dmso, aes(x = reorder(IPR,order), y = MMEJ_zscore, color = drug)) + 
#   scale_colour_brewer(palette = "Set2")+
#   coord_flip()+
#   theme(axis.title.y = element_blank())+
#   ylab("MMEJ z-score")+
#   xlab("") +
#   theme(text = element_text(size = 14))+
#   
# 
# ggplot_custom() +
#   geom_bar(data = hdac.dmso %>%
#              dplyr::select(mean2, IPR, order) %>%
#              unique(), stat="identity", aes(x =  reorder(IPR,order), y = mean2, alpha = 0.2)) +
#   geom_point(data = hdac.dmso, aes(x = reorder(IPR,order), y = efficiency_zscore, color = drug)) + 
#   scale_colour_brewer(palette = "Set2")+
#   coord_flip()+
#   theme(axis.title.y = element_blank())+
#   ylab("efficiency z-score")+
#   xlab("") +
#   theme(text = element_text(size = 14))+
#   
# 
# # Statistical significance? Is IPR 17 different?
# anova <- aov(MMEJ_zscore ~ IPR, data = hdac.dmso)
# summary.aov(anova)
# tukey <- TukeyHSD(anova)
# 
# # Make plots for all HDACs at the three concentrations
# indel.data$concentration <- factor(indel.data$concentration, levels = c("100nm", "1um", "10um"))
# ggplot_custom(indel.data %>%
#          filter(target == "HDAC" | drug == "DMSO"),
#        aes(x = reorder(IPR, order), y = efficiency_zscore, color = target)) +
#   geom_quasirandom(dodge.width = 0.75) +
#   geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
#   
#   xlab("") +
#   scale_color_manual(values = colors_diverse) +
#   facet_wrap(~concentration) +
#   coord_flip()
# 
# # only at the specific domains
# indel.data$cluster2 <- "open" 
# indel.data$cluster2[indel.data$order == "9" | 
#                       indel.data$order == "10" |
#                       indel.data$order == "11" | 
#                       indel.data$order == "12" |
#                      indel.data$order == "13" | 
#                       indel.data$order == "14" |
#                      indel.data$order == "15" | 
#                       indel.data$order == "16" |
#                       indel.data$order == "17" | 
#                       indel.data$order == "18"] <- "condensed"
# 
# # Include detailed HDAC annotation
# hdac_annotation <- read.csv2("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/HDAC_categories.csv") %>%
#   dplyr::select(drug, Categorie)
# indel.data.hdac <- indel.data %>%
#   filter(target == "HDAC" | drug == "DMSO")
# indel.data.hdac <- merge(indel.data.hdac, hdac_annotation, all = T)
# 
# ggplot_custom(indel.data.hdac[!is.na(indel.data.hdac$concentration),] %>%
#          filter(Categorie %in% c("HDAC1", "HDAC3", "DMSO")),
#        aes(x = Categorie, y = efficiency_zscore, color = cluster2)) +
#   geom_quasirandom(dodge.width = 0.75) +
#   geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
#   
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0.5)) + 
#   xlab("") +
#   scale_color_manual(values = colors_diverse) +
#   facet_wrap(~concentration)
```


```{r export}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```