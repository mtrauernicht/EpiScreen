---
title: "Indels Preprocessing"
author: "Ruben Schep"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---

knitr document van Steensel lab

# Preprocessing of the indel data
# Introduction

In this script I want to prepocess the datafiles into several working dataframes. 

I want one data frame in which I have the number of mutations, per sample, per barcode per indel size.
This one will be used for plotting indel patterns, calculating ratios later on and such.

I want one dataframe that contains the ratios of each barcode in each sample. These ratios will be : 
This could be a long dataframe, with the following variables: Barcode, sample, ratios ...  

* Efficiency (All mutations / Total or (Total - WT sequences) / Total)  
* +1 / -7  
* Deletions / Total  
* Insertions / Total  
* +1 / (-7 + -14 + -22)  
* Barcode effiency vs Overall efficiency  

In this dataframe I would also like to have the means of the samples (here I will ignore the inhibitor treated ones)  

* Mean ratio  
* Total reads  
* Mean reads  
* Median reads  

## Description of Data

For this analysis we need the mapping and the indel data of the TRIP integrations. These 
files are obtained with the crispr_trip.snake script that C. Leemans edited. This data 
contains the genomic locations of the TRIP integrations (hg38) and the indel frequencies 
at each integration.

The mutations were called by counting the distance between two constant regions. These
were separated by barcode. The barcodes were also filtered on the starcode, to pick out
the most abundant, and considered real, ones.

Mutations files : *genuine_mapped.table

| barcode  | type | score | 
| ------- | --------- | ----- | 
| TTCTATTCGCACACAA | ins | 1 |
| TTTCCCACATCAGGAG | wt | 0 |
| CCATAGTAGTGATTAC | del | -4 |

# Data importing and processing
## Path, Libraries, Parameters and Useful Functions
```{r setup, message=FALSE, warnings=FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 

# libraries:
# library(devtools)
# install_github("lawremi/rtracklayer")
# install_github("cran/gtools")
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(car)
library(parallel)
library(gtools)
# library(rtracklayer)
```
## Custom functions
Functions used
```{r functions}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, substr(gsub("-","",Sys.time()),1,8), filename)
  filename
}

CallTrueBarcodes <- function(df) {
  df <- df[df$V2 %in% barcodes.list,]
  df
}

RemoveLowReads <- function(reads) {
  if (sum(reads$V1) < 2000) {
    reads <- NULL
  } else {
    reads 
  } 
}

RemoveEmptyDfs <- function(rem) {
  if (is.null(rem) == TRUE) {
    rm(rem)
  } else {
    rem
  }
}


Read_Counts <- function(x) {
  #This function sums all the reads per barcode
  tmp <- x %>% group_by(V2) %>% summarise(sum = sum(V1))
  tmp$V2 <- as.character(tmp$V2)
  colnames(tmp) <- c("barcode", "sum")
  tmp
}


MutationsToDataframe <- function(mutations) {
  # This function does
  tmp <- data.table::dcast(mutations, value.var = "V1", formula = V2 ~ V4, fun = sum)
  n <- colnames(tmp)
  names(tmp) <- n
  rownames(tmp) <- tmp$"V2"
  tmp <- tmp[, -1]
  tmp
}

IndelsOnly <- function(x) {
  #This function removes the "not_clear and "point_mut" from the indels.
  tmp <- x[!x$V3 %in% c("not_clear", "wt_point_mut"), ]
  tmp
}

Not_Clear_Counts <- function(x){
  tmp <- x[x$V3 == "not_clear", ]
  tmp <- tmp[, c("V2", "V1")]
  colnames(tmp) <- c("barcode", "not_clear")
  tmp
}

Point_Mut_Counts <- function(x){
  tmp <- x[x$V3 == "wt_point_mut", ]
  tmp <- tmp[, c("V2", "V1")]
  colnames(tmp) <- c("barcode", "point_mut")
  tmp
}

RenameBarcodes <- function(list, pool) {
# This function renames the barcodes in the samples to barcode.pool to remove ambuguity between the cell pools
    for (i in pool) {
    list[[i]]$V2 <- paste(list[[i]]$V2, deparse(substitute(pool)), sep = ".")
  }
  list
}

NAToZero <- function(DT) {
  # This function changes NA to 0 in a data.table by name :
  for (j in names(DT))
    set(DT,which(is.na(DT[[j]])),j,0)
  return(DT)
  }

RemoveBarcodeFromList_RN <- function(x, barcode) {
  tmp <- x[!rownames(x)==barcode, ]
  tmp
}

RemoveBarcodeFromList_barcode <- function(x, barcode) {
  tmp <- x[!x$barcode==barcode, ]
  tmp
}

CalculateRatio <- function(mutations, indel) {
  # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel) %in% names(mutations)) {
    indel_reads <- mutations[,as.character(indel)]
    indel_reads <- as.matrix(indel_reads)
    rownames(indel_reads) <- rownames(mutations)
    
    ratio=ifelse(((indel_reads==0) | mutations[, "0"]==0), NA, 
                 as.numeric(mutations[,as.character(indel)]/(rowSums(mutations)-mutations[, "0"])))
                 
    ratio=round(ratio,3)
    
    df <- data.frame(barcode = as.character(row.names(mutations)),
             ratio = ratio,
             stringsAsFactors = FALSE)
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel)))
    df
  } else {
    df <- data.frame(barcode = as.character(row.names(mutations)),
             ratio = NA, 
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel)))
    df
  }
}

CalculatePercentage <- function(mutations, indel) {
  # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel) %in% names(mutations)) {
    indel_reads <- mutations[,as.character(indel)]
    indel_reads <- as.matrix(indel_reads)
    rownames(indel_reads) <- rownames(mutations)
    
    percentage=ifelse((indel_reads==0), 0, 
                 as.numeric(mutations[,as.character(indel)]/(rowSums(mutations))*100))
                 
    percentage=round(percentage,3)
    
    df <- data.frame(barcode = as.character(row.names(mutations)),
             percentage = percentage,
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("percentage.", as.character(indel)))
    df
  } else {
    df <- data.frame(barcode = as.character(row.names(mutations)),
             ratio = NA,
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("percentage.", as.character(indel)))
    df
  }
}


CalculateRatio_internal <- function(mutations, indel1, indel2){
   # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel1) %in% names(mutations) & as.character(indel2) %in% names(mutations)) {
    indel1_reads <- mutations[,as.character(indel1)]
    indel1_reads <- as.matrix(indel1_reads)
    rownames(indel1_reads) <- rownames(mutations)
    
    indel2_reads <- mutations[,as.character(indel2)]
    indel2_reads <- as.matrix(indel2_reads)
    rownames(indel2_reads)=rownames(mutations)
    
    ratio=ifelse(((indel1_reads==0 & indel2_reads==0) | indel2_reads==0), NA, 
                 as.numeric(mutations[,as.character(indel1)]/mutations[,as.character(indel2)]))
                 
    ratio=round(ratio,3)
    
    df <- data.frame(barcode = row.names(mutations),
             ratio = ratio,
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel1), "_", as.character(indel2)))
    df
  } else {
    df <- data.frame(barcode = row.names(mutations),
             ratio = NA, 
             stringsAsFactors = FALSE) 
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel1), "_", as.character(indel2)))
    df
  }
}

CalculateEfficiencies <- function(efficiencies) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(efficiencies),
             efficiency = (1 - efficiencies[, "0"] / rowSums(efficiencies)) * 100)
}

CalculateInsertions <- function(insertions) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(insertions),
             insertions = (rowSums(insertions[, -grep('^[-0]',colnames(insertions))]) / rowSums(insertions)) * 100)
}

CalculateDeletions <- function(deletions) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(deletions),
             deletions = (rowSums(deletions[ ,grep('-',colnames(deletions))]) / rowSums(deletions)) * 100)
}
```

## Data import
Data import from mapping. These files were generated on 30.09.2018, with a minimum of 500 reads per barcode in the mutation calling.
```{r import}
# Set directory to the mutation output folder of the CRISPR-TRIP snakemake script
setwd("/DATA/projects/DSBrepair/data/5280_DrugScreen/processed/mutation_counts")
# Import files in list and make individual tables
# I use this if all the samples are good. Here however I do not use all the samples. 
file.list <- list.files(pattern='*[.]raw_count.table')

# Import barcode list
barcodes.list <- c("AGGGCGTAAAATATTT", "TATGGCTGTCGGGTAG", "TGTCCCTTAGTACTTT", "AGAAAATAATATGACG","CGGCCTGAAGGTCAGG","TTGAACGCGGGCTCGG","GCTAACATCACGAATC","GCGCACCCTTTAATTG","ACTGTCGAGTTGTCCG","CCGGGGACGTATGCAC","TCTTTTGAGGAGCTGA","ATATCGTTGCTGGAGA","CATCCACCACACTTCA","ACCCCTAAAGGCGCTG","ATACTATATTTAACGG","CATTTCTGATCAATAA","CTCTTAATCGCTGCC","GAGCGCGTCACCGGGT","GTACCTCTCGATAGTG","TGGCCAATATTTGTCT")

# import the data
df.list <- mclapply(file.list, read.table, mc.cores = 20, stringsAsFactors = FALSE)
# rename the lists
names(df.list) <- gsub('(*?)[.]ma.*', '\\1', file.list)
# these are the samples
names(df.list)
# count the sample number
n.samples <- length(df.list)
```

## Select true barcodes and exclude low read counts
```{r}
# Call true barcodes
df.list <- lapply(df.list, CallTrueBarcodes)

# Remove samples with low read counts
df.list2 <- lapply(df.list, RemoveLowReads)

# Remove empty dfs
df.list3 <- lapply(df.list2, RemoveEmptyDfs)

df.list4 <- Filter(function(x) ncol(x) == 5, df.list2)

df.list4 <- df.list2[sapply(df.list2, function(x) dim(x)[[1]]) > 0]
```



### Some data pre-processing
Set everything in a datafram that contains the barcodes, indel ratios, and efficiencies.
```{r indeldataframe}
# To be able to setup the functions in a general way. This means in cases where we have A
# and B samples. 
# A <- grep("_A_",  names(df.list))
# B <- grep("_B_",  names(df.list))
# # Rename the barcodes
# df.list <- RenameBarcodes(df.list, pool = A)
# df.list <- RenameBarcodes(df.list, pool = B)

# Total reads per barcode
total.reads.list <- mclapply(df.list, Read_Counts, mc.cores = 10)

# Combine the mutations in a list as dataframes for eacht sample.
not.clear.list<- mclapply(df.list, Not_Clear_Counts, mc.cores = 10)
point.mut.list <- mclapply(df.list, Point_Mut_Counts, mc.cores = 10)

# Now remove these samples from all the mutations lists before we make the indel dataframes
indel.list <- mclapply(df.list, IndelsOnly, mc.cores = 10)

# Remove dataframes without data (leftovers from the low reads removal)


mutations.list <- lapply(indel.list, MutationsToDataframe)
total.reads.mutations.list <- mclapply(indel.list, Read_Counts, mc.cores = 10)
# We need to get the total reads in each sample, here I'll get the sum of all the columns and rows from each dataframe.
```

Next we will work on a long dataframe that will include all the ratios (deletions, insertions, +1/-7 etc) for each barcode in each sample.

I found out that some barcodes overlap in A and B but do not have the same integration sites (this has a very low chance). It would be a pitty to trash them, and I do not want to merge them as they are integrated in differente locations. I will name all the barcodes in A sample to "barcode".A and in B to "barcode".B. For this I will use the n.samples to pick out only A and only B data.

 
# Analysis
## Not clear counts in the mutation data
```{r not_clear}
# I need to change the list into a data frame, and pull out the names of the samples, transform the data frame (this returns a matrix) and rechange it into a data frame. 
total.reads.df <- ldply(total.reads.list, data.frame)
point.mut.df <- ldply(point.mut.list, data.frame)
not.clear.df <- ldply(not.clear.list, data.frame)
# Merge them all together
non.indels.df <- list(total.reads.df, point.mut.df, not.clear.df) %>% 
  join_all(., by = c(".id", "barcode"),  match = "first")  %>%
  mutate_all(funs(replace(., is.na(.), 0)))
# Calculate the fraction of not clear
non.indels.df$nc_fraction <- non.indels.df$not_clear/non.indels.df$sum*100
non.indels.df$pm_fraction <- non.indels.df$point_mut/non.indels.df$sum*100

# What is the mean not clear fraction in our samples? 
nc_pm_fraction.df <- non.indels.df %>% 
  group_by(.id) %>% 
  summarise(mean_nc = mean(nc_fraction),
            median_nc = median(nc_fraction),
            max_nc = max(nc_fraction),
            mean_pm = mean(pm_fraction),
            median_pm = median(pm_fraction),
            max_pm = max(pm_fraction)) %>% 
  melt(., id.vars = ".id")

nc_pm_fraction.df$type <- gsub(".*_", "", nc_pm_fraction.df$variable)
nc_pm_fraction.df$plasmid <- gsub("indel_.*?_.*?_(.*?)_.*", "\\1", nc_pm_fraction.df$.id)

ggplot(nc_pm_fraction.df, aes(.id , value, fill = variable)) + 
  geom_bar(position = "dodge", stat = "identity") + 
  facet_grid(type ~ ., scales = "free")


# The total means and medians of all the samples: 
nc_pm_fraction.df %>% group_by(variable) %>% summarise(mean = mean(value), median = median(value), max = max(value), min = min(value))

```
  
In this plot we see that on average we have a very acceptable amount of not-clear reads. There are some peaks, what are they from?
  
```{r}
# What are the top non clear barcodes?
non.indels.df[order(non.indels.df$nc_fraction, decreasing = T)[1:30],]

```

It seems that most of the not clear reads come from one specific barcode. CATGAGTATTGGGACG.A
Surprisingly it's also the sample that is shifted (where the WT is considered a +4 and the +1 a +5).
Easiest is to discard this barcode for all further analysis.

Quick look at the amount of point mutations per sample. 

```{r}
ggplot(nc_pm_fraction.df[nc_pm_fraction.df$type=="pm", ], aes(.id , value, fill = variable)) + 
  geom_bar(position = "dodge", stat = "identity") + 
  facet_grid(. ~ plasmid, scales = "free")

# make a small dataframe with the mean amount of point mutations.
mean_pm <- nc_pm_fraction.df[nc_pm_fraction.df$variable=="mean_pm", ]
# What are the experiments with the most point mutations?
mean_pm[order(mean_pm$value, decreasing = T)[1:20],]

# Are there any barcodes that pop up specifically?
non.indels.df[order(non.indels.df$pm_fraction, decreasing = T)[1:20],]
```

Most of the samples that have a higher average point mutation count are the negative control samples. 

This all looks good to me. But before we continue let's remove the barcode with the weird indels. 

```{r}
mutations.list <- lapply(mutations.list, 
                         RemoveBarcodeFromList_RN , 
                         barcode = c("CATGAGTATTGGGACG.A"))
mutations.list <- lapply(mutations.list, 
                         RemoveBarcodeFromList_RN , 
                         barcode = c("CCCACCCAGCCCACGT.A"))

total.reads.mutations.list <- lapply(total.reads.mutations.list, 
                                     RemoveBarcodeFromList_barcode, 
                                     barcode = c("CATGAGTATTGGGACG.A"))
total.reads.mutations.list <- lapply(total.reads.mutations.list, 
                                     RemoveBarcodeFromList_barcode, 
                                     barcode = c("CCCACCCAGCCCACGT.A"))
dim(total.reads.mutations.list$`indel_9_B_LBR2_-`)
```


```{r}
# Let's make the sums of all the standard LBR2 samples (no drugs, DMSO, 64h)
norm.mutations.list <- lapply(mutations.list, function(df) {
  df <- df/sum(df)
  df
})

# transform rownames to 1 column in all the samples
norm.mutations.dt.list <- copy(norm.mutations.list)
norm.mutations.dt.list <- lapply(norm.mutations.dt.list, setDT, keep.rownames = TRUE)
mutations.dt.list <- copy(mutations.list)
mutations.dt.list <- lapply(mutations.dt.list, setDT, keep.rownames = TRUE)
# Make the sample lists: 
##### LBR2 and DMSO #####
# Select the samples (in a ugly way but it works..)
samples.names <- names(norm.mutations.dt.list)
LBR2.64h.samples <- samples.names[-grep("si|NU|GSK|BIX|92|88|16|ODN3|GFP|LBR1|-guide", samples.names)]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2.64h.tib <- norm.mutations.dt.list[LBR2.64h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>% as.data.table()

LBR2.64h.reads <- total.reads.mutations.list[LBR2.64h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>% as.data.table()
dim(LBR2.64h.reads)

##### LBR2 #####
# Select the samples (in a ugly way but it works..)
samples.names <- names(norm.mutations.dt.list)
LBR2._.64h.samples <- samples.names[-grep("si|NU|GSK|BIX|92|88|16|ODN3|GFP|LBR1|-guide|DMSO", samples.names)]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2._.64h.tib <- norm.mutations.dt.list[LBR2._.64h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>% as.data.table()

LBR2._.64h.reads <- total.reads.mutations.list[LBR2._.64h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>% as.data.table()
dim(LBR2._.64h.reads)

#### DMSO ####
# Select the samples (in a ugly way but it works..)
samples.names <- names(norm.mutations.dt.list)
LBR2.DMSO.64h.samples <- samples.names[-grep("si|NU|GSK|BIX|92|88|16|ODN3|GFP|LBR1|-guide", samples.names)]
LBR2.DMSO.64h.samples <- LBR2.DMSO.64h.samples[grep("DMSO", LBR2.DMSO.64h.samples)]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2.DMSO.64h.tib <- norm.mutations.dt.list[LBR2.DMSO.64h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>% as.data.table()

LBR2.DMSO.64h.reads <- total.reads.mutations.list[LBR2.DMSO.64h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>% as.data.table()
dim(LBR2.DMSO.64h.reads)

##### LBR2 NU #####
# Select the samples (in a ugly way but it works..)
LBR2.NU7441.64h.samples <- samples.names[grep("NU", samples.names)]
LBR2.NU7441.64h.samples <- LBR2.NU7441.64h.samples[-grep("si|GSK|BIX|92|88|16|ODN3|GFP|LBR1|-guide", LBR2.NU7441.64h.samples)]
LBR2.NU7441.64h.list <- norm.mutations.dt.list[LBR2.NU7441.64h.samples]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2.NU7441.64h.tib <- norm.mutations.dt.list[LBR2.NU7441.64h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>% as.data.table()

LBR2.NU7441.64h.reads <- total.reads.mutations.list[LBR2.NU7441.64h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>%
  as.data.table()
dim(LBR2.NU7441.64h.reads)

##### LBR ssODN #####
# Select the samples (in a ugly way but it works..)
LBR2.ssODN.DMSO.64h.samples <- samples.names[grep("ODN3", samples.names)]
LBR2.ssODN.DMSO.64h.samples <- LBR2.ssODN.DMSO.64h.samples[-grep("si|NU|GSK|BIX|92|88|16|GFP", LBR2.ssODN.DMSO.64h.samples)]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2.ssODN.DMSO.64h.list <- norm.mutations.dt.list[LBR2.ssODN.DMSO.64h.samples]
LBR2.ssODN.DMSO.64h.tib <- norm.mutations.dt.list[LBR2.ssODN.DMSO.64h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>%
  as.data.table()

LBR2.ssODN.DMSO.64h.reads <- total.reads.mutations.list[LBR2.ssODN.DMSO.64h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>%
  as.data.table()
dim(LBR2.ssODN.DMSO.64h.reads)

##### LBR ssODN NU #####
# Select the samples (in a ugly way but it works..)
LBR2.ssODN.NU7441.64h.samples <- samples.names[grep("ODN3", samples.names)]
LBR2.ssODN.NU7441.64h.samples <- 
  LBR2.ssODN.NU7441.64h.samples[-grep("si|GSK|BIX|92|88|16|GFP|DMSO",
                                      LBR2.ssODN.NU7441.64h.samples)]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2.ssODN.NU7441.64h.list <- norm.mutations.dt.list[LBR2.ssODN.NU7441.64h.samples]
LBR2.ssODN.NU7441.64h.tib <- norm.mutations.dt.list[LBR2.ssODN.NU7441.64h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>% 
  as.data.table()

LBR2.ssODN.NU7441.64h.reads <- total.reads.mutations.list[LBR2.ssODN.NU7441.64h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>%
  as.data.table()
dim(LBR2.ssODN.NU7441.64h.reads)

##### LBR late #####
# Select the samples (in a ugly way but it works..)
LBR2.88h.samples <- samples.names[-grep("si|NU|GSK|BIX|64|16|ODN3|GFP|-guide|LBR1", 
                                        samples.names)]
LBR2.88h.samples <- LBR2.88h.samples[grep("88|92", LBR2.88h.samples)]
# take the samples - bind rows - remove NA's - group by barcode - sum the same barcodes - tib to DT
LBR2.88h.tib <- norm.mutations.dt.list[LBR2.88h.samples] %>% 
  bind_rows() %>% NAToZero() %>% group_by(rn) %>% summarise_all(.funs = sum) %>% as.data.table()

LBR2.88h.reads <- total.reads.mutations.list[LBR2.88h.samples] %>% 
  bind_rows() %>% group_by(barcode) %>% summarise_all(.funs = sum) %>%
  as.data.table()
dim(LBR2.88h.reads)

summed.indel.list <- list(LBR2.64h.tib,
                          LBR2._.64h.tib,
                          LBR2.DMSO.64h.tib,
                          LBR2.NU7441.64h.tib, 
                          LBR2.ssODN.DMSO.64h.tib, 
                          LBR2.ssODN.NU7441.64h.tib, 
                          LBR2.88h.tib)

names(summed.indel.list) <- c("indel_sum_AB_LBR2_64h",
                              "indel_sum_AB_LBR2_-_64h",
                              "indel_sum_AB_LBR2_DMSO_64h", 
                              "indel_sum_AB_LBR2_NU7441_64h", 
                              "indel_sum_AB_LBR2_ssODN3_DMSO_64h", 
                              "indel_sum_AB_LBR2_ssODN3_NU7441_64h", 
                              "indel_sum_AB_LBR2_88h")

summed.reads.list <- list(LBR2.64h.reads, 
                          LBR2._.64h.reads,
                          LBR2.DMSO.64h.reads, 
                          LBR2.NU7441.64h.reads, 
                          LBR2.ssODN.DMSO.64h.reads, 
                          LBR2.ssODN.NU7441.64h.reads, 
                          LBR2.88h.reads)

names(summed.reads.list) <- c("indel_sum_AB_LBR2_64h", 
                              "indel_sum_AB_LBR2_-_64h",
                              "indel_sum_AB_LBR2_DMSO_64h",
                              "indel_sum_AB_LBR2_NU7441_64h", 
                              "indel_sum_AB_LBR2_ssODN3_DMSO_64h", 
                              "indel_sum_AB_LBR2_ssODN3_NU7441_64h", 
                              "indel_sum_AB_LBR2_88h")

all.norm.mutations.dt.list <- c(summed.indel.list, norm.mutations.dt.list)

all.norm.reads.dt.list <- c(summed.reads.list, total.reads.mutations.list)

all.mutations.df.list <- lapply(all.norm.mutations.dt.list, function(x) {
  x <- as.data.frame(x)
  x <- x[ , mixedsort(colnames(x))]
  rownames(x) <- x[, "rn"]
  x$rn <- NULL
  x
})

# ### STILL WORKING ON THIS -- how to multiply each row by the same row in the other list.
all.norm.mutations.df.list <- mapply(function(x, y) {
  df <- x*y$sum
  df}, x = all.mutations.df.list, 
  y = all.norm.reads.dt.list) 

```


```{r}
total.reads.mutations.df <- ldply(all.norm.reads.dt.list, data.frame)
all.indels.norm.df <- ldply(all.norm.mutations.df.list, data.frame)
summarise(total.reads.mutations.df)
# Merge them all together


```


# Indel proportions data frame. 
We will not calculate the +1 / -7 ratios, we will count the proportion of -22, -14 -7, +1 and +2. I want to have the total insertions, total deletions and efficiences. 
```{r calculate_ratios}
RSTP2_2000_mutations.df <- total.reads.mutations.df
# Assing condition and plasmid tranfection from the sample names to a column.
RSTP2_2000_mutations.df$experiment <- gsub("indel_(.*?)_.*", "\\1", 
                                            RSTP2_2000_mutations.df$.id)
RSTP2_2000_mutations.df$condition <- gsub("indel_.*?_.*?_.*?_.*?(.*?)", "\\1", 
                                           RSTP2_2000_mutations.df$.id)
RSTP2_2000_mutations.df$plasmid <- gsub("indel_.*?_.*?_(.*?)_.*", "\\1", 
                                         RSTP2_2000_mutations.df$.id)
# Adding the timepoints
RSTP2_2000_mutations.df$time <- 64
RSTP2_2000_mutations.df$time[grep(".*_t16$", RSTP2_2000_mutations.df$.id)] <- 16
RSTP2_2000_mutations.df$time[grep(".*_t88$", RSTP2_2000_mutations.df$.id)] <- 88
RSTP2_2000_mutations.df$time[grep(".*_t92$", RSTP2_2000_mutations.df$.id)] <- 88

# Let's plot the distribution of the amount of reads per barcode
p <- ggplot(RSTP2_2000_mutations.df, aes(log10(sum)))
p + geom_density()

# We can repeat all this for the efficiencies. 
# Fist make one dataframe for all the effiencies, deletions and insertions
efficiency.df <- lapply(all.norm.mutations.df.list, CalculateEfficiencies) %>% 
  ldply(., data.frame)

deletions.df <- lapply(all.norm.mutations.df.list, CalculateDeletions) %>% 
  ldply(., data.frame)

insertions.df <- lapply(all.norm.mutations.df.list, CalculateInsertions) %>% 
  ldply(., data.frame)

# Calculate the proportion of some set indels
plus2.ratio.mutations.df <- lapply(all.norm.mutations.df.list, indel = 2, CalculateRatio) %>% 
  ldply(., data.frame)

plus1.ratio.mutations.df <- lapply(all.norm.mutations.df.list, indel = 1, CalculateRatio) %>%
  ldply(., data.frame)

min7.ratio.mutations.df <- lapply(all.norm.mutations.df.list, indel = -7, CalculateRatio) %>% 
  ldply(., data.frame)

min14.ratio.mutations.df <- lapply(all.norm.mutations.df.list, indel = -14, CalculateRatio) %>%
  ldply(., data.frame)

min22.ratio.mutations.df <- lapply(all.norm.mutations.df.list, indel = -22, CalculateRatio) %>%
  ldply(., data.frame)

# List all the data frames 
indel.ratios.list <- list(RSTP2_2000_mutations.df,
                          efficiency.df, 
                          insertions.df, 
                          deletions.df, 
                          plus2.ratio.mutations.df, 
                          plus1.ratio.mutations.df, 
                          min7.ratio.mutations.df, 
                          min14.ratio.mutations.df,
                          min22.ratio.mutations.df)

indel.ratios.df <- join_all(indel.ratios.list, 
                         by = c(".id", "barcode"),
                         match = "first")

dim(indel.ratios.df)
###
plus1.per.mutations.df <- lapply(all.norm.mutations.df.list, indel = 1, CalculatePercentage) %>% 
  ldply(., data.frame)

plus2.per.mutations.df <- lapply(all.norm.mutations.df.list, indel = 2, CalculatePercentage) %>%
  ldply(., data.frame)

min7.per.mutations.df <- lapply(all.norm.mutations.df.list, indel = -7, CalculatePercentage) %>%
  ldply(., data.frame)

###

plus1.min7.ratio.mutations.df <- lapply(all.norm.mutations.df.list, 
                                        indel1 = 1, 
                                        indel2 = -7, 
                                        CalculateRatio_internal) %>% 
  ldply(., data.frame)

plus1.plus2.ratio.mutations.df <- lapply(all.norm.mutations.df.list, 
                                         indel1 = 1, 
                                         indel2 = 2, 
                                         CalculateRatio_internal) %>% 
  ldply(., data.frame)

plus2.min7.ratio.mutations.df <- lapply(all.norm.mutations.df.list, 
                                        indel1 = 2, 
                                        indel2 = -7, 
                                        CalculateRatio_internal) %>% 
  ldply(., data.frame)

# Merge these with the large dataframe
indel.ratios.list <- list(indel.ratios.df,
                          plus2.per.mutations.df,
                          plus1.per.mutations.df,
                          min7.per.mutations.df,
                          plus1.min7.ratio.mutations.df,
                          plus1.plus2.ratio.mutations.df,
                          plus2.min7.ratio.mutations.df)

indel.ratios.df <- join_all(indel.ratios.list, 
                         by = c(".id", "barcode"),
                         match = "first")


# Rename the first column to sample
colnames(indel.ratios.df)[1] <- "sample"

head(indel.ratios.df)

# For the following operations it's better to work with a data table
tib_indel_ratios <- as_tibble(indel.ratios.df)
dim(tib_indel_ratios)

# Export it for the efficiency analysis. To test potential normalisation. 
setwd("/DATA/projects/DSBrepair/data/R/")

# The ratios data for the efficiency analysis
filename <- SetFileName("_total_indel_data.RData", "rs")
save(tib_indel_ratios, file = filename)
```

## Processed data export
The files will be saved in the processed data folder.
```{r export}
setwd("/DATA/projects/DSBrepair/data/R/")
# The mutations list that can be loaded for the indel spectra plots.
filename <- SetFileName("_All.IndelFreqData.RData", "rs")
save(all.norm.mutations.df.list, file = filename)

# The ratios data that can be loaded for the chromatin analysis.
filename <- SetFileName("_All.and.mean.Ratios.RData", "rs")
save(tib_indel_ratios, file = filename)
```
### Conclusions 
I'm happy with the output I've generated. I should still work on checking what the best amount of reads is that I need for correct correlations etc.
### Session Info
```{r session_info}
sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))

```

