---
title: "DSB Episcreen data analysis & plotting"
author: 
  - name: "Max Trauernicht"
    email: "m.trauernicht@nki.nl"
    affiliation: "Netherlands Cancer Institute"
date: '`r format(Sys.time(), "%d/%m/%Y")`'
output: 
  html_document:
    theme: united
    highlight: pygments
    fig_caption: yes
    code_folding: hide
    df_print: kable
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
---

*knitr document van Steensel lab*


# Introduction
Clone 5 with ~18 sgRNA target site integrations was cut and treated with 160 epigenetic drugs. The repair outcomes of that experiment will be visualized here. I previously processed the raw sequencing data, and calculated the repair outcomes. In this script, the main results plots will be generated.


## Setup {.tabset}

<!-- little HTML script to do indentation of the table of contents -->
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
      });

    });
</script>

```{css, echo = FALSE}
div.sourceCode {
  overflow-x: hidden;
}
```
### Libraries

```{r load_packages, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(dplyr)
library(outliers)
library(ggplot2)
library(ggbeeswarm)
library(data.table)
library(ggrepel)
library(GGally)
library(DESeq2)
library(gghighlight)
library(platetools)
library(ggpubr)
library(tidyr)
library(Laurae)
```

### Functions

```{r load_functions, echo = FALSE, warning = FALSE}

p.adjust <- function(p, method = p.adjust.methods, n = length(p))
{
    ## Methods 'Hommel', 'BH', 'BY' and speed improvements
    ## contributed by Gordon Smyth
    method <- match.arg(method)
    if(method == "fdr") method <- "BH"	# back compatibility
    nm <- names(p)
    p <- as.numeric(p)
    p0 <- setNames(p, nm)
    if(all(nna <- !is.na(p))) nna <- TRUE
    p <- p[nna]
    lp <- length(p)
    # stopifnot(n >= lp)
    if (n <= 1) return(p0)
    if (n == 2 && method == "hommel") method <- "hochberg"

    p0[nna] <-
	switch(method,
	       bonferroni = pmin(1, n * p),
	       holm = {
		   i <- seq_len(lp)
		   o <- order(p)
		   ro <- order(o)
		   pmin(1, cummax( (n - i + 1L) * p[o] ))[ro]
	       },
	       hommel = { ## needs n-1 >= 2 in for() below
		   if(n > lp) p <- c(p, rep.int(1, n-lp))
		   i <- seq_len(n)
		   o <- order(p)
		   p <- p[o]
		   ro <- order(o)
		   q <- pa <- rep.int( min(n*p/i), n)
		   for (j in (n-1):2) {
		       ij <- seq_len(n-j+1)
		       i2 <- (n-j+2):n
		       q1 <- min(j*p[i2]/(2:j))
		       q[ij] <- pmin(j*p[ij], q1)
		       q[i2] <- q[n-j+1]
		       pa <- pmax(pa,q)
		   }
		   pmax(pa,p)[if(lp < n) ro[1:lp] else ro]
	       },
	       hochberg = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( (n - i + 1L) * p[o] ))[ro]
	       },
	       BH = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   pmin(1, cummin( n / i * p[o] ))[ro]
	       },
	       BY = {
		   i <- lp:1L
		   o <- order(p, decreasing = TRUE)
		   ro <- order(o)
		   q <- sum(1L/(1L:n))
		   pmin(1, cummin(q * n / i * p[o]))[ro]
	       },
	       none = p)
    p0
}

SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# From Fede:
# ggpairs custom functions
corColor <- function(data, mapping, color = I("black"), sizeRange = c(1, 3), ...) {

  x   <- eval_data_col(data, mapping$x)
  y   <- eval_data_col(data, mapping$y)
  r   <- cor(x, y)
  rt  <- format(r, digits = 3)
  tt  <- as.character(rt)
  cex <- max(sizeRange)

  # helper function to calculate a useable size
  percent_of_range <- function(percent, range) {
    percent * diff(range) + min(range, na.rm = TRUE)
  }

  # plot correlation coefficient
  p <- ggally_text(label = tt, mapping = aes(), xP = 0.5, yP = 0.5,
                   size = I(percent_of_range(cex * abs(r), sizeRange)), color = color, ...) +
    theme(panel.grid.minor=element_blank(),
          panel.grid.major=element_blank())

  corColors <- RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")[2:6]

  if (r <= boundaries[1]) {
    corCol <- corColors[1]
  } else if (r <= boundaries[2]) {
    corCol <- corColors[2]
  } else if (r < boundaries[3]) {
    corCol <- corColors[3]
  } else if (r < boundaries[4]) {
    corCol <- corColors[4]
  } else {
    corCol <- corColors[5]
  }

  p <- p +
    theme(panel.background = element_rect(fill = corCol))

  return(p)
}


# stat_smooth_func <- function(mapping = NULL, data = NULL,
#                         geom = "smooth", position = "identity",
#                         ...,
#                         method = "auto",
#                         formula = y ~ x,
#                         se = TRUE,
#                         n = 80,
#                         span = 0.75,
#                         fullrange = FALSE,
#                         level = 0.95,
#                         method.args = list(),
#                         na.rm = FALSE,
#                         show.legend = NA,
#                         inherit.aes = TRUE,
#                         xpos = NULL,
#                         ypos = NULL) {
#   layer(
#     data = data,
#     mapping = mapping,
#     stat = StatSmoothFunc,
#     geom = geom,
#     position = position,
#     show.legend = show.legend,
#     inherit.aes = inherit.aes,
#     params = list(
#       method = method,
#       formula = formula,
#       se = se,
#       n = n,
#       fullrange = fullrange,
#       level = level,
#       na.rm = na.rm,
#       method.args = method.args,
#       span = span,
#       xpos = xpos,
#       ypos = ypos,
#       ...
#     )
#   )
# }
# 
# StatSmoothFunc <- ggproto("StatSmooth", Stat,
#                       
#                       setup_params = function(data, params) {
#                         # Figure out what type of smoothing to do: loess for small datasets,
#                         # gam with a cubic regression basis for large data
#                         # This is based on the size of the _largest_ group.
#                         if (identical(params$method, "auto")) {
#                           max_group <- max(table(data$group))
#                           
#                           if (max_group < 1000) {
#                             params$method <- "loess"
#                           } else {
#                             params$method <- "gam"
#                             params$formula <- y ~ s(x, bs = "cs")
#                           }
#                         }
#                         if (identical(params$method, "gam")) {
#                           params$method <- mgcv::gam
#                         }
#                         
#                         params
#                       },
#                       
#                       compute_group = function(data, scales, method = "auto", formula = y~x,
#                                                se = TRUE, n = 80, span = 0.75, fullrange = FALSE,
#                                                xseq = NULL, level = 0.95, method.args = list(),
#                                                na.rm = FALSE, xpos=NULL, ypos=NULL) {
#                         if (length(unique(data$x)) < 2) {
#                           # Not enough data to perform fit
#                           return(data.frame())
#                         }
#                         
#                         if (is.null(data$weight)) data$weight <- 1
#                         
#                         if (is.null(xseq)) {
#                           if (is.integer(data$x)) {
#                             if (fullrange) {
#                               xseq <- scales$x$dimension()
#                             } else {
#                               xseq <- sort(unique(data$x))
#                             }
#                           } else {
#                             if (fullrange) {
#                               range <- scales$x$dimension()
#                             } else {
#                               range <- range(data$x, na.rm = TRUE)
#                             }
#                             xseq <- seq(range[1], range[2], length.out = n)
#                           }
#                         }
#                         # Special case span because it's the most commonly used model argument
#                         if (identical(method, "loess")) {
#                           method.args$span <- span
#                         }
#                         
#                         if (is.character(method)) method <- match.fun(method)
#                         
#                         base.args <- list(quote(formula), data = quote(data), weights = quote(weight))
#                         model <- do.call(method, c(base.args, method.args))
#                         
#                         m = model
#                         eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
#                                          list(a = format(coef(m)[1], digits = 3), 
#                                               b = format(coef(m)[2], digits = 3), 
#                                               r2 = format(summary(m)$r.squared, digits = 3)))
#                         func_string = as.character(as.expression(eq))
#                         
#                         if(is.null(xpos)) xpos = min(data$x)*0.9
#                         if(is.null(ypos)) ypos = max(data$y)*0.9
#                         data.frame(x=xpos, y=ypos, label=func_string)
#                         
#                       },
#                       
#                       required_aes = c("x", "y")
# )

```


### Data import

```{r data import, echo = FALSE, warning = FALSE}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts")

# Import data from preprocessing script
indel.data.r1 <- get(load("mt20210504_drug_screen_mutations_rep1")) %>%
  mutate(biorep = "rep1")
indel.data.r2 <- get(load("mt20210504_drug_screen_mutations_rep2")) %>%
  mutate(biorep = "rep2")

integrations <- read.table("barcode_order.txt", header = T)

# Import viability data
viability.comp <- read.csv2("mt20200618_viability_rep1-2.csv") %>%
  setnames(".id", "id")
```


## Viability data

```{r, warning = FALSE}
# First combine the data from the two replicates
indel.data <- rbind(indel.data.r1, indel.data.r2)

# Add viability data to indel.data
viability.comp$id <- gsub("_[0-9]{3}$", "", viability.comp$id)
viability.rep1 <- viability.comp %>%
  dplyr::select(id, viability) %>%
  mutate(biorep = "rep1")
viability.rep2 <- viability.comp %>%
  dplyr::select(id, X) %>%
  setnames("X", "viability") %>% 
  mutate(biorep = "rep2")
viability.comp <- rbind(viability.rep1, viability.rep2)

indel.data$id <- gsub("_[0-9]{3}$", "", indel.data$id)
indel.data <- merge(viability.comp, indel.data, by = c("id", "biorep")) %>% 
  mutate(plate.id = gsub("(.*plate[1,2]).*", "\\1", id),
         viability = ave(viability, plate.id, biorep, FUN = function(x) x/max(x)))

indel.data$conc <- factor(indel.data$conc, levels = c("100nm", "1um", "10um"))

indel.data2 <- indel.data
indel.data2$group <- "drug"
indel.data2$group[indel.data2$drug == "DMSO"] <- "DMSO"
indel.data2$group[indel.data2$drug == "PAO"] <- "PAO"

indel.data2 <- indel.data2 %>%
  dplyr::select(viability, biorep, barcode, id, group, conc, drug, target) %>%
  spread(key = biorep, value = viability)

sp <- ggscatter(indel.data2, x = "rep1", y = "rep2",
                color = "group", size = 1.5, add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "viability episcreen rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")

sp + stat_cor(method = "pearson", label.x = 0, label.y = 0.15) + 
  geom_segment(x = 0.5, xend = 0.5, y = 0.5, yend = 1, linetype = "dashed") +
  geom_segment(x = 0.5, xend = 1, y = 0.5, yend = 0.5, linetype = "dashed") +
  facet_wrap(~conc) +theme_bw() +
  scale_color_manual(values = c("#2a9d8f", "black", "#e76f51"))

# Explore differences between rep 1 & rep 2
indel.data2 <- indel.data2 %>%
  mutate(dif = rep1 / rep2) %>%
  dplyr::select(dif, drug, target, conc, rep1, rep2) %>%
  unique()

indel.data2$changed <- "no"
indel.data2$changed[indel.data2$dif >= 2] <- "yes"

ggplot(indel.data2, aes(x = target, y = log2(dif))) +
  geom_quasirandom() +
  theme_bw() +
  ylab("log2(rep 1 viability / rep 2 viabilty)") +
  facet_wrap(~conc) +
  coord_flip()
```
Most of the wells that had a drastic drop in viability in rep 2 are not represented in the indel data - so they are excluded from these plots


## Data pre-processing

```{r pre-processing, warning = FALSE}
## save favorite colors
colors_diverse <- c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51") 

## Make some density plots to get a feeling for the data
indel.data <- merge(indel.data, integrations)
indel.data$integration <- factor(indel.data$integration, levels = c("Integration 1", "Integration 2", "Integration 3", "Integration 4", "Integration 5",
                                                                    "Integration 6", "Integration 7", "Integration 8", "Integration 9", "Integration 10",
                                                                    "Integration 11", "Integration 12", "Integration 13", "Integration 14", 
                                                                    "Integration 15", "Integration 16", "Integration 17", "Integration 18"))

# Save file before to filtering
indel.data <- indel.data %>%
  setnames(c("id"), c("condition"))
all.indel.data <- indel.data

# Remove barcodes with abnormal counts from analysis
# Density plot of reads.count using only PAO data -> these are the input reads
all.indel.data <- all.indel.data[!is.na(all.indel.data$barcode),]
ggplot(data = all.indel.data[all.indel.data$drug == c("DMSO"),] %>%
         dplyr::select(barcode, condition, read.count1.7, drug, biorep) %>%
         unique(), aes(x = read.count1.7, color = biorep, group = biorep)) + 
  geom_density() + 
  xlim(0,1000) +
  facet_wrap(~barcode, nrow = 6)+ 
  labs(title = "read count before cutting (PAO) and after cutting (DMSO)") + 
  theme_bw()+
  scale_color_manual(values = c("#2a9d8f", "black"))


# Remove two barcodes with abnormal indel read counts
indel.data <- indel.data[indel.data$barcode != "ACCCCTAAAGGCGCTG" &
                           indel.data$barcode != "CTCTTAATCGCTGCC",]

# Also remove "TGTCCCTTAGTACTTT"? - this one has a bit wider spread of DMSO indel scores (at least in rep 1)

# Remove 0, NAs, Infs
indel.data <- indel.data[is.finite(indel.data$MMEJscore),]
indel.data <- indel.data[indel.data$MMEJscore != 0,]

# Exclude noisy data - estimate fraction of what that is
ggplot(indel.data %>%
         dplyr::select(read.count1.7, biorep, barcode, condition, plate.id) %>%
         unique(), aes(color = biorep, x = read.count1.7)) +
  geom_density() +
  geom_vline(xintercept = 30) +
  facet_wrap(~plate.id) +
  xlim(0,500) +
  theme_bw()

# In some plates of rep 2 the reads peak at around 100 - is this a problem?

ggplot(indel.data %>%
         dplyr::select(read.count1.7, biorep, barcode, condition, plate.id) %>%
         unique(), aes(color = biorep, x = read.count1.7)) +
  geom_density() +
  geom_vline(xintercept = 30) +
  facet_wrap(~plate.id) +
  xlim(0,100) +
  theme_bw()

indel.data <- indel.data[indel.data$read.count1.7 > 30,]

# We want to exclude reads from cells that have reduced viability (set cut-off at 50% reduced viability)
indel.data <- indel.data[indel.data$viability > 0.5,]


# Optional: Exclude data completely (remove the remaining datapoint) if 2 out of 3 replicates were already excluded until now
## indel.data <- indel.data[indel.data$uniqueID %in% names(which(table(indel.data$uniqueID) > 1)), ]
```


## DMSO indel scores

```{r, warning = FALSE}
# Plot MMEJ scores at each barcode for the two bioreps
ggplot(indel.data %>% 
         dplyr::select(MMEJscore, condition, integration, drug, biorep) %>%
         filter(drug == "DMSO") %>%
         unique(), aes(x = integration, MMEJscore)) +
  geom_quasirandom() +
  theme_bw() +
  coord_flip() +
  facet_wrap(~biorep)

# Correlation DMSO MMEJ scores
indel.data.DMSO.rep <- indel.data %>% 
  dplyr::select(MMEJscore, condition, integration, drug, biorep, plate.id) %>%
  filter(drug == "DMSO") %>%
  dcast(condition + integration + drug + plate.id ~ biorep, value.var = "MMEJscore")

sp <- ggscatter(indel.data.DMSO.rep, x = "rep1", y = "rep2",
                size = 1.5, add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "MMEJscore rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")

sp + stat_cor(method = "pearson", label.x = 0, label.y = 0.6) + 
  facet_wrap(~plate.id) +theme_bw()
```



## Data normalization - normalize indel counts

```{r plate_normalization, warning = FALSE}
## Normalize the data

## Check if we have normally distributed DMSO data
qqnorm(indel.data$MMEJscore[indel.data$drug == "DMSO"])
qqnorm(indel.data$freqCut[indel.data$drug == "DMSO"])


# Plate normalization for cutting/repair efficiency
for (i in unique(indel.data$plate.id)) {
  for (j in unique(indel.data$barcode)) {
    for(k in unique(indel.data$biorep)) {
      dmso.eff.mean <- mean(indel.data$freqCut[indel.data$drug == "DMSO" & 
                                                 indel.data$plate.id ==  i & 
                                                 indel.data$barcode == j & 
                                                 indel.data$biorep == k])
  indel.data$freqCut_norm[indel.data$plate.id == i & indel.data$barcode == j & indel.data$biorep == k] <-
    indel.data$freqCut[indel.data$plate.id == i & indel.data$barcode == j & indel.data$biorep == k] / dmso.eff.mean
    }
  }
}


## MMEJscore z-score
for (i in unique(indel.data$drug)) {
  for (j in unique(indel.data$conc)) {
    for (k in unique(indel.data$biorep)) {
    indel.data$MMEJ_zscore[indel.data$drug == i & indel.data$conc == j & indel.data$biorep == k] <-
      (indel.data$MMEJscore[indel.data$drug == i & indel.data$conc == j & indel.data$biorep == k] -
      mean(indel.data$MMEJscore[indel.data$drug == "DMSO" & indel.data$conc == j & indel.data$biorep == k])) / 
      sd(indel.data$MMEJscore[indel.data$drug == "DMSO" & indel.data$conc == j & indel.data$biorep == k])
    }
  }
} 

indel.data <- indel.data %>%
  mutate(MMEJ_zscore_mean_bio = ave(MMEJ_zscore, integration, drug, conc, biorep, FUN = function(x) mean(x)),
         MMEJ_zscore_mean = ave(MMEJ_zscore_mean_bio, integration, drug, conc, FUN = function(x) mean(x)))

indel.data <- indel.data %>%
  mutate(freqCut_norm_mean_bio = ave(freqCut_norm, integration, drug, conc, biorep, FUN = function(x) mean(x)),
         freqCut_norm_mean = ave(freqCut_norm_mean_bio, integration, drug, conc, FUN = function(x) mean(x)))


indel.data <- indel.data %>%
  mutate(MMEJ_zscore_mean_bio_drug = ave(MMEJ_zscore_mean_bio, drug, conc, biorep, FUN = function(x) mean(x)),
         freqCut_norm_mean_bio_drug = ave(freqCut_norm_mean_bio, drug, conc, biorep, FUN = function(x) mean(x)))
```


## Drug effects per target group

```{r Quality check data, warning = FALSE}
# Density plot logratio of the controls
ggplot(data = indel.data[indel.data$drug == c("DMSO","DNA-PKi","Mirin"),], 
       aes(x = MMEJ_zscore, color = target)) + 
  theme_bw() +
  geom_density() + 
  xlab("MMEJ z-score") +
  facet_wrap(~biorep) +
  scale_color_manual(values = colors_diverse)

# Beeswarm plot of MMEJ score of the controls at all IPRs
ggplot(data = indel.data[indel.data$drug == "DMSO",], 
       aes(y = MMEJscore, x = integration)) + theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0.5)) + 
  geom_quasirandom(dodge.width = 0.75) +
  geom_boxplot(position = position_dodge(0.75), alpha = 0.7)+ xlab("integration") + 
  labs(title = "MMEJ score of DMSO-treated cells") +
  facet_wrap(~biorep)

# Beeswarm plot of MMEJ score of all drugs, highlighting controls
ggplot(data = indel.data %>%
         dplyr::select(MMEJ_zscore_mean_bio, sample, drug, conc, integration, biorep) %>%
         unique(), 
       aes(y = MMEJ_zscore_mean_bio, x = 'x', color = sample)) + theme_bw() +
  geom_quasirandom(dodge.width = 0.75) +
  geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
  xlab("") + ylab("MMEJ score") +
  scale_color_manual(values = colors_diverse) +
  facet_grid(biorep~conc)

# Integral of MMEJ-zscore density plot per target group
ggplot(data = indel.data, 
       aes(x = MMEJ_zscore)) +
  xlab("logratio") + ylab("acumulative value")+ stat_ecdf(aes(colour = target))+ theme_classic() +
  labs(title = "accumulative logratio of all targets") + facet_wrap(~biorep)

# Integral of freqCut density plot
ggplot(data = indel.data, 
       aes(x = freqCut)) +
  xlab("efficiency: normalized over plate") + stat_ecdf(aes(colour = target))+ theme_classic() +
  labs(title = "integral of efficiency density")

# Total amount of drugs per target group
ggplot(indel.data, aes(x = reorder(target,target, function(x)-length(x)))) +
  geom_bar()+theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12))+ 
  ylab("datapoints") + xlab("target group")+ labs(title = "datapoints per target group")


indel.data2 <- indel.data %>% 
  mutate(MMEJ_zscore_mean = ave(MMEJ_zscore_mean_bio, biorep, conc, drug, FUN = function (x) mean(x))) %>%
  dplyr::select(MMEJ_zscore_mean, conc, target, drug, biorep) %>%
  unique()
indel.data2$zscore_change <- "<1"
indel.data2$zscore_change[abs(indel.data2$MMEJ_zscore_mean)>0.5] <- "0.5-1.5"
indel.data2$zscore_change[abs(indel.data2$MMEJ_zscore_mean)>1.5] <- ">1.5"
indel.data2 <- indel.data2 %>%
  mutate(size = ave(target, target, zscore_change, FUN = function(x) length(x)),
         total_size = ave(target, target, FUN = function(x) length(x)))


ggplot(indel.data2 %>%
         dplyr::select(target, size, zscore_change, conc, total_size, biorep) %>%
         unique(), aes(x = reorder(target, as.numeric(total_size)), 
                   y = as.numeric(size), 
                       fill = zscore_change)) + 
      geom_bar(stat="identity") +
    labs(fill = "z-score")+
  scale_fill_manual(values = colors_diverse[seq(1, length(colors_diverse), 2)])+
  coord_flip()+ theme_bw() +
  ylab("Amount of drugs per Category") + theme(axis.title.y = element_blank())+
  theme(text = element_text(size = 14), axis.text.y = element_text(size = 12))+
  facet_grid(biorep~conc)
```



## Correlation plots

```{r correlation plots, warning = FALSE}
# Visualize logratio change and efficiency change in one plot to spot outliers
indel.data2 <- indel.data %>% 
  dplyr::select(drug, conc, biorep, MMEJ_zscore_mean_bio_drug, freqCut_norm_mean_bio_drug) %>%
  filter(drug != "DNA-PKi")
indel.data2 <- unique(indel.data2)

ggplot(indel.data2, aes(x = MMEJ_zscore_mean_bio_drug, y = log2(freqCut_norm_mean_bio_drug))) +
  geom_point(color = ifelse(abs(indel.data2$MMEJ_zscore_mean_bio_drug) > 1, "black", "grey"))+
  xlab("MMEJ z-score") + ylab("Efficiency relative to DMSO (log2)") +
  #gghighlight(abs(mean.MMEJ_zscore.drug) > 5, label_key = drug) + 
  theme_bw() +
  theme(text = element_text(size = 14)) +
  facet_grid(biorep~conc)


# Correlation plot mean viability vs. mean efficiency
indel.data$mean.viability.drug = 
  ave(indel.data$viability, indel.data$drug, indel.data$conc, FUN = function(x) mean(x))

indel.data2 <- indel.data %>% 
  dplyr::select(drug, conc, biorep, mean.viability.drug, freqCut_norm_mean_bio_drug) %>% unique()

ggplot(indel.data2, aes(x = mean.viability.drug, y = log2(freqCut_norm_mean_bio_drug))) +
  geom_point(color = ifelse(abs(log2(indel.data2$freqCut_norm_mean_bio_drug)) > 0.2 , "black", "grey")) +
  xlab("Viability") + ylab("Cutting Efficiency Change") +
  #gghighlight(abs(mean.efficiency_zscore.drug) > 0.1, label_key = drug) + 
  theme_bw() +
  theme(text = element_text(size = 14)) +
  facet_grid(biorep~conc)


# Correlation plot mean viability vs. mean ratio
indel.data2 <- indel.data %>% 
  dplyr::select(drug, conc, MMEJ_zscore_mean_bio_drug, mean.viability.drug, biorep) %>% 
  filter(drug != "DNA-PKi") %>% 
  unique()

ggplot(indel.data2, aes(x = MMEJ_zscore_mean_bio_drug, y = mean.viability.drug)) +
  geom_point(color = ifelse(abs(indel.data2$MMEJ_zscore_mean_bio_drug) > 1, "black", "grey")) +
  xlab("MMEJ z-score") + ylab("Viability") +
  #gghighlight(abs(mean.MMEJ_zscore.drug) > 1.5, label_key = drug) + 
  theme_bw() +
  theme(text = element_text(size = 14)) +
  facet_wrap(~conc, nrow = 1, ncol = 3)


ggplot(indel.data2[indel.data2$drug != "DNA-PKi",], aes(x = MMEJ_zscore_mean_bio_drug, y = mean.viability.drug)) +
  geom_point()+
  xlab("MMEJ z-score") + ylab("Viability")+
  geom_smooth(method = lm, color = "grey") +
  theme(text = element_text(size = 14))+
  facet_wrap(~conc, nrow = 1, ncol = 3)+
  theme_bw()
# Do we need a more stringent viability cutoff? 0.7?




# Correlation plots of the replicates
indel.data2 <- indel.data[-grep("DNA-PK|DMSO", indel.data$drug),]
indel.data.rep1 <- indel.data2 %>%
  filter(rep == 'R1') %>%
  dplyr::select(barcode, biorep, drug, conc, 'R1' = MMEJ_zscore)
indel.data.rep2 <- indel.data2 %>%
  filter(rep == 'R2') %>%
  dplyr::select(barcode, biorep, drug, conc, 'R2' = MMEJ_zscore)
indel.data.rep3 <- indel.data2 %>%
  filter(rep == 'R3') %>%
  dplyr::select(barcode, biorep, drug, conc, 'R3' = MMEJ_zscore)

indel.data.rep <- merge(indel.data.rep1, indel.data.rep2, all = T)
indel.data.rep <- merge(indel.data.rep, indel.data.rep3, all = T)

# Correlation matrix plot
correlation.plot.rep1 <- indel.data.rep %>% 
  filter(biorep == "rep1") %>%
  dplyr::select(R1, R2, R3) %>% 
  na.omit()

correlation.plot.rep2 <- indel.data.rep %>% 
  filter(biorep == "rep2") %>%
  dplyr::select(R1, R2, R3) %>% 
  na.omit()

n <- sample(1:nrow(indel.data), 5000)
boundaries <- seq(from = 0.7, by = 0.05, length.out = 4)
plt_biorep1 <- ggpairs(correlation.plot.rep1,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") +
                   theme_bw()}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") +
                   theme_bw()})) +
  ggtitle("Correlation Between Technical Replicates - Biorep 1") +
  theme(text = element_text(size = 20))+
  xlab("MMEJ z-score") +
  ylab("MMEJ z-score") 
  # theme_bw()

plt_biorep2 <- ggpairs(correlation.plot.rep2,
               upper = list(continuous = corColor),
               lower = list(continuous = function(data, mapping, ...) {
                   ggally_points(data = data[n, ], mapping = mapping, alpha = 0.1, size = 0.5) +
                   geom_abline(slope = 1, lty = "dashed", col = "red") +
                   theme_bw()}),
               diag = list(continuous = function(data, mapping, ...) {
                   ggally_densityDiag(data = data, mapping = mapping, alpha = 0.3, fill = "red") +
                   theme_bw()})) +
  ggtitle("Correlation Between Technical Replicates - Biorep 2") +
  theme(text = element_text(size = 20))+
  xlab("MMEJ z-score") +
  ylab("MMEJ z-score") 
  # theme_bw()

print(plt_biorep1)
print(plt_biorep2)



# Correlation between biological replicates
indel.data2 <- indel.data[-grep("DNA-PK|DMSO", indel.data$drug),] %>%
  dplyr::select(MMEJ_zscore_mean_bio_drug, biorep, drug, conc) %>%
  unique() %>%
  spread(key = biorep, value = MMEJ_zscore_mean_bio_drug)

sp <- ggscatter(indel.data2, x = "rep1", y = "rep2",
                size = 1.5, add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "mean drug effects on MMEJ-zscore rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")

sp + stat_cor(method = "pearson", label.x = -2, label.y = 1) + 
  facet_wrap(~conc) +theme_bw() 


# Correlation between biological replicates
indel.data2 <- indel.data[-grep("DNA-PK|DMSO", indel.data$drug),] %>%
  dplyr::select(freqCut_norm_mean_bio_drug, biorep, drug, conc) %>%
  mutate(freqCut_norm_mean_bio_drug = log2(freqCut_norm_mean_bio_drug)) %>%
  unique() %>%
  spread(key = biorep, value = freqCut_norm_mean_bio_drug)

sp <- ggscatter(indel.data2, x = "rep1", y = "rep2",
                size = 1.5, add = "reg.line",
   add.params = list(color = "blue", fill = "lightgray"), title = "mean drug effects on efficiency rep 1 vs. rep 2",
   conf.int = TRUE, ylab = "rep 2", xlab = "rep 1")

sp + stat_cor(method = "pearson", label.x = -0.1, label.y = 0.25) + 
  facet_wrap(~conc) +theme_bw() 
```



## Locally vs. globally acting drugs

```{r, warning = FALSE}
# Plotting the MMEJ z-score against the SD in the MMEJ z-score between the 18 IPRs
ggplot(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(MMEJ_zscore_sd_bio_drug = ave(MMEJ_zscore_mean_bio, drug, conc, FUN = function(x) sd(x))) %>%
         dplyr::select(MMEJ_zscore_mean_bio_drug, MMEJ_zscore_sd_bio_drug, drug, conc, biorep) %>%
         unique(),
       aes(x = MMEJ_zscore_mean_bio_drug, y = MMEJ_zscore_sd_bio_drug)) +
  geom_point() +
  theme_bw() +
  xlab("MMEJ z-score per drug") +
  ylab("MMEJ z-score sd of integrations") +
  facet_grid(biorep~conc)

ggplot(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(MMEJ_zscore_sd_bio_drug = ave(MMEJ_zscore_mean_bio, drug, conc, FUN = function(x) sd(x)),
                sd_percentage = 100* (MMEJ_zscore_sd_bio_drug / MMEJ_zscore_mean_bio_drug)) %>%
         dplyr::select(sd_percentage, drug, conc, target, biorep) %>%
         unique(),
       aes(x = target, y = sd_percentage)) +
  geom_quasirandom() +
  geom_hline(yintercept = 15, linetype = "dashed") +
  ylab("MMEJ score: SD of 18 IPRs relative to mean (%)") +
  theme_bw() +
  facet_grid(biorep~conc) +
  coord_flip()

ggplot(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(MMEJ_zscore_sd_bio_drug = ave(MMEJ_zscore_mean_bio, drug, conc, FUN = function(x) sd(x))) %>%
         dplyr::select(MMEJ_zscore_sd_bio_drug, drug, conc, target, biorep) %>%
         unique(),
       aes(x = target, y = MMEJ_zscore_sd_bio_drug)) +
  geom_quasirandom() +
  ylab("MMEJ score: SD of 18 IPRs ") +
  geom_hline(yintercept = 0.125, linetype = "dashed") +
  theme_bw() +
  facet_grid(biorep~conc) +
  coord_flip()

ggplot(indel.data %>%
         filter(drug != "DNA-PKi", target != "Negative Control", target != "MRN") %>%
         mutate(freqCut_norm_sd_bio_drug = ave(freqCut_norm_mean_bio_drug, drug, conc, FUN = function(x) sd(x))) %>%
         dplyr::select(freqCut_norm_sd_bio_drug, drug, conc, target, biorep) %>%
         unique(),
       aes(x = target, y = freqCut_norm_sd_bio_drug)) +
  geom_quasirandom() +
  ylab("efficiency: SD of 18 IPRs ") +
  geom_hline(yintercept = 0.03, linetype = "dashed") +
  theme_bw() +
  facet_grid(biorep~conc) +
  coord_flip()
```



## Spotting outliers
```{r, warning = FALSE}
# # Spot individual drug outliers per concentration
# indel.data2 <- indel.data
# indel.data2$MMEJ_zscore <- ave(indel.data2$MMEJ_zscore, indel.data2$conc, indel.data2$drug, FUN = function(x) mean(x))
# indel.data2 <- indel.data2 %>% dplyr::select(drug, conc, MMEJ_zscore)
# indel.data2 <- indel.data2[!duplicated(indel.data2),]
# indel.data2$conc <- factor(indel.data2$conc, levels=c("100nm", "1um", "10um"))
# 
# ggplot(indel.data2 %>%
#          filter(drug != "DNA-PKi"), aes(x=conc, y=MMEJ_zscore)) +
#   geom_quasirandom() + 
#   gghighlight(abs(MMEJ_zscore) > 6, label_key = drug) + theme_bw()
#   
# # The same but only the range between 1 & 2
# ggplot(indel.data2[abs(indel.data2$MMEJ_zscore) < 2,], aes(x=conc, y=MMEJ_zscore)) +
#   geom_quasirandom() + 
#   gghighlight(abs(MMEJ_zscore) > 1.7, label_key = drug) + theme_bw()
# 
# # Spot outliers by plotting DMSO versus drugs
# indel.data2 <- indel.data
# indel.data2$mean.ratio.bc.drug.conc <- ave(indel.data2$efficiency, 
#                                            indel.data2$conc, indel.data2$drug, 
#                                            indel.data2$barcode, FUN = function(x) mean(x))
# indel.data2 <- indel.data2 %>% dplyr::select(barcode, drug, conc, mean.ratio.bc.drug.conc)
# indel.data2 <- indel.data2[!duplicated(indel.data2),]
# indel.data2.high <- indel.data2[grep("1um", indel.data2$conc),]
# indel.data2.high <- indel.data2.high[,-3]
# 
# indel.data2.high <- dcast(indel.data2.high, barcode ~ drug, value.var = "mean.ratio.bc.drug.conc")
# 
# 
# gghighlight_point(indel.data2.high, aes(x = DMSO, y = `Vorinostat (SAHA, MK0683)`), `Vorinostat (SAHA, MK0683)` - DMSO > 0.1) +
#   geom_abline(intercept = 0, slope = 1) +
#   geom_abline(intercept = 0.1, slope = 1, linetype = "dashed") +
#   geom_abline(intercept = - 0.1, slope = 1, linetype = "dashed") +
#   geom_text(aes(x = 0.4, y = 0.32, label = "-10% efficiency", angle = 35)) +
#   geom_text(aes(x = 0.4, y = 0.52, label = "+10% efficiency", angle = 35)) +
#   scale_x_continuous(limits = c(0.25, 1)) +
#   scale_y_continuous(limits = c(0.25, 1)) +
#   labs(title = "Efficiency compared to DMSO for each integration") + theme_bw()
# 
# # Make a beeswarm plot with alternative colors for outliers based on chi square scores
# ggplot(data = indel.data) +
#   geom_quasirandom(mapping = 
#                      aes(x = reorder(integration, order), y = logratio.mean, 
#                          colour = ifelse(p.value > 0.05,
#                                          "non-outlier","outlier")), alpha = 0.5) + theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
#   ylab("log2(+1/-7 ratio)") + xlab("integration") + 
#   labs(title = "Outlier plot", colour = "Outlier based on p value < 0.05") + 
#   scale_color_manual(values=c("#999999", "#E69F00"))
# 
# 
# 
# # Boxplot of logratio 
# indel.data$cluster <- "Active Promoter/Enhancer" 
# indel.data$cluster[indel.data$order == "3" | 
#                       indel.data$order == "4"] <- "H3K9me2/3 Domain"
# indel.data$cluster[indel.data$order == "5" | 
#                       indel.data$order == "6" |
#                       indel.data$order == "7" | 
#                       indel.data$order == "8"] <- "Active Gene Body"
# indel.data$cluster[indel.data$order == "9" | 
#                       indel.data$order == "10" |
#                       indel.data$order == "11" | 
#                       indel.data$order == "12"] <- "LAD"
# indel.data$cluster[indel.data$order == "13" | 
#                       indel.data$order == "14"] <- "No Chromatin Marks"
# indel.data$cluster[indel.data$order == "15" | 
#                       indel.data$order == "16" |
#                       indel.data$order == "17" | 
#                       indel.data$order == "18"] <- "H3K27me3 Domain"
# 
# ggplot(data = indel.data[indel.data$drug != "DMSO",],
#        aes(x = reorder(integration, order),
#            y = efficiency_zscore)) +
#   geom_quasirandom(color = ifelse(indel.data[indel.data$drug != "DMSO",]$efficiency_zscore > 2 | 
#                                     indel.data[indel.data$drug != "DMSO",]$efficiency_zscore < -2, 
#                                   "#343a40", "#6c757d")) +
#   ylab("MMEJ score")+
#   scale_fill_brewer(palette = "Pastel2")+
#   xlab("") +
#   theme_bw()+
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+
#   theme(axis.title.x = element_blank()) +
#   coord_flip()
# 
# # Are the logratios of the different barcode clusters different?
# indel.data2$int <- "1"
# indel.data2$int[indel.data2$order >= 9] <- "2"
# indel.data2$logratio <- ave(indel.data2$logratio, 
#                             indel.data2$integration, 
#                             indel.data2$rep, 
#                             FUN = function(x) mean(x))
# indel.data2 <- indel.data2 %>% dplyr::select(rep, logratio, int, integration) %>% unique()
# indel.data2$mean <- ave(indel.data2$logratio,
#                         indel.data2$int, 
#                         indel.data2$rep,
#                         FUN = function(x) mean(x))
# indel.data2$sd <- ave(indel.data2$logratio, 
#                       indel.data2$int, 
#                       indel.data2$rep,
#                       FUN = function(x) sd(x))
# indel.data2$p.value <- t.test(indel.data2$mean[indel.data2$int == 1], indel.data2$mean[indel.data2$int == 2])$p.value
# indel.data2$mean.bio <- ave(indel.data2$mean,
#                         indel.data2$int, 
#                         FUN = function(x) mean(x))
# indel.data2$sd.bio <- ave(indel.data2$logratio, 
#                       indel.data2$int, 
#                       FUN = function(x) sd(x))
# 
# 
# # Boxplot of efficiencies normalized
# ggplot(data = indel.data[indel.data$drug == "DMSO",]) +
#   geom_boxplot(mapping = aes(x = reorder(integration,order), y = efficiency.platenorm)) + theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
#   labs(title = "Efficiency distribution per integration after normalization") 
# 
# # Beeswarm plot of efficiencies
# ggplot(data = indel.data) +
#   geom_quasirandom(mapping = 
#                      aes(x = reorder(integration,order), y = efficiency.mean, 
#                          colour = ifelse(p.value > 0.05,
#                                          "non-outlier","outlier"))) + theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) + 
#   ylab("efficiency") + xlab("integration") + labs(title = "Efficiency plot, outliers (based on logratio) in yellow", colour = "Logratio outlier based on p value < 0.05") + scale_color_manual(values=c("#999999", "#E69F00"))
# 
# 
# # Make a loop of plots, plotting the ratio per drug target group together with DMSO
# for (i in unique(indel.data$target)) {
#   data <- indel.data[indel.data$target == i | indel.data$target == "Negative Control", ]
#   p <- ggplot(data = data) +
#     geom_quasirandom(mapping = aes(x = reorder(integration,order), y = MMEJ_zscore, colour = target), alpha = 0.8, dodge.width = -0.5) + theme_bw() +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0))+ 
#     ylab("log2(+1/-7 ratio)") + xlab("integration")+ labs(title= paste("logratio of",i, "compared to DMSO"))
#   print(p)
# }
# 
# 
# # Aurora Kinase only
# indel.data.med <- indel.data[indel.data$conc == "1um",]
# aurora.dmso <- indel.data.med[indel.data.med$drug == "DMSO" | indel.data.med$target == "Aurora Kinase",]
# aurora.dmso$target <- factor(aurora.dmso$target, levels = c("Negative Control", "Aurora Kinase"))
# ggplot(data =  aurora.dmso) +
#     geom_quasirandom(aes(x = reorder(integration,order), y = MMEJ_zscore, colour = target, group = target), 
#                      alpha = 0.8, dodge.width = -0.5, width = 0.1) + 
#   scale_colour_brewer(palette = "Set2")+
#   coord_flip()+
#   theme(axis.title.y = element_blank())+
#     ylab("Change log2(+1/-7 ratio)")+
#   theme(text = element_text(size = 14))+
#   geom_hline(yintercept = 1, linetype = "dashed", alpha = 0.5)+
#   theme_classic2()
# 
# 
# # Decitabine only
# decitabine.dmso <- indel.data[indel.data$drug == "DMSO" | 
#                                 indel.data$drug == "Decitabine",]
# decitabine.dmso$drug <- factor(decitabine.dmso$drug, levels = c("DMSO", "Decitabine"))
# decitabine.dmso$conc <- factor(decitabine.dmso$conc, levels = c("100nm", "1um", "10um"))
# 
# ggplot(decitabine.dmso, aes(x = reorder(integration,order), 
#                             y = MMEJ_zscore, 
#                             colour = drug, group = drug,
#                             dodge.width = -0.5,
#                             width = 0.1)) +
#     geom_quasirandom() + 
#   scale_colour_brewer(palette = "Set2") +
#   coord_flip() +
#   theme(axis.title.y = element_blank()) +
#   ylab("MMEJ z-score") +
#   xlab("") +
#   theme(text = element_text(size = 14)) +
#   geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
#   theme_bw() + facet_wrap(~conc)
# 
# # HDACs (efficiency and logratio)
# hdac.dmso <- indel.data[indel.data$drug == "Vorinostat (SAHA, MK0683)"|
#                           indel.data$drug == "Givinostat (ITF2357)"|
#                           indel.data$drug == "PCI-24781 (Abexinostat)"|
#                           indel.data$drug == "AR-42"|
#                           indel.data$drug == "Scriptaid ",]
# hdac.dmso <- hdac.dmso[hdac.dmso$conc == "1um",]
# 
# hdac.dmso$MMEJ_zscore <- ave(hdac.dmso$MMEJ_zscore, 
#                              hdac.dmso$barcode, hdac.dmso$drug,
#                              FUN = function(x) mean(x))
# hdac.dmso$efficiency_zscore <- ave(hdac.dmso$efficiency_zscore, 
#                                     hdac.dmso$barcode, hdac.dmso$drug,
#                                     FUN = function(x) mean(x))
# 
# 
# hdac.dmso <- hdac.dmso %>% dplyr::select(drug, MMEJ_zscore, 
#                                   efficiency_zscore, order, 
#                                   integration) %>% unique()
# hdac.dmso$mean <- ave(hdac.dmso$MMEJ_zscore, hdac.dmso$integration,
#                       FUN = function(x) mean(x))
# hdac.dmso$mean2 <- ave(hdac.dmso$efficiency_zscore, hdac.dmso$integration,
#                       FUN = function(x) mean(x))
# 
# ggplot() +
#   geom_bar(data = hdac.dmso %>%
#              dplyr::select(mean, integration, order) %>%
#              unique(), stat="identity", aes(x =  reorder(integration,order), y = mean, alpha = 0.2)) +
#   geom_point(data = hdac.dmso, aes(x = reorder(integration,order), y = MMEJ_zscore, color = drug)) + 
#   scale_colour_brewer(palette = "Set2")+
#   coord_flip()+
#   theme(axis.title.y = element_blank())+
#   ylab("MMEJ z-score")+
#   xlab("") +
#   theme(text = element_text(size = 14))+
#   theme_bw()
# 
# ggplot() +
#   geom_bar(data = hdac.dmso %>%
#              dplyr::select(mean2, integration, order) %>%
#              unique(), stat="identity", aes(x =  reorder(integration,order), y = mean2, alpha = 0.2)) +
#   geom_point(data = hdac.dmso, aes(x = reorder(integration,order), y = efficiency_zscore, color = drug)) + 
#   scale_colour_brewer(palette = "Set2")+
#   coord_flip()+
#   theme(axis.title.y = element_blank())+
#   ylab("efficiency z-score")+
#   xlab("") +
#   theme(text = element_text(size = 14))+
#   theme_bw()
# 
# # Statistical significance? Is integration 17 different?
# anova <- aov(MMEJ_zscore ~ integration, data = hdac.dmso)
# summary.aov(anova)
# tukey <- TukeyHSD(anova)
# 
# # Make plots for all HDACs at the three concentrations
# indel.data$conc <- factor(indel.data$conc, levels = c("100nm", "1um", "10um"))
# ggplot(indel.data %>%
#          filter(target == "HDAC" | drug == "DMSO"),
#        aes(x = reorder(integration, order), y = efficiency_zscore, color = target)) +
#   geom_quasirandom(dodge.width = 0.75) +
#   geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
#   theme_bw() +
#   xlab("") +
#   scale_color_manual(values = colors_diverse) +
#   facet_wrap(~conc) +
#   coord_flip()
# 
# # only at the specific domains
# indel.data$cluster2 <- "open" 
# indel.data$cluster2[indel.data$order == "9" | 
#                       indel.data$order == "10" |
#                       indel.data$order == "11" | 
#                       indel.data$order == "12" |
#                      indel.data$order == "13" | 
#                       indel.data$order == "14" |
#                      indel.data$order == "15" | 
#                       indel.data$order == "16" |
#                       indel.data$order == "17" | 
#                       indel.data$order == "18"] <- "condensed"
# 
# # Include detailed HDAC annotation
# hdac_annotation <- read.csv2("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/HDAC_categories.csv") %>%
#   dplyr::select(drug, Categorie)
# indel.data.hdac <- indel.data %>%
#   filter(target == "HDAC" | drug == "DMSO")
# indel.data.hdac <- merge(indel.data.hdac, hdac_annotation, all = T)
# 
# ggplot(indel.data.hdac[!is.na(indel.data.hdac$conc),] %>%
#          filter(Categorie %in% c("HDAC1", "HDAC3", "DMSO")),
#        aes(x = Categorie, y = efficiency_zscore, color = cluster2)) +
#   geom_quasirandom(dodge.width = 0.75) +
#   geom_boxplot(position = position_dodge(0.75), alpha = 0.4) +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0.5)) + 
#   xlab("") +
#   scale_color_manual(values = colors_diverse) +
#   facet_wrap(~conc)
```



```{r export}
setwd("/DATA/usr/m.trauernicht/projects/EpiScreen/files_scripts/")
filename <- SetFileName("_indel.data", "mt")
save(indel.data, file = filename)
```

# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

