---
title: "Indels Preprocessing"
author: "Ruben Schep"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---

knitr document van Steensel lab

# Preprocessing of the indel data
# Introduction

In this script I want to prepocess the datafiles into several working dataframes. 

I want one data frame in which I have the number of mutations, per sample, per barcode per indel size.
This one will be used for plotting indel patterns, calculating ratios later on and such.

I want one dataframe that contains the ratios of each barcode in each sample. These ratios will be : 
This could be a long dataframe, with the following variables: Barcode, sample, ratios ...
* Efficiency (All mutations / Total or (Total - WT sequences) / Total)
* +1 / -7
* Deletions / Total
* Insertions / Total
* +1 / (-7 + -14 + -22)
* Barcode effiency vs Overall efficiency
In this dataframe I would also like to have the means of the samples (here I will ignore the inhibitor treated ones)
* Mean ratio
* Total reads
* Mean reads
* Median reads

## Description of Data

For this analysis we need the mapping and the indel data of the TRIP integrations. These 
files are obtained with the crispr_trip.snake script that C. Leemans edited. This data 
contains the genomic locations of the TRIP integrations (hg38) and the indel frequencies 
at each integration.

The mutations were called by counting the distance between two constant regions. These
were separated by barcode. The barcodes were also filtered on the starcode, to pick out
the most abundant, and considered real, ones.

Mutations files : *genuine_mapped.table

| barcode  | type | score | 
| ------- | --------- | ----- | 
| TTCTATTCGCACACAA | ins | 1 |
| TTTCCCACATCAGGAG | wt | 0 |
| CCATAGTAGTGATTAC | del | -4 |

# Data importing and processing
## Path, Libraries, Parameters and Useful Functions
```{r setup}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),3,8) 

# libraries:
library(rtracklayer)
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(ggplot2)

```
## Custom functions
Functions used
```{r functions}
MutationsToDataframe <- function(mutations) {
  # This function does
  
  tmp <- as(table(mutations[, c(1,3)]), "matrix")
  n <- colnames(tmp)
  tmp <- data.frame(tmp)
  names(tmp) <- n
  tmp
}

RenameBarcodes <- function(list, pool) {
# This function renames the barcodes in the samples to barcode.pool to remove ambuguity between the cell pools
    for (i in pool) {
    rownames(list[[i]]) <- paste(rownames(list[[i]]), deparse(substitute(pool)), sep = ".")
  }
  list
}

ReadsPerBarcode <- function(mutations) {
  #This function sums up all the mutations to count the number of reads per barcode.
  data.frame(barcode = row.names(mutations),
             reads = rowSums(mutations))
}

CalculateRatio <- function(mutations, indel) {
  # This function calculates the proportion of any indel over all the indels using the 
  # dataframe created with MutationsToDataframe.
  if (as.character(indel) %in% names(mutations)) {
    df <- data.frame(barcode = row.names(mutations),
             ratio = mutations[, as.character(indel)] / (rowSums(mutations)-mutations[, "0"]))
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel)))
    df
  }
  else {
    df <- data.frame(barcode = row.names(mutations),
             ratio = 0)
    colnames(df) <- c("barcode", paste0("ratio.", as.character(indel)))
    df
  }
}

CalculateEfficiencies <- function(efficiencies) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(efficiencies),
             efficiency = (1 - efficiencies[, "0"] / rowSums(efficiencies)) * 100)
}

CalculateInsertions <- function(insertions) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(insertions),
             insertions = (rowSums(insertions[, -grep('^[-0]',colnames(insertions))]) / rowSums(insertions)) * 100)
}

CalculateDeletions <- function(deletions) {
  # This function calculates the efficiency of the cut and repair at each barcode
  # using the dataframe created with MutationsToDataframe.
  data.frame(barcode = row.names(deletions),
             deletions = (rowSums(deletions[ ,grep('-',colnames(deletions))]) / rowSums(deletions)) * 100)
}

RowConfInt <- function(x, poolrows, lastcol) {
  d=as.numeric(x[poolrows])
  if (!isConstant(d[!is.na(d)])){
    if (!is.na(x[lastcol])) {
      result=as.numeric(x[lastcol])-as.numeric(t.test(d, na.rm=T)$conf.int[1])
      }
    else{
      result=NA
    }
  } else{
    result=NA
  };
  return(result)
}

RowPValue <- function(x, poolrows, lastcol) {
  d=as.numeric(x[poolrows])
  if (!isConstant(d[!is.na(d)])){
    if (!is.na(x[lastcol])) {
      result=as.numeric(t.test(d, na.rm=T)$p.value)
      }
    else{
      result=NA
    }
  } else{
    result=NA
  };
  return(result)
}

CalculateMeanVar <- function(mutations.list) {
  # This function combines the ratios that are calculated with CalculateRatio
  # and appended to the barcode list for each replicate.
  df <- NULL  # make an empty dataframe
  for (i in 1:length(mutations.list)) { # For each sample in mutation.list
    m <- CalculateEfficiencies(mutations.list[[i]])
    if (is.null(df)) {
      df <- efficiency
    } else {
      df <- merge(df, efficiency, by = "barcode", all = TRUE)
    
    }
    names(df)[ncol(df)] <- paste("efficiency", names(mutations.list)[i], sep = ".")
  }
  df
}

OverallIndels <- function(x) {
  colSums(x[,sapply(x, is.numeric)])
}

Not_Clear_Counts <- function(x){
tmp <- as(table(x$V2=="not_clear"), "matrix")
tmp <- data.frame(tmp)
tmp
}
```

## Data import
Data import from mapping. These files were generated on 30.09.2018, with a minimum of 500 reads per barcode in the mutation calling.
```{r import}
# Set directory to the mutation output folder of the CRISPR-TRIP snakemake script
setwd("~/mydata/projects/CRISPR_TRIP/20180918_TRIP_5106/data/processed/mutation/")
# Import files in list and make individual tables
# I use this if all the samples are good. Here however I do not use all the samples. 
file.list <- list.files(pattern='*.genuine_mapped.table')

# import the data
df.list <- lapply(file.list, read.table, sep = "\t")
# rename the lists
names(df.list) <- gsub('(*?).ge.*', '\\1', file.list)
# these are the samples
names(df.list)
# count the sample number
n.samples <- length(df.list)
```

### Some data pre-processing
Set everything in a datafram that contains the barcodes, indel ratios, and efficiencies.
```{r processing}
# To be able to setup the functions in a general way. This means in cases where we have A
# and B samples. 
A <- grep("_A_",  names(df.list))
B <- grep("_B_",  names(df.list))

# Combine the mutations in a list as dataframes for eacht sample.
mutations.list <- lapply(df.list, MutationsToDataframe)
mutations.list <- RenameBarcodes(mutations.list, pool = A)
mutations.list <- RenameBarcodes(mutations.list, pool = B)
# We need to get the total reads in each sample, here I'll get the sum of all the columns and rows from each dataframe.
```

Next we will work on a long dataframe that will include all the ratios (deletions, insertions, +1/-7 etc) for each barcode in each sample.

I found out that some barcodes overlap in A and B but do not have the same integration sites (this has a very low chance). It would be a pitty to trash them, and I do not want to merge them as they are integrated in differente locations. I will name all the barcodes in A sample to "barcode".A and in B to "barcode".B. For this I will use the n.samples to pick out only A and only B data.

 
# Analysis
## Not clear counts in the mutation data
```{r}
# Here I apply the Not_Clear_Counts, over the list, it does the counts of not_clear in the mutations list.
not.clear.list <- lapply(df.list, Not_Clear_Counts)
# I need to change the list into a data frame, and pull out the names of the samples, transform the data frame (this returns a matrix) and rechange it into a data frame. 
not.clear.df <- as.data.frame(t(setNames(as.data.frame(not.clear.list), names(not.clear.list))))
# change the column names
colnames(not.clear.df) <- c("other", "not_clear")
# Calculate the fraction of not clear
not.clear.df$nc_fraction <- not.clear.df$not_clear/not.clear.df$other*100
# What is the mean not clear fraction in our samples? 
mean(not.clear.df$nc_fraction)
# What is the median not clear fraction in our samples? 
median(not.clear.df$nc_fraction)
# What is the maximum not clear fraction in our samples?
max(not.clear.df$nc_fraction)
```
  
We have max 3.25% on not clear in our samples. The mean and median are both less than 2%, that is good.

# Indel proportions data frame. 
We will not calculate the +1 / -7 ratios, we will count the proportion of -22, -14 -7, +1 and +2. I want to have the total insertions, total deletions and efficiences. 
```{r calculateratios}
# Same for total amount of reads
reads.list <- lapply(mutations.list, ReadsPerBarcode)
reads.df <- ldply(reads.list, data.frame)
reads.df$barcode <- as.character(reads.df$barcode)

# Assing condition and plasmid tranfection from the sample names to a column.
reads.df$experiment <- gsub("indel_(.*?)_.*", "\\1", reads.df$.id)
reads.df$condition <- gsub("indel_.*?_.*?_.*?_.*?(.*?)", "\\1", reads.df$.id)
reads.df$plasmid <- gsub("indel_.*?_.*?_.*?(.*?)", "\\1", reads.df$.id)
reads.df$plasmid <- gsub("(.*?)_.*", "\\1", reads.df$plasmid)
# Let's plot the distribution of the amount of reads per barcode
p <- ggplot(reads.df, aes(log10(reads)))
p + geom_density()

# We can repeat all this for the efficiencies. 
# Fist make one dataframe for all the effiencies, deletions and insertions
efficiency.list <- lapply(mutations.list, CalculateEfficiencies)
efficiency.df <- ldply(efficiency.list, data.frame)
efficiency.df$barcode <- as.character(efficiency.df$barcode)
indel.ratios.df <- merge(reads.df, efficiency.df, by = c(".id", "barcode"))

deletions.list <- lapply(mutations.list, CalculateDeletions)
deletions.df <- ldply(deletions.list, data.frame)
deletions.df$barcode <- as.character(deletions.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, deletions.df, by = c(".id", "barcode"))

insertions.list <- lapply(mutations.list, CalculateInsertions)
insertions.df <- ldply(insertions.list, data.frame)
insertions.df$barcode <- as.character(insertions.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, insertions.df, by = c(".id", "barcode"))

# Calculate the proportion of some set indels
plus2.ratio.mutations.list <- lapply(mutations.list, indel = 2, CalculateRatio)
plus2.ratio.mutations.df <- ldply(plus2.ratio.mutations.list, data.frame)
plus2.ratio.mutations.df$barcode <- as.character(plus2.ratio.mutations.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, plus2.ratio.mutations.df, by = c(".id", "barcode"))

plus1.ratio.mutations.list <- lapply(mutations.list, indel = 1, CalculateRatio)
plus1.ratio.mutations.df <- ldply(plus1.ratio.mutations.list, data.frame)
plus1.ratio.mutations.df$barcode <- as.character(plus1.ratio.mutations.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, plus1.ratio.mutations.df, by = c(".id", "barcode"))

min7.ratio.mutations.list <- lapply(mutations.list, indel = -7, CalculateRatio)
min7.ratio.mutations.df <- ldply(min7.ratio.mutations.list, data.frame)
min7.ratio.mutations.df$barcode <- as.character(min7.ratio.mutations.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, min7.ratio.mutations.df, by = c(".id", "barcode"))

min14.ratio.mutations.list <- lapply(mutations.list, indel = -14, CalculateRatio)
min14.ratio.mutations.df <- ldply(min14.ratio.mutations.list, data.frame)
min14.ratio.mutations.df$barcode <- as.character(min14.ratio.mutations.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, min14.ratio.mutations.df, by = c(".id", "barcode"))

min22.ratio.mutations.list <- lapply(mutations.list, indel = -22, CalculateRatio)
min22.ratio.mutations.df <- ldply(min22.ratio.mutations.list, data.frame)
min22.ratio.mutations.df$barcode <- as.character(min22.ratio.mutations.df$barcode)
indel.ratios.df <- merge(indel.ratios.df, min22.ratio.mutations.df, by = c(".id", "barcode"))

dim(indel.ratios.df)

# Rename the first column to sample
colnames(indel.ratios.df)[1] <- "sample"

head(indel.ratios.df)
```


Conclusion : The distribution of barcodes is clealry not as biassed as in the 100 pools.
This is much more linear, except for the upper few. But this is not a big concern.
```{r ratioplots}
p <- ggplot(indel.ratios.df, aes(x = efficiency,  y = sample, color = plasmid))
p + geom_point(show.legend = FALSE) + 
     theme_bw()

p <- ggplot(indel.ratios.df[indel.ratios.df$experiment == "2", ], aes(x = ratio.1,  y = sample, color = condition))
p + geom_point(show.legend = F) + 
     theme_bw()
p <- ggplot(indel.ratios.df[indel.ratios.df$experiment == "2", ], aes(x = ratio.2,  y = sample, color = condition))
p + geom_point(show.legend = F) + 
     theme_bw()
p <- ggplot(indel.ratios.df[indel.ratios.df$experiment == "2", ], aes(x = ratio..7,  y = sample, color = condition))
p + geom_point(show.legend = F) + 
     theme_bw()
```

```{r means}
# For the following operations it's better to work with a data table
tib_indel_ratios <- as.data.table(indel.ratios.df)

dim(tib_indel_ratios)
# Let's make the mean of all the standart LBR2 samples (no drugs, DMSO, 64h)
#### LBR2 ####
LBR2.mutations.dt <- tib_indel_ratios[(tib_indel_ratios$condition %in% 
                                         c("-", "DMSO", "ODNOT_DMSO", "t64", "DMSO_t64", "siNT")) & 
                                        tib_indel_ratios$plasmid=="LBR2", ]

setkey(LBR2.mutations.dt, barcode)
LBR2.mean.ratios.dt <- LBR2.mutations.dt %>% 
                        group_by(barcode) %>% 
                        dplyr::summarise(deletions = mean(deletions), 
                                         insertions = mean(insertions), 
                                         reads = sum(reads), 
                                         ratio..7 = as.numeric(mean(ratio..7)),
                                         ratio.1 = as.numeric(mean(ratio.1)), 
                                         ratio.2 = as.numeric(mean(ratio.2)), 
                                         ratio..14 = as.numeric(mean(ratio..14)), 
                                         ratio..22 = as.numeric(mean(ratio..22)), 
                                         condition = "LBR2_mean",
                                         plasmid = "LBR2")

head(LBR2.mean.ratios.dt)
dim(LBR2.mean.ratios.dt)
#### NU7441 ####
LBR2.NU7441.mutations.dt <- tib_indel_ratios[(tib_indel_ratios$condition %in% 
                                         c("NU7441", "NU7441_t64", "ODNOT_NU7441")) & 
                                        tib_indel_ratios$plasmid=="LBR2", ]

setkey(LBR2.NU7441.mutations.dt, barcode)
LBR2.NU7441.mean.ratios.dt <- LBR2.NU7441.mutations.dt %>% 
                        group_by(barcode) %>% 
                        dplyr::summarise(deletions = mean(deletions), 
                                         insertions = mean(insertions), 
                                         reads = sum(reads), 
                                         ratio..7 = as.numeric(mean(ratio..7)),
                                         ratio.1 = as.numeric(mean(ratio.1)), 
                                         ratio.2 = as.numeric(mean(ratio.2)), 
                                         ratio..14 = as.numeric(mean(ratio..14)), 
                                         ratio..22 = as.numeric(mean(ratio..22)), 
                                         condition = "NU7441_mean", 
                                         plasmid = "LBR2")

head(LBR2.NU7441.mean.ratios.dt)
dim(LBR2.NU7441.mean.ratios.dt)
#### late ####
LBR2.late.mutations.dt <- tib_indel_ratios[(tib_indel_ratios$condition %in% 
                                         c("t92", "DMSO_t88")) & 
                                        tib_indel_ratios$plasmid=="LBR2", ]

setkey(LBR2.late.mutations.dt, barcode)
LBR2.late.mean.ratios.dt <- LBR2.late.mutations.dt %>% 
                        group_by(barcode) %>% 
                        dplyr::summarise(deletions = mean(deletions), 
                                         insertions = mean(insertions), 
                                         reads = sum(reads), 
                                         ratio..7 = as.numeric(mean(ratio..7)),
                                         ratio.1 = as.numeric(mean(ratio.1)), 
                                         ratio.2 = as.numeric(mean(ratio.2)), 
                                         ratio..14 = as.numeric(mean(ratio..14)), 
                                         ratio..22 = as.numeric(mean(ratio..22)), 
                                         condition = "t90_mean",
                                         plasmid = "LBR2")

head(LBR2.late.mean.ratios.dt)
dim(LBR2.late.mean.ratios.dt)

#### ODN3 ####
LBR2.ODN3.mutations.dt <- tib_indel_ratios[(tib_indel_ratios$condition %in% 
                                         c("ssODN3_DMSO_t64", "ODN3_DMSO")) & 
                                        tib_indel_ratios$plasmid=="LBR2", ]

setkey(LBR2.ODN3.mutations.dt, barcode)
LBR2.ODN3.mean.ratios.dt <- LBR2.ODN3.mutations.dt %>% 
                        group_by(barcode) %>% 
                        dplyr::summarise(deletions = mean(deletions), 
                                         insertions = mean(insertions), 
                                         reads = sum(reads), 
                                         ratio..7 = as.numeric(mean(ratio..7)),
                                         ratio.1 = as.numeric(mean(ratio.1)), 
                                         ratio.2 = as.numeric(mean(ratio.2)), 
                                         ratio..14 = as.numeric(mean(ratio..14)), 
                                         ratio..22 = as.numeric(mean(ratio..22)), 
                                         condition = "ODN3_mean",
                                         plasmid = "LBR2")

head(LBR2.ODN3.mean.ratios.dt)
dim(LBR2.ODN3.mean.ratios.dt)

#### ODN3 NU7441 ####
LBR2.ODN3.NU7441.mutations.dt <- tib_indel_ratios[(tib_indel_ratios$condition %in% 
                                         c("ssODN3_NU7441_t64", "ODN3_NU7441")) & 
                                        tib_indel_ratios$plasmid=="LBR2", ]

setkey(LBR2.ODN3.NU7441.mutations.dt, barcode)
LBR2.ODN3.NU7441.mean.ratios.dt <- LBR2.ODN3.NU7441.mutations.dt %>% 
                                      group_by(barcode) %>% 
                                      dplyr::summarise(deletions = mean(deletions), 
                                                       insertions = mean(insertions), 
                                                       reads = sum(reads), 
                                                       ratio..7 = as.numeric(mean(ratio..7)),
                                                       ratio.1 = as.numeric(mean(ratio.1)), 
                                                       ratio.2 = as.numeric(mean(ratio.2)), 
                                                       ratio..14 = as.numeric(mean(ratio..14)), 
                                                       ratio..22 = as.numeric(mean(ratio..22)), 
                                                       condition = "ODN3_NU7441_mean",
                                                       plasmid = "LBR2")

head(LBR2.ODN3.NU7441.mean.ratios.dt)
dim(LBR2.ODN3.NU7441.mean.ratios.dt)

#### Make one with all the other data ####
grouped.samples <- c(unique(LBR2.mutations.dt$sample), 
                     unique(LBR2.NU7441.mutations.dt$sample), 
                     unique(LBR2.late.mutations.dt$sample), 
                     unique(LBR2.ODN3.mutations.dt$sample), 
                     unique(LBR2.ODN3.NU7441.mutations.dt$sample))

other.ratios.dt <- tib_indel_ratios[(!tib_indel_ratios$sample %in% grouped.samples) & !(tib_indel_ratios$plasmid %in% c("-guide", "GFP")), ]
# We can rename the columns of the ratios in the other.ratios.dt so that they are merged. 



#### Merge ####
mean.ratios.dt <- rbindlist(list(LBR2.mean.ratios.dt,
                                        LBR2.NU7441.mean.ratios.dt,
                                        LBR2.late.mean.ratios.dt,
                                        LBR2.ODN3.mean.ratios.dt,
                                        LBR2.ODN3.NU7441.mean.ratios.dt,
                                        other.ratios.dt), 
                          use.names = TRUE, 
                          fill = TRUE)
dim(mean.ratios.dt)
mean.ratios.dt
```


```{r barcodes}
# Quick plot to check the barcode abundancy, to be sure that there is no
# big bias towards some barcodes that are super abundant
par(mfrow=c(2,2))
for (i in 1:n.samples) {
  barcodesum <- sort(rowSums(mutations.list[[i]]))
  plot(barcodesum, main = paste("Sample", names(mutations.list[i])))
  # I figured out that you need at least 1000 reads to get correct statistic.
  filteredbarcodesum <- barcodesum[barcodesum>1000]
  if (length(filteredbarcodesum)==0) {
    print(paste0("no barcodes with more than 1000 reads in filtered ", names(mutations.list[i])))
  }
  else {
    plot(filteredbarcodesum, 
         main = paste("Sample filtered", names(mutations.list[i])))
  }
  print(paste(names(mutations.list[i]),":", length(barcodesum)))
  print(paste("Filtered", names(mutations.list[i]),":", length(filteredbarcodesum)))
}

```


## Processed data export
The files will be saved in the processed data folder.
```{r}
setwd("../data/processed/")
# The mutations list that can be loaded for the indel spectra plots.
filename <- paste0("rs", Sys.Date(), "_All.IndelFreqData.RData")
filename <- gsub("-", "", filename)
save(mutations.list, file = filename)

# The ratios data that can be loaded for the chromatin analysis.
filename <- paste0("rs", Sys.Date(), "_All.Ratios.RData")
filename <- gsub("-", "", filename)
save(indel.ratios.df, file = filename)

# The mean ratios data for LBR2 normal conditions that can be loaded for the chromatin analysis.
filename <- paste0("rs", Sys.Date(), "_LBR2.mean.Ratios.RData")
filename <- gsub("-", "", filename)
save(LBR2.mean.ratios.dt, file = filename)

# The means file for mapping analysis.
filename <- paste0("rs", Sys.Date(), "_MeanRatioTotalReads.RData")
filename <- gsub("-", "", filename)
save(mean.ratios.dt, file = filename)

```
### Conclusions 
I'm happy with the output I've generated. I should still work on checking what the best amount of reads is that I need for correct correlations etc.

### Session Info
```{r}

sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))

```

