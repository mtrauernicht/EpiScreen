---
title: "Parsing_QC"
author: "Ruben Schep"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---

knitr document van Steensel lab

# Parsing and starcode quality control
# Introduction
After demultiplexing all the samples from the sequencing data, the data has been processed by the CRISPR-TRIP snakemake script. This script maps the barcodes from the iPCR (iPCR from 5 feb 2018). It calls the true barcodes with the starcode script for both the mutation and mapping reads. It call the mutations on all the mutation samples and spits them in mapped, unmapped and non genuine.

Here we want to do a QC of the parsing of the mapping, the barcodes and mutations. We will load the statistics data of all the files. We will also look at barcode counts from the table files (those list the barcodes from the starcode stript). I obtained the counts though shell with `cd ~/mydata/projects/CRISPR_TRIP/20180918_TRIP_5106/data/processed/mutation ;`  
`wc -l * > ~/mydata/projects/CRISPR_TRIP/20180918_TRIP_5106/data/processed/rs20180930_starcode_barcode_counts.txt`.   
Pasted the result in a text editor and changes all the spaced to only 1 tab, and saved as text file. 

I will export a bed file also containing the broad integrations for the generation of mean chip values over the integration sites. 

## Description of Data
The statistics files look like this for the mapping:
```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
|	reads	|	bp	|	reads_written	|	bp_written	|	n_tooshort	|	index	|	map_pat1a	|	const_bar	|	rev_map_complement	|	rev_map	|	fwd_map_complement|
|----|----|----|----|----|----|----|----|----|----|----|
|19828607	|	5869267672	|	13923655	|	1901947251	|	0	|	19828607	|	19159557	|	14908545	|	8002804	|	13923655	|	7831360|

"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

And like this for the mutations : 
```{r table2, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
|	reads	|	bp	|	reads_written	|	bp_written	|	n_tooshort	|	pat1	|	barcode	|	pat2|
|----|----|----|----|----|----|----|----|
|	1917323	|	268435236	|	1523275	|	146262106	|	0	|	1802163	|	1802150	|	1523275|
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

For the genuine (mapped and unmapped) and non-genuine barcode counts I will just get the line counts of the files.   

679811      indel_1_A_GFP_DMSO_t16.genuine_mapped  
695310      indel_1_A_GFP_DMSO_t16.genuine_unmapped  
452964      indel_1_A_GFP_DMSO_t16.not_genuine  
1828085    	indel_1_A_GFP_DMSO_t16.raw  
422130      indel_1_A_GFP_DMSO_t64.genuine_mapped  
331931    	indel_1_A_GFP_DMSO_t64.genuine_unmapped  
337248    	indel_1_A_GFP_DMSO_t64.not_genuine   

# Data loading and processing 

## Path, Libraries, Parameters and Useful Functions  

```{r message=FALSE}
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),3,8) 

# libraries:
library(plyr)
library(dplyr)
library(GenomicRanges)
library(RColorBrewer)
library(ggplot2)
library(magrittr)
```
 
## Custom functions  

Functions used in this script:   

```{r}
MakeGranges <- function(x) {
  x$end_pos <- as.numeric(as.character(x$start_pos+3))
  colnames(x) <- c("name",
                   "seqname", 
                   "strand", 
                   "start",
                   "total_mapped", 
                   "mapq_sum1", 
                   "reads1", 
                   "mapq_sum2", 
                   "reads2", 
                   "seq", 
                   "end")
  gr <- makeGRangesFromDataFrame(x, keep.extra.columns = T)
  return(gr)
}

BarcodeOverlap <- function(read1, read2) {
  counts <- c(nrow(read1), 
              nrow(read2), 
              sum(read2$barcode %in% read1$barcode), 
              sum(!read1$barcode %in% read2$barcode),
              sum(!read2$barcode %in% read1$barcode))
}
```

## Data loading  

These are data from the crispr-trip.snake script, and a text file that has has been obtained as explained above.  

```{r}
# First I load the statistics data from the mapping.
setwd("/DATA/projects/DSBrepair/data/5280_DrugScreen/processed/parsed/")

file.list <- list.files(pattern='mutation*.*statistics.txt')
indel.statistics.list <- lapply(file.list, 
                                read.table, 
                                header = TRUE)
names(indel.statistics.list)<- gsub('mutation.(.*?).statistics.txt', 
                                    '\\1', 
                                    file.list)
# we need to remove the index column for the time being
indel.statistics.list <- lapply(indel.statistics.list, function(x) { x["index"] <- NULL; x })
indel.statistics.df <- do.call(rbind.data.frame, 
                               indel.statistics.list)

```

# Analysis  

## Parsing QC  

This data is pulled form the statistics files in `/parsed/`  

Here we want to look at the porportion of reads that contain the sequences (constant and barcodes) that we expect.   
It's an overall check of the PCR and sequencing quality.  

### Indel parsing  


```{r}
rownames(indel.statistics.df)
mypalette<-brewer.pal(5,"Greens")
barplot(as.matrix(t(indel.statistics.df[c(89:98, 1:6),c(1,3,6:8)])), 
        col = mypalette,
        beside = T, 
        main = "Read parsing statistics", 
        ylab = "reads", 
        legend = colnames(indel.statistics.df[,c(1,3,6:8)]), 
        las = 2,
        cex.names = 0.4,
        cex.axis = 0.6,
        args.legend = list(x = "topright", cex = 0.6))

barplot(as.matrix(t(indel.statistics.df[c(7:18),c(1,3,6:8)])), 
        col = mypalette,
        beside = T, 
        main = "Read parsing statistics", 
        ylab = "reads", 
        legend = colnames(indel.statistics.df[,c(1,3,6:8)]), 
        las = 2,
        cex.names = 0.4,
        cex.axis = 0.6,
        args.legend = list(x = "topright", cex = 0.6))

barplot(as.matrix(t(indel.statistics.df[c(19:48),c(1,3,6:8)])), 
        col = mypalette,
        beside = T, 
        main = "Read parsing statistics", 
        ylab = "reads", 
        legend = colnames(indel.statistics.df[,c(1,3,6:8)]), 
        las = 2,
        cex.names = 0.4,
        cex.axis = 0.6,
        args.legend = list(x = "topright", cex = 0.6))

barplot(as.matrix(t(indel.statistics.df[c(49:64),c(1,3,6:8)])), 
        col = mypalette,
        beside = T, 
        main = "Read parsing statistics", 
        ylab = "reads", 
        legend = colnames(indel.statistics.df[,c(1,3,6:8)]), 
        las = 2,
        cex.names = 0.4,
        cex.axis = 0.6,
        args.legend = list(x = "topright", cex = 0.6))

barplot(as.matrix(t(indel.statistics.df[c(65:76),c(1,3,6:8)])), 
        col = mypalette,
        beside = T, 
        main = "Read parsing statistics", 
        ylab = "reads", 
        legend = colnames(indel.statistics.df[,c(1,3,6:8)]), 
        las = 2,
        cex.names = 0.4,
        cex.axis = 0.6,
        args.legend = list(x = "topright", cex = 0.6))

barplot(as.matrix(t(indel.statistics.df[c(77:88),c(1,3,6:8)])), 
        col = mypalette,
        beside = T, 
        main = "Read parsing statistics", 
        ylab = "reads", 
        legend = colnames(indel.statistics.df[,c(1,3,6:8)]), 
        las = 2,
        cex.names = 0.4,
        cex.axis = 0.6,
        args.legend = list(x = "topright", cex = 0.6))

# % of reads written from the total reads :
indelreadswritten.vec <- indel.statistics.df$reads_written/indel.statistics.df$reads*100
names(indelreadswritten.vec) <- rownames(indel.statistics.df)
barplot(indelreadswritten.vec, 
        las=2, 
        cex.names = 0.4)

```

 

# Session Info  
```{r}
sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))

```